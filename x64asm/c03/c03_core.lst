     1                                  ;c03_core.asm:简易内核，李忠，2021-9-3
     2                                  
     3                                  %include "..\common\global_defs.wid"
     4                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     5                              <1> 
     6                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     7                              <1> 
     8                              <1> %ifndef _GLOBAL_DEFS_
     9                              <1>    %define _GLOBAL_DEFS_
    10                              <1> 
    11                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    12                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    13                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    14                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    15                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    16                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    17                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    18                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    19                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    20                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    21                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    22                              <1> 	                                        ;页目录指针表
    23                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    24                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    25                              <1> 
    26                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    27                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    28                              <1> 
    29                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    30                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    31                              <1> 	                                                                ;端起始线性地址
    32                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    33                              <1> 	                                                                ;性地址
    34                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    35                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    36                              <1> 
    37                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    38                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    39                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    40                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    41                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    42                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    43                              <1> 
    44                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    45                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    46                              <1> 			;时的起始地址
    47                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    48                              <1> 			;时的起始地址
    49                              <1> 
    50                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    51                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    52                              <1> 
    53                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    54                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    55                              <1> 
    56                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    57                              <1> 
    58                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    59                              <1> 
    60                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    61                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    62                              <1>             %%spin_lock:
    63                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    64                              <1>                        je %%get_lock      	;获取锁
    65                              <1>                        pause
    66                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    67                              <1>             %%get_lock:
    68                              <1>                        mov %1, 1
    69                              <1>                        xchg %1, %2
    70                              <1>                        cmp %1, 0          	;交换前为零？
    71                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    72                              <1>    %endmacro
    73                              <1> 
    74                              <1> %endif
    75                              <1> 
     4                                  
     5                                  ;===============================================================================
     6                                  section core_header                               ;内核程序头部
     7 00000000 [6A0B0000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     8 00000004 [7E0A0000]                init_entry   dd init                            ;#4：内核入口点
     9 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    10                                  
    11                                  ;===============================================================================
    12                                  section core_data                                 ;内核数据段
    13 00000000 457865637574696E67-       welcome      db "Executing in 64-bit mode.", 0x0d, 0x0a, 0
    13 00000009 20696E2036342D6269-
    13 00000012 74206D6F64652E0D0A-
    13 0000001B 00                 
    14                                  
    15                                  ;===============================================================================
    16                                  section core_code                                 ;内核代码段
    17                                  
    18                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    19                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    20                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    21                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    22                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    23                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    24                              <1> 
    25                              <1> %include "..\common\global_defs.wid"
    26                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    27                              <2> 
    28                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    29                              <2> 
    30                              <2> %ifndef _GLOBAL_DEFS_
    31                              <2>    %define _GLOBAL_DEFS_
    32                              <2> 
    33                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    34                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    35                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    36                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    37                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    38                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    39                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    40                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    41                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    42                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    43                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    44                              <2> 	                                        ;页目录指针表
    45                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    46                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    47                              <2> 
    48                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    49                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    50                              <2> 
    51                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    52                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    53                              <2> 	                                                                ;端起始线性地址
    54                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    55                              <2> 	                                                                ;性地址
    56                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    57                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    58                              <2> 
    59                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    60                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    61                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    62                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    63                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    64                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    65                              <2> 
    66                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    67                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    68                              <2> 			;时的起始地址
    69                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    70                              <2> 			;时的起始地址
    71                              <2> 
    72                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    73                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    74                              <2> 
    75                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    76                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    77                              <2> 
    78                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    79                              <2> 
    80                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    81                              <2> 
    82                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    83                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    84                              <2>             %%spin_lock:
    85                              <2>                        cmp %2, 0           	;锁是释放状态吗？
    86                              <2>                        je %%get_lock      	;获取锁
    87                              <2>                        pause
    88                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
    89                              <2>             %%get_lock:
    90                              <2>                        mov %1, 1
    91                              <2>                        xchg %1, %2
    92                              <2>                        cmp %1, 0          	;交换前为零？
    93                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    94                              <2>    %endmacro
    95                              <2> 
    96                              <2> %endif
    97                              <2> 
    26                              <1> 
    27                              <1>          bits 64
    28                              <1> 
    29                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    30                              <1> %ifdef __MP__
    31                              <1> _prn_str_locker dq 0                  	;打印锁
    32                              <1> %endif
    33                              <1> 
    34                              <1> put_string64:       	;显示0终止的字符串并移动光标
    35                              <1>                      	;输入：RBX=字符串的线性地址
    36 00000000 53                  <1>          push rbx
    37 00000001 51                  <1>          push rcx
    38                              <1> 
    39 00000002 9C                  <1>          pushfq     	;-->A
    40 00000003 FA                  <1>          cli
    41                              <1> %ifdef __MP__
    42                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    43                              <1> %endif
    44                              <1> 
    45                              <1>   .getc:
    46 00000004 8A0B                <1>          mov cl, [rbx]
    47 00000006 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    48 00000008 740A                <1>          jz .exit                 	;显示完毕，返回
    49 0000000A E809000000          <1>          call put_char
    50 0000000F 48FFC3              <1>          inc rbx
    51 00000012 EBF0                <1>          jmp .getc
    52                              <1> 
    53                              <1>   .exit:
    54                              <1> %ifdef __MP__
    55                              <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    56                              <1> %endif
    57 00000014 9D                  <1>          popfq                               	;A
    58                              <1> 
    59 00000015 59                  <1>          pop rcx
    60 00000016 5B                  <1>          pop rbx
    61                              <1> 
    62 00000017 C3                  <1>          ret                                	;段内返回
    63                              <1> 
    64                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    65                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
    66                              <1> 	;进光标。
    67                              <1>                                            	;输入：CL=字符ASCII码
    68 00000018 50                  <1>          push rax
    69 00000019 53                  <1>          push rbx
    70 0000001A 51                  <1>          push rcx
    71 0000001B 52                  <1>          push rdx
    72 0000001C 56                  <1>          push rsi
    73 0000001D 57                  <1>          push rdi
    74                              <1> 
    75                              <1>          ;以下取当前光标位置
    76 0000001E 66BAD403            <1>          mov dx, 0x3d4
    77 00000022 B00E                <1>          mov al, 0x0e
    78 00000024 EE                  <1>          out dx, al
    79 00000025 66FFC2              <1>          inc dx                        	;0x3d5
    80 00000028 EC                  <1>          in al, dx                     	;高字
    81 00000029 88C4                <1>          mov ah, al
    82                              <1> 
    83 0000002B 66FFCA              <1>          dec dx                        	;0x3d4
    84 0000002E B00F                <1>          mov al, 0x0f
    85 00000030 EE                  <1>          out dx, al
    86 00000031 66FFC2              <1>          inc dx                        	;0x3d5
    87 00000034 EC                  <1>          in al, dx                     	;低字
    88 00000035 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
    89 00000038 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
    90                              <1> 
    91 0000003F 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
    92 00000042 750E                <1>          jnz .put_0a
    93 00000044 6689D8              <1>          mov ax, bx
    94 00000047 B350                <1>          mov bl, 80
    95 00000049 F6F3                <1>          div bl
    96 0000004B F6E3                <1>          mul bl
    97 0000004D 6689C3              <1>          mov bx, ax
    98 00000050 EB6C                <1>          jmp .set_cursor
    99                              <1> 
   100                              <1>   .put_0a:
   101 00000052 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   102 00000055 7506                <1>          jnz .put_other
   103 00000057 6683C350            <1>          add bx, 80
   104 0000005B EB16                <1>          jmp .roll_screen
   105                              <1> 
   106                              <1>   .put_other:                              	;正常显示字符
   107 0000005D 66D1E3              <1>          shl bx, 1
   108 00000060 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   108 00000069 FF                  <1>
   109 0000006A 880C18              <1>          mov [rax + rbx], cl
   110                              <1> 
   111                              <1>          ;以下将光标位置推进一个字符
   112 0000006D 66D1EB              <1>          shr bx, 1
   113 00000070 66FFC3              <1>          inc bx
   114                              <1> 
   115                              <1>   .roll_screen:
   116 00000073 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   117 00000078 7C44                <1>          jl .set_cursor
   118                              <1> 
   119 0000007A 6653                <1>          push bx
   120                              <1> 
   121 0000007C FC                  <1>          cld
   122 0000007D 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   122 00000086 FF                  <1>
   123 00000087 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   123 00000090 FF                  <1>
   124 00000091 B9E0010000          <1>          mov rcx, 480
   125 00000096 F348A5              <1>          rep movsq
   126 00000099 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   127 0000009D B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   128                              <1>   .cls:
   129 000000A2 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   129 000000AB FF                  <1>
   130 000000AC 66C704182007        <1>          mov word[rax + rbx], 0x0720
   131 000000B2 6683C302            <1>          add bx, 2
   132 000000B6 E2EA                <1>          loop .cls
   133                              <1> 
   134 000000B8 665B                <1>          pop bx
   135 000000BA 6683EB50            <1>          sub bx, 80
   136                              <1> 
   137                              <1>   .set_cursor:
   138 000000BE 66BAD403            <1>          mov dx, 0x3d4
   139 000000C2 B00E                <1>          mov al, 0x0e
   140 000000C4 EE                  <1>          out dx, al
   141 000000C5 66FFC2              <1>          inc dx                         	;0x3d5
   142 000000C8 88F8                <1>          mov al, bh
   143 000000CA EE                  <1>          out dx, al
   144 000000CB 66FFCA              <1>          dec dx       	;0x3d4
   145 000000CE B00F                <1>          mov al, 0x0f
   146 000000D0 EE                  <1>          out dx, al
   147 000000D1 66FFC2              <1>          inc dx       	;0x3d5
   148 000000D4 88D8                <1>          mov al, bl
   149 000000D6 EE                  <1>          out dx, al
   150                              <1> 
   151 000000D7 5F                  <1>          pop rdi
   152 000000D8 5E                  <1>          pop rsi
   153 000000D9 5A                  <1>          pop rdx
   154 000000DA 59                  <1>          pop rcx
   155 000000DB 5B                  <1>          pop rbx
   156 000000DC 58                  <1>          pop rax
   157                              <1> 
   158 000000DD C3                  <1>          ret
   159                              <1> 
   160                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   161                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   162                              <1> ;不同，互不干扰，不需要加锁和互斥。
   163                              <1> %ifdef __MP__
   164                              <1> _prnxy_locker dq 0
   165                              <1> %endif
   166                              <1> 
   167                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   168                              <1>                                           	;DH=行，DL=列
   169                              <1>                                           	;R9B=颜色属性
   170 000000DE 50                  <1>          push rax
   171 000000DF 53                  <1>          push rbx
   172 000000E0 51                  <1>          push rcx
   173 000000E1 52                  <1>          push rdx
   174 000000E2 4150                <1>          push r8
   175                              <1> 
   176                              <1>          ;指定坐标位置在显存内的偏移量
   177 000000E4 88F0                <1>          mov al, dh
   178 000000E6 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   179 000000E8 F6E5                <1>          mul ch
   180 000000EA D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   181 000000EC 6681E2FF00          <1>          and dx, 0x00ff
   182 000000F1 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   183 000000F4 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   184                              <1> 
   185 000000FA 9C                  <1>          pushfq                        	;-->A
   186 000000FB FA                  <1>          cli
   187                              <1> %ifdef __MP__
   188                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   189                              <1> %endif
   190                              <1> 
   191 000000FC 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   191 00000105 FF                  <1>
   192                              <1>   .nextc:
   193 00000106 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   194 00000108 08D2                <1>          or dl, dl
   195 0000010A 7412                <1>          jz .exit
   196 0000010C 41881400            <1>          mov byte [r8 + rax], dl
   197 00000110 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   198 00000115 48FFC3              <1>          inc rbx
   199 00000118 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   200 0000011C EBE8                <1>          jmp .nextc
   201                              <1>   .exit:
   202 0000011E 4D31C0              <1>          xor r8, r8
   203                              <1> %ifdef __MP__
   204                              <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   205                              <1> %endif
   206 00000121 9D                  <1>          popfq                              	;A
   207                              <1> 
   208 00000122 4158                <1>          pop r8
   209 00000124 5A                  <1>          pop rdx
   210 00000125 59                  <1>          pop rcx
   211 00000126 5B                  <1>          pop rbx
   212 00000127 58                  <1>          pop rax
   213                              <1> 
   214 00000128 C3                  <1>          ret
   215                              <1> 
   216                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   217                              <1> make_call_gate:                          	;创建64位的调用门
   218                              <1>                                           	;输入：RAX=例程的线性地址
   219                              <1>                                           	;输出：RDI:RSI=调用门
   220 00000129 4889C7              <1>          mov rdi, rax
   221 0000012C 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   222                              <1> 
   223 00000130 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   224 00000131 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   225 00000138 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   226 0000013C 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   227 00000143 5E                  <1>          pop rsi
   228                              <1> 
   229 00000144 C3                  <1>          ret
   230                              <1> 
   231                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   232                              <1> make_interrupt_gate:                      	;创建64位的中断门
   233                              <1>                                             	;输入：RAX=例程的线性地址
   234                              <1>                                             	;输出：RDI:RSI=中断门
   235 00000145 4889C7              <1>          mov rdi, rax
   236 00000148 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   237                              <1> 
   238 0000014C 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   239 0000014D 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   240 00000154 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   241 00000158 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   242 0000015F 5E                  <1>          pop rsi
   243                              <1> 
   244 00000160 C3                  <1>          ret
   245                              <1> 
   246                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   247                              <1> make_trap_gate:                             	;创建64位的陷阱门
   248                              <1>                                              	;输入：RAX=例程的线性地址
   249                              <1>                                              	;输出：RDI:RSI=陷阱门
   250 00000161 4889C7              <1>          mov rdi, rax
   251 00000164 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   252                              <1> 
   253 00000168 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   254 00000169 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   255 00000170 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   256 00000174 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   257 0000017B 5E                  <1>          pop rsi
   258                              <1> 
   259 0000017C C3                  <1>          ret
   260                              <1> 
   261                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   262                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   263                              <1>                                           	;输入：RAX=TSS的线性地址
   264                              <1>                                           	;输出：RDI:RSI=TSS描述符
   265 0000017D 50                  <1>          push rax
   266                              <1> 
   267 0000017E 4889C7              <1>          mov rdi, rax
   268 00000181 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   269                              <1> 
   270 00000185 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   271 00000186 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   272 0000018B 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   273 00000191 8A442405            <1>          mov al, [rsp + 5]
   274 00000195 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   275 00000199 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   276 0000019E C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   277 000001A3 5E                  <1>          pop rsi                       	;门的低64位
   278                              <1> 
   279 000001A4 58                  <1>          pop rax
   280                              <1> 
   281 000001A5 C3                  <1>          ret
   282                              <1> 
   283                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   284                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   285                              <1>                                        	;R8=中断向量
   286                              <1>                                        	;RDI:RSI=门描述符
   287 000001A6 4150                <1>          push r8
   288 000001A8 4151                <1>          push r9
   289                              <1> 
   290 000001AA 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   291 000001AE 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   291 000001B7 FF                  <1>
   292 000001B8 4B893401            <1>          mov [r9 + r8], rsi
   293 000001BC 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   294                              <1> 
   295 000001C1 4159                <1>          pop r9
   296 000001C3 4158                <1>          pop r8
   297                              <1> 
   298 000001C5 C3                  <1>          ret
   299                              <1> 
   300                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   301                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   302 000001C6 50                  <1>          push rax
   303                              <1> 
   304 000001C7 B011                <1>          mov al, 0x11
   305 000001C9 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   306 000001CB B020                <1>          mov al, 0x20
   307 000001CD E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   308 000001CF B004                <1>          mov al, 0x04
   309 000001D1 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   310 000001D3 B001                <1>          mov al, 0x01
   311 000001D5 E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   312                              <1> 
   313 000001D7 B011                <1>          mov al, 0x11
   314 000001D9 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   315 000001DB B028                <1>          mov al, 0x28
   316 000001DD E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   317 000001DF B002                <1>          mov al, 0x02
   318 000001E1 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   319 000001E3 B001                <1>          mov al, 0x01
   320 000001E5 E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   321                              <1> 
   322 000001E7 58                  <1>          pop rax
   323 000001E8 C3                  <1>          ret
   324                              <1> 
   325                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   326                              <1> %ifdef __MP__
   327                              <1> _read_hdd_locker dq 0                 	;读硬盘锁
   328                              <1> %endif
   329                              <1> 
   330                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   331                              <1>                                         	;RAX=逻辑扇区号
   332                              <1>                                         	;RBX=目标缓冲区线性地址
   333                              <1>                                         	;返回：RBX=RBX+512
   334 000001E9 50                  <1>          push rax
   335 000001EA 51                  <1>          push rcx
   336 000001EB 52                  <1>          push rdx
   337                              <1> 
   338 000001EC 9C                  <1>          pushfq                     	;-->A
   339 000001ED FA                  <1>          cli
   340                              <1> %ifdef __MP__
   341                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   342                              <1> %endif
   343                              <1> 
   344 000001EE 50                  <1>          push rax
   345                              <1> 
   346 000001EF 66BAF201            <1>          mov dx, 0x1f2
   347 000001F3 B001                <1>          mov al, 1
   348 000001F5 EE                  <1>          out dx, al                	;读取的扇区数
   349                              <1> 
   350 000001F6 66FFC2              <1>          inc dx                    	;0x1f3
   351 000001F9 58                  <1>          pop rax
   352 000001FA EE                  <1>          out dx, al               	;LBA地址7~0
   353                              <1> 
   354 000001FB 66FFC2              <1>          inc dx                   	;0x1f4
   355 000001FE B108                <1>          mov cl, 8
   356 00000200 48D3E8              <1>          shr rax, cl
   357 00000203 EE                  <1>          out dx, al   	;LBA地址15~8
   358                              <1> 
   359 00000204 66FFC2              <1>          inc dx       	;0x1f5
   360 00000207 48D3E8              <1>          shr rax, cl
   361 0000020A EE                  <1>          out dx, al  	;LBA地址23~16
   362                              <1> 
   363 0000020B 66FFC2              <1>          inc dx       	;0x1f6
   364 0000020E 48D3E8              <1>          shr rax, cl
   365 00000211 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   366 00000213 EE                  <1>          out dx, al
   367                              <1> 
   368 00000214 66FFC2              <1>          inc dx       	;0x1f7
   369 00000217 B020                <1>          mov al, 0x20 	;读命令
   370 00000219 EE                  <1>          out dx, al
   371                              <1> 
   372                              <1>   .waits:
   373 0000021A EC                  <1>          in al, dx
   374                              <1>          ;and al, 0x88
   375                              <1>          ;cmp al, 0x08
   376 0000021B A808                <1>          test al, 8
   377 0000021D 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   378                              <1> 
   379 0000021F B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   380 00000224 66BAF001            <1>          mov dx, 0x1f0
   381                              <1>   .readw:
   382 00000228 66ED                <1>          in ax, dx
   383 0000022A 668903              <1>          mov [rbx], ax
   384 0000022D 4883C302            <1>          add rbx, 2
   385 00000231 E2F5                <1>          loop .readw
   386                              <1> 
   387                              <1> %ifdef __MP__
   388                              <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   389                              <1> %endif
   390 00000233 9D                  <1>          popfq                              			;A
   391                              <1> 
   392 00000234 5A                  <1>          pop rdx
   393 00000235 59                  <1>          pop rcx
   394 00000236 58                  <1>          pop rax
   395                              <1> 
   396 00000237 C3                  <1>          ret
   397                              <1> 
   398                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   399 00000238 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   400 00000278 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   401                              <1>   _page_map_len  equ $ - _page_bit_map
   402                              <1> 
   403                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   404                              <1>                                             			;输入：无
   405                              <1>                                             			;输出：RAX=页的物理地址
   406 00000638 4831C0              <1>          xor rax, rax
   407                              <1>   .b1:
   408 0000063B F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   409 00000644 730B                <1>          jnc .b2
   410 00000646 48FFC0              <1>          inc rax
   411 00000649 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   412 0000064F 7CEA                <1>          jl .b1
   413                              <1> 
   414                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   415                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   416                              <1>          ;面的换入和换出。
   417                              <1> 
   418                              <1>   .b2:
   419 00000651 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   420                              <1> 
   421 00000655 C3                  <1>          ret
   422                              <1> 
   423                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   424                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   425                              <1>                                      	;输入：R13=线性地址
   426                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   427 00000656 4155                <1>          push r13
   428                              <1> 
   429 00000658 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   429 00000661 00                  <1>
   430 00000662 4D21F5              <1>          and r13, r14
   431 00000665 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   432                              <1> 
   433 00000669 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   434 00000670 4D01EE              <1>          add r14, r13
   435                              <1> 
   436 00000673 415D                <1>          pop r13
   437                              <1> 
   438 00000675 C3                  <1>          ret
   439                              <1> 
   440                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   441                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   442                              <1>                                     	;输入：R13=线性地址
   443                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   444 00000676 4155                <1>          push r13
   445                              <1> 
   446 00000678 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   446 00000681 00                  <1>
   447 00000682 4D21F5              <1>          and r13, r14
   448 00000685 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   449                              <1> 
   450 00000689 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   451 00000690 4D01EE              <1>          add r14, r13
   452                              <1> 
   453 00000693 415D                <1>          pop r13
   454                              <1> 
   455 00000695 C3                  <1>          ret
   456                              <1> 
   457                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   458                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   459                              <1>                                      	;输入：R13=线性地址
   460                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   461 00000696 4155                <1>          push r13
   462                              <1> 
   463 00000698 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   463 000006A1 00                  <1>
   464                              <1> 	;索引部分
   465 000006A2 4D21F5              <1>          and r13, r14
   466 000006A5 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   467                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   468 000006A9 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   469 000006B0 4D01EE              <1>          add r14, r13
   470 000006B3 415D                <1>          pop r13
   471                              <1> 
   472 000006B5 C3                  <1>          ret
   473                              <1> 
   474                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   475                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   476                              <1>                                    	;输入：R13=线性地址
   477                              <1>                                    	;输出：R14=对应的页表项的线性地址
   478 000006B6 4155                <1>          push r13
   479                              <1> 
   480 000006B8 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   480 000006C1 00                  <1>
   481                              <1> 	                                ;索引部分
   482 000006C2 4D21F5              <1>          and r13, r14
   483 000006C5 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   484                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   485 000006C9 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   485 000006D2 FF                  <1>
   486 000006D3 4D01EE              <1>          add r14, r13
   487                              <1> 
   488 000006D6 415D                <1>          pop r13
   489 000006D8 C3                  <1>          ret
   490                              <1> 
   491                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   492                              <1> %ifdef __MP__
   493                              <1> _spaging_locker dq 0
   494                              <1> %endif
   495                              <1> 
   496                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   497                              <1>                                    	;输入：R13=线性地址
   498 000006D9 51                  <1>          push rcx
   499 000006DA 50                  <1>          push rax
   500 000006DB 4156                <1>          push r14
   501                              <1> 
   502 000006DD 9C                  <1>          pushfq                   	;-->A
   503 000006DE FA                  <1>          cli
   504                              <1> %ifdef __MP__
   505                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   506                              <1> %endif
   507                              <1> 
   508                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   509                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   510 000006DF E872FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   511 000006E4 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   512 000006EB 752B                <1>          jnz .b0
   513                              <1> 
   514                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   515 000006ED E846FFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   516 000006F2 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   517 000006F6 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   518                              <1> 
   519                              <1>          ;清空刚分配的页目录指针表
   520 000006F9 E878FFFFFF          <1>          call lin_to_lin_of_pdpte
   521 000006FE 49C1EE0C            <1>          shr r14, 12
   522 00000702 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   523 00000706 B900020000          <1>          mov rcx, 512
   524                              <1>   .cls0:
   525 0000070B 49C70600000000      <1>          mov qword [r14], 0
   526 00000712 4983C608            <1>          add r14, 8
   527 00000716 E2F3                <1>          loop .cls0
   528                              <1> ;-------------------------------------------------
   529                              <1>   .b0:
   530                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   531 00000718 E859FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   532 0000071D 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   533 00000724 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   534                              <1> 
   535                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   536 00000726 E80DFFFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   537 0000072B 4883C807            <1>          or rax, 0x07                  	;添加属性位
   538 0000072F 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   539                              <1> 
   540                              <1>          ;清空刚分配的页目录表
   541 00000732 E85FFFFFFF          <1>          call lin_to_lin_of_pdte
   542 00000737 49C1EE0C            <1>          shr r14, 12
   543 0000073B 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   544 0000073F B900020000          <1>          mov rcx, 512
   545                              <1>   .cls1:
   546 00000744 49C70600000000      <1>          mov qword [r14], 0
   547 0000074B 4983C608            <1>          add r14, 8
   548 0000074F E2F3                <1>          loop .cls1
   549                              <1> ;-------------------------------------------------
   550                              <1>   .b1:
   551                              <1>          ;检查该线性地址所对应的页目录项是否存在
   552 00000751 E840FFFFFF          <1>          call lin_to_lin_of_pdte
   553 00000756 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   554 0000075D 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   555                              <1> 
   556                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   557 0000075F E8D4FEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   558 00000764 4883C807            <1>          or rax, 0x07                      	;添加属性位
   559 00000768 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   560                              <1> 
   561                              <1>          ;清空刚分配的页表
   562 0000076B E846FFFFFF          <1>          call lin_to_lin_of_pte
   563 00000770 49C1EE0C            <1>          shr r14, 12
   564 00000774 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   565 00000778 B900020000          <1>          mov rcx, 512
   566                              <1>   .cls2:
   567 0000077D 49C70600000000      <1>          mov qword [r14], 0
   568 00000784 4983C608            <1>          add r14, 8
   569 00000788 E2F3                <1>          loop .cls2
   570                              <1> ;-------------------------------------------------
   571                              <1>   .b2:
   572                              <1>          ;检查该线性地址所对应的页表项是否存在
   573 0000078A E827FFFFFF          <1>          call lin_to_lin_of_pte
   574 0000078F 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   575 00000796 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   576                              <1> 
   577                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   578 00000798 E89BFEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   579 0000079D 4883C807            <1>          or rax, 0x07                     	;添加属性位
   580 000007A1 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   581                              <1> 
   582                              <1>   .b3:
   583                              <1> %ifdef __MP__
   584                              <1>          mov qword [rel _spaging_locker], 0
   585                              <1> %endif
   586 000007A4 9D                  <1>          popfq                      	;A
   587                              <1> 
   588 000007A5 415E                <1>          pop r14
   589 000007A7 58                  <1>          pop rax
   590 000007A8 59                  <1>          pop rcx
   591                              <1> 
   592 000007A9 C3                  <1>          ret
   593                              <1> 
   594                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   595                              <1> %ifdef __MP__
   596                              <1> _mapping_locker dq 0
   597                              <1> %endif
   598                              <1> 
   599                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   600                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   601                              <1>                                    	;输入：R13=线性地址
   602                              <1>                                                    ;RAX=页的物理地址（含属性）
   603 000007AA 51                  <1>          push rcx
   604 000007AB 4156                <1>          push r14
   605                              <1> 
   606 000007AD 9C                  <1>          pushfq
   607 000007AE FA                  <1>          cli
   608                              <1> %ifdef __MP__
   609                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   610                              <1> %endif
   611                              <1> 
   612 000007AF 50                  <1>          push rax
   613                              <1> 
   614                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   615                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   616 000007B0 E8A1FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   617 000007B5 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   618 000007BC 752B                <1>          jnz .b0
   619                              <1> 
   620                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   621 000007BE E875FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   622 000007C3 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   623 000007C7 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   624                              <1> 
   625                              <1>          ;清空刚分配的页目录指针表
   626 000007CA E8A7FEFFFF          <1>          call lin_to_lin_of_pdpte
   627 000007CF 49C1EE0C            <1>          shr r14, 12
   628 000007D3 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   629 000007D7 B900020000          <1>          mov rcx, 512
   630                              <1>   .cls0:
   631 000007DC 49C70600000000      <1>          mov qword [r14], 0
   632 000007E3 4983C608            <1>          add r14, 8
   633 000007E7 E2F3                <1>          loop .cls0
   634                              <1> ;-------------------------------------------------
   635                              <1>   .b0:
   636                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   637 000007E9 E888FEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   638 000007EE 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   639 000007F5 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   640                              <1> 
   641                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   642 000007F7 E83CFEFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   643 000007FC 4883C807            <1>          or rax, 0x07              	;添加属性位
   644 00000800 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   645                              <1> 
   646                              <1>          ;清空刚分配的页目录表
   647 00000803 E88EFEFFFF          <1>          call lin_to_lin_of_pdte
   648 00000808 49C1EE0C            <1>          shr r14, 12
   649 0000080C 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   650 00000810 B900020000          <1>          mov rcx, 512
   651                              <1>   .cls1:
   652 00000815 49C70600000000      <1>          mov qword [r14], 0
   653 0000081C 4983C608            <1>          add r14, 8
   654 00000820 E2F3                <1>          loop .cls1
   655                              <1> ;-------------------------------------------------
   656                              <1>   .b1:
   657                              <1>          ;检查该线性地址所对应的页目录项是否存在
   658 00000822 E86FFEFFFF          <1>          call lin_to_lin_of_pdte
   659 00000827 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   660 0000082E 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   661                              <1> 
   662                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   663 00000830 E803FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   664 00000835 4883C807            <1>          or rax, 0x07                  	;添加属性位
   665 00000839 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   666                              <1> 
   667                              <1>          ;清空刚分配的页表
   668 0000083C E875FEFFFF          <1>          call lin_to_lin_of_pte
   669 00000841 49C1EE0C            <1>          shr r14, 12
   670 00000845 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   671 00000849 B900020000          <1>          mov rcx, 512
   672                              <1>   .cls2:
   673 0000084E 49C70600000000      <1>          mov qword [r14], 0
   674 00000855 4983C608            <1>          add r14, 8
   675 00000859 E2F3                <1>          loop .cls2
   676                              <1> ;-------------------------------------------------
   677                              <1>   .b2:
   678 0000085B E856FEFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   679 00000860 58                  <1>          pop rax
   680 00000861 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   681                              <1> 
   682                              <1> %ifdef __MP__
   683                              <1>          mov qword [rel _mapping_locker], 0
   684                              <1> %endif
   685 00000864 9D                  <1>          popfq
   686                              <1> 
   687 00000865 415E                <1>          pop r14
   688 00000867 59                  <1>          pop rcx
   689                              <1> 
   690 00000868 C3                  <1>          ret
   691                              <1> 
   692                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   693 00000869 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   694                              <1> 
   695                              <1> %ifdef __MP__
   696                              <1>   _core_alloc_locker dq 0
   697                              <1> %endif
   698                              <1> 
   699                              <1> core_memory_allocate:                 	;在虚拟地址空间的高端（内核）分配内存
   700                              <1>                                         	;输入：RCX=请求分配的字节数
   701                              <1>                                         	;输出：R13=本次分配的起始线性地址
   702                              <1>                                         	;      R14=下次分配的起始线性地址
   703 00000871 9C                  <1>          pushfq                        	;A-->
   704 00000872 FA                  <1>          cli
   705                              <1> %ifdef __MP__
   706                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   707                              <1> %endif
   708                              <1> 
   709 00000873 4C8B2DEFFFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   710 0000087A 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   711                              <1> 
   712 0000087F 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   713 00000886 740C                <1>          jz .algn
   714 00000888 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   715 0000088C 49C1EE03            <1>          shr r14, 3
   716 00000890 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   717                              <1> 
   718                              <1>   .algn:
   719 00000894 4C8935CEFFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   720                              <1> 
   721                              <1> %ifdef __MP__
   722                              <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   723                              <1> %endif
   724 0000089B 9D                  <1>          popfq                             	;A
   725                              <1> 
   726 0000089C 4155                <1>          push r13
   727 0000089E 4156                <1>          push r14
   728                              <1> 
   729                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   730 000008A0 49C1ED0C            <1>          shr r13, 12
   731 000008A4 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   732 000008A8 49C1EE0C            <1>          shr r14, 12
   733 000008AC 49C1E60C            <1>          shl r14, 12                    	;too
   734                              <1>   .next:
   735 000008B0 E824FEFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   736 000008B5 4981C500100000      <1>          add r13, 0x1000               	;+4096
   737 000008BC 4D39F5              <1>          cmp r13, r14
   738 000008BF 7EEF                <1>          jle .next
   739                              <1> 
   740 000008C1 415E                <1>          pop r14
   741 000008C3 415D                <1>          pop r13
   742                              <1> 
   743 000008C5 C3                  <1>          ret
   744                              <1> 
   745                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   746                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   747                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   748                              <1>                                    	;      RCX=希望分配的字节数
   749                              <1>                                    	;输出：R13=本次分配的起始线性地址
   750                              <1>                                    	;      R14=下次分配的起始线性地址
   751                              <1>          ;获得本次内存分配的起始线性地址
   752 000008C6 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   753 000008CA 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   754                              <1> 
   755 000008CF 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   756 000008D6 740C                <1>          jz .algn
   757 000008D8 49C1EE03            <1>          shr r14, 3
   758 000008DC 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   759 000008E0 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   760                              <1> 
   761                              <1>   .algn:
   762 000008E4 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   763                              <1> 
   764 000008E8 4155                <1>          push r13
   765 000008EA 4156                <1>          push r14
   766                              <1> 
   767                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   768 000008EC 49C1ED0C            <1>          shr r13, 12
   769 000008F0 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   770 000008F4 49C1EE0C            <1>          shr r14, 12
   771 000008F8 49C1E60C            <1>          shl r14, 12                 	;too
   772                              <1>   .next:
   773 000008FC E8D8FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   774 00000901 4981C500100000      <1>          add r13, 0x1000                ;+4096
   775 00000908 4D39F5              <1>          cmp r13, r14
   776 0000090B 7EEF                <1>          jle .next
   777                              <1> 
   778 0000090D 415E                <1>          pop r14
   779 0000090F 415D                <1>          pop r13
   780                              <1> 
   781 00000911 C3                  <1>          ret
   782                              <1> 
   783                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   784                              <1> %ifdef __MP__
   785                              <1> _copy_locker dq 0
   786                              <1> %endif
   787                              <1> 
   788                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   789                              <1>                                         	;输入：无
   790                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   791 00000912 56                  <1>          push rsi
   792 00000913 57                  <1>          push rdi
   793 00000914 4155                <1>          push r13
   794 00000916 51                  <1>          push rcx
   795                              <1> 
   796 00000917 9C                  <1>          pushfq                                   	;-->A
   797 00000918 FA                  <1>          cli
   798                              <1> %ifdef __MP__
   799                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   800                              <1> %endif
   801                              <1> 
   802 00000919 E81AFDFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   803 0000091E 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   804 00000922 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   804 0000092B FF                  <1>
   805 0000092C E879FEFFFF          <1>          call mapping_laddr_to_page
   806                              <1> 
   807                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   808 00000931 410F017D00          <1>          invlpg [r13]
   809                              <1> 
   810 00000936 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   811 0000093D 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   812 00000940 B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   813 00000945 FC                  <1>          cld
   814 00000946 F348A5              <1>          repe movsq
   815                              <1> 
   816 00000949 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   817 00000950 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   818                              <1> 
   819                              <1> %ifdef __MP__
   820                              <1>          mov qword [rel _copy_locker], 0
   821                              <1> %endif
   822 00000958 9D                  <1>          popfq                    	;A
   823                              <1> 
   824 00000959 59                  <1>          pop rcx
   825 0000095A 415D                <1>          pop r13
   826 0000095C 5F                  <1>          pop rdi
   827 0000095D 5E                  <1>          pop rsi
   828                              <1> 
   829 0000095E C3                  <1>          ret
   830                              <1> 
   831                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   832                              <1> %ifdef __MP__
   833                              <1> _cmos_locker dq 0
   834                              <1> %endif
   835                              <1> 
   836                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   837                              <1>                                        	;输入：RBX=缓冲区线性地址
   838 0000095F 50                  <1>          push rax
   839                              <1> 
   840 00000960 9C                  <1>          pushfq                       	;-->A
   841 00000961 FA                  <1>          cli
   842                              <1> %ifdef __MP__
   843                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   844                              <1> %endif
   845                              <1> 
   846                              <1>   .w0:
   847 00000962 B08A                <1>          mov al, 0x8a
   848 00000964 E670                <1>          out 0x70, al
   849 00000966 E471                <1>          in al, 0x71                 	;读寄存器A
   850 00000968 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   851 0000096A 75F6                <1>          jnz .w0
   852                              <1> 
   853 0000096C B084                <1>          mov al, 0x84
   854 0000096E E670                <1>          out 0x70, al
   855 00000970 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   856 00000972 88C4                <1>          mov ah, al
   857                              <1> 
   858 00000974 C0EC04              <1>          shr ah, 4
   859 00000977 80E40F              <1>          and ah, 0x0f
   860 0000097A 80C430              <1>          add ah, 0x30
   861 0000097D 8823                <1>          mov [rbx], ah
   862                              <1> 
   863 0000097F 240F                <1>          and al, 0x0f
   864 00000981 0430                <1>          add al, 0x30
   865 00000983 884301              <1>          mov [rbx + 1], al
   866                              <1> 
   867 00000986 C643023A            <1>          mov byte [rbx + 2], ':'
   868                              <1> 
   869 0000098A B082                <1>          mov al, 0x82
   870 0000098C E670                <1>          out 0x70, al
   871 0000098E E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   872 00000990 88C4                <1>          mov ah, al
   873                              <1> 
   874 00000992 C0EC04              <1>          shr ah, 4
   875 00000995 80E40F              <1>          and ah, 0x0f
   876 00000998 80C430              <1>          add ah, 0x30
   877 0000099B 886303              <1>          mov [rbx + 3], ah
   878                              <1> 
   879 0000099E 240F                <1>          and al, 0x0f
   880 000009A0 0430                <1>          add al, 0x30
   881 000009A2 884304              <1>          mov [rbx + 4], al
   882                              <1> 
   883 000009A5 C643053A            <1>          mov byte [rbx + 5], ':'
   884                              <1> 
   885 000009A9 B080                <1>          mov al, 0x80
   886 000009AB E670                <1>          out 0x70, al
   887 000009AD E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   888 000009AF 88C4                <1>          mov ah, al              	;分拆成两个数字
   889                              <1> 
   890 000009B1 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   891 000009B4 80E40F              <1>          and ah, 0x0f
   892 000009B7 80C430              <1>          add ah, 0x30
   893 000009BA 886306              <1>          mov [rbx + 6], ah
   894                              <1> 
   895 000009BD 240F                <1>          and al, 0x0f               	;仅保留低4位
   896 000009BF 0430                <1>          add al, 0x30               	;转换成ASCII
   897 000009C1 884307              <1>          mov [rbx + 7], al
   898                              <1> 
   899 000009C4 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   900                              <1> 
   901                              <1> %ifdef __MP__
   902                              <1>          mov qword [rel _cmos_locker], 0
   903                              <1> %endif
   904 000009C8 9D                  <1>          popfq                	;A
   905                              <1> 
   906 000009C9 58                  <1>          pop rax
   907                              <1> 
   908 000009CA C3                  <1>          ret
   909                              <1> 
   910                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   911 000009CB 0000000000000000    <1>   _process_id        dq 0
   912                              <1> 
   913                              <1> generate_process_id:                  	;生成唯一的进程标识
   914                              <1>                                         	;返回：RAX=进程标识
   915 000009D3 B801000000          <1>          mov rax, 1
   916 000009D8 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   917                              <1> 
   918 000009E1 C3                  <1>          ret
   919                              <1> 
   920                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   921 000009E2 0000000000000000    <1>   _thread_id dq 0
   922                              <1> 
   923                              <1> generate_thread_id:                 	;生成唯一的线程标识
   924                              <1>                                       	;返回：RAX=线程标识
   925 000009EA B801000000          <1>          mov rax, 1
   926 000009EF F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   927                              <1> 
   928 000009F8 C3                  <1>          ret
   929                              <1> 
   930                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   931 000009F9 08                  <1>   _screen_row        db 8
   932                              <1> 
   933                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   934                              <1>                                      	;返回：DH=行号
   935 000009FA B601                <1>          mov dh, 1
   936 000009FC F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   937                              <1> 
   938 00000A04 C3                  <1>          ret
   939                              <1> 
   940                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   941                              <1> get_cpu_number:                        	;返回当前处理器的编号
   942                              <1>                                         	;返回：RAX=处理器编号
   943 00000A05 9C                  <1>          pushfq
   944 00000A06 FA                  <1>          cli
   945 00000A07 0F01F8              <1>          swapgs
   946 00000A0A 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   947 00000A13 0F01F8              <1>          swapgs
   948 00000A16 9D                  <1>          popfq
   949 00000A17 C3                  <1>          ret
   950                              <1> 
   951                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   952                              <1> memory_allocate:                       	;用户空间的内存分配
   953                              <1>                                          	;进入：RDX=期望分配的字节数
   954                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   955 00000A18 51                  <1>          push rcx
   956 00000A19 4153                <1>          push r11
   957 00000A1B 4156                <1>          push r14
   958                              <1> 
   959 00000A1D 9C                  <1>          pushfq
   960 00000A1E FA                  <1>          cli
   961 00000A1F 0F01F8              <1>          swapgs
   962 00000A22 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
   963 00000A2B 0F01F8              <1>          swapgs
   964 00000A2E 9D                  <1>          popfq
   965                              <1> 
   966 00000A2F 4889D1              <1>          mov rcx, rdx
   967 00000A32 E88FFEFFFF          <1>          call user_memory_allocate
   968                              <1> 
   969 00000A37 415E                <1>          pop r14
   970 00000A39 415B                <1>          pop r11
   971 00000A3B 59                  <1>          pop rcx
   972                              <1> 
   973 00000A3C C3                  <1>          ret
   974                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    19                                  
    20                                           bits 64
    21                                  
    22                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    23                                  general_interrupt_handler:                        ;通用中断处理过程
    24 00000A3D 48CF                             iretq
    25                                  
    26                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    27                                  general_exception_handler:                        ;通用异常处理过程
    28                                                                                    ;在24行0列显示红底白字的错误信息
    29 00000A3F 4C8B3D(08000000)                mov r15, [rel position]
    30 00000A46 498D9F[5B0A0000]                lea rbx, [r15 + exceptm]
    31 00000A4D B618                            mov dh, 24
    32 00000A4F B200                            mov dl, 0
    33 00000A51 41B14F                          mov r9b, 0x4f
    34 00000A54 E885F6FFFF                      call put_cstringxy64                      ;位于core_utils64.wid
    35                                  
    36 00000A59 FA                              cli
    37 00000A5A F4                              hlt                                       ;停机且不接受外部硬件中断
    38                                  
    39 00000A5B 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
    39 00000A64 6F6E20726169736564-
    39 00000A6D 2C68616C742E00     
    40                                  
    41                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    42                                  general_8259ints_handler:                         ;通用的8259中断处理过程
    43 00000A74 50                               push rax
    44                                  
    45 00000A75 B020                             mov al, 0x20                             ;中断结束命令EOI
    46 00000A77 E6A0                             out 0xa0, al                             ;向从片发送
    47 00000A79 E620                             out 0x20, al                             ;向主片发送
    48                                  
    49 00000A7B 58                               pop rax
    50                                  
    51 00000A7C 48CF                             iretq
    52                                  
    53                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    54                                  init:    ;初始化内核的工作环境
    55                                  
    56                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
    57                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
    58 00000A7E 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
    58 00000A87 FF                 
    59 00000A88 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
    60                                  
    61 00000A90 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
    62                                  
    63                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
    64                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
    65 00000A98 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
    65 00000AA1 FF                 
    66 00000AA2 4801C4                           add rsp,rax                              ;栈指针必须转换为高端地址且必须是扩高地址
    67                                  
    68                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
    69 00000AA5 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
    69 00000AAE FF                 
    70 00000AAF 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
    71                                  
    72                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
    73 00000AB6 488B05(08000000)                 mov rax, [rel position]
    74 00000ABD 4805[C50A0000]                   add rax, .to_upper
    75 00000AC3 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
    76                                  
    77                                    .to_upper:
    78                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
    79                                  
    80                                           ;为32个异常创建通用处理过程的中断门
    81 00000AC5 4C8B0D(08000000)                 mov r9, [rel position]
    82 00000ACC 498D81[3F0A0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
    83 00000AD3 E86DF6FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
    84                                  
    85 00000AD8 4D31C0                           xor r8, r8
    86                                    .idt0:
    87 00000ADB E8C6F6FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
    88 00000AE0 49FFC0                           inc r8
    89 00000AE3 4983F81F                         cmp r8, 31
    90 00000AE7 7EF2                             jle .idt0
    91                                  
    92                                           ;创建并安装对应于其它中断的通用处理过程的中断门
    93 00000AE9 498D81[3D0A0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
    94 00000AF0 E850F6FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
    95                                  
    96 00000AF5 41B820000000                     mov r8, 32
    97                                    .idt1:
    98 00000AFB E8A6F6FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
    99 00000B00 49FFC0                           inc r8
   100 00000B03 4981F8FF000000                   cmp r8, 255
   101 00000B0A 7EEF                             jle .idt1
   102                                  
   103 00000B0C 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   103 00000B15 FF                 
   104 00000B16 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   104 00000B1F FF                 
   105 00000B20 4889430E                         mov qword [rbx + 0x0e], rax
   106 00000B24 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   107                                  
   108 00000B2A 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   109                                  
   110                                           ;初始化8259中断控制器，包括重新设置中断向量号
   111 00000B2E E893F6FFFF                       call init_8259
   112                                  
   113                                           ;创建并安装16个8259中断处理过程的中断门，向量0x20--0x2f
   114 00000B33 498D81[740A0000]                 lea rax, [r9 + general_8259ints_handler] ;得到通用8259中断处理过程的线性地址
   115 00000B3A E806F6FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   116                                  
   117 00000B3F 41B820000000                     mov r8, 0x20
   118                                    .8259:
   119 00000B45 E85CF6FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   120 00000B4A 49FFC0                           inc r8
   121 00000B4D 4983F82F                         cmp r8, 0x2f
   122 00000B51 7EF2                             jle .8259
   123                                  
   124 00000B53 FB                               sti                                      ;开放硬件中断
   125                                  
   126                                           ;在64位模式下显示的第一条信息!
   127 00000B54 4C8B3D(08000000)                 mov r15, [rel position]
   128 00000B5B 498D9F[00000000]                 lea rbx, [r15 + welcome]
   129 00000B62 E899F4FFFF                       call put_string64                        ;位于core_utils64.wid
   130                                  
   131                                    .halt:
   132 00000B67 F4                              hlt
   133 00000B68 EBFD                            jmp .halt
   134                                  
   135                                  
   136                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   137                                  core_end:
