     1                                  ;c07_core.asm:多处理器多线程内核，李忠，2022-10-29
     2                                  
     3                                  %define __MP__
     4                                  
     5                                  %include "..\common\global_defs.wid"
     6                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     7                              <1> 
     8                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     9                              <1> 
    10                              <1> %ifndef _GLOBAL_DEFS_
    11                              <1>    %define _GLOBAL_DEFS_
    12                              <1> 
    13                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    14                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    15                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    16                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    17                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    18                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    19                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    20                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    21                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    22                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    23                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    24                              <1> 	                                        ;页目录指针表
    25                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    26                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    27                              <1> 
    28                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    29                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    30                              <1> 
    31                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    32                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    33                              <1> 	                                                                ;端起始线性地址
    34                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    35                              <1> 	                                                                ;性地址
    36                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    37                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    38                              <1> 
    39                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    40                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    41                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    42                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    43                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    44                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    45                              <1> 
    46                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    47                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    48                              <1> 			;时的起始地址
    49                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    50                              <1> 			;时的起始地址
    51                              <1> 
    52                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    53                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    54                              <1> 
    55                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    56                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    57                              <1> 
    58                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    59                              <1> 
    60                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    61                              <1> 
    62                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    63                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    64                              <1>             %%spin_lock:
    65                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    66                              <1>                        je %%get_lock      	;获取锁
    67                              <1>                        pause
    68                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    69                              <1>             %%get_lock:
    70                              <1>                        mov %1, 1
    71                              <1>                        xchg %1, %2
    72                              <1>                        cmp %1, 0          	;交换前为零？
    73                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    74                              <1>    %endmacro
    75                              <1> 
    76                              <1> %endif
    77                              <1> 
     6                                  
     7                                  ;===============================================================================
     8                                  section core_header                               ;内核程序头部
     9 00000000 [00000000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
    10 00000004 [2D140000]                init_entry   dd init                            ;#4：内核入口点
    11 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    12                                  
    13                                  ;===============================================================================
    14                                  section core_data                                 ;内核数据段
    15 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    15 00000009 6F7420737570706F72-
    15 00000012 746564206F72206461-
    15 0000001B 7461206572726F722E-
    15 00000024 0D0A00             
    16                                  
    17 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    18 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    19 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    20                                  
    21 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    22 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    23                                  
    24 00000131 00                        ack_cpus     db 0                               ;处理器初始化应答计数
    25                                  
    26 00000132 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    27                                  
    28 00000136 457865637574696E67-       welcome      db "Executing in 64-bit mode.Init MP", 249, 0
    28 0000013F 20696E2036342D6269-
    28 00000148 74206D6F64652E496E-
    28 00000151 6974204D50F900     
    29 00000158 204350552873292072-       cpu_init_ok  db " CPU(s) ready.", 0x0d, 0x0a, 0
    29 00000161 656164792E0D0A00   
    30                                  
    31 00000169 00<rep 100h>              buffer       times 256 db 0
    32                                  
    33 00000269 [960B000000000000]        sys_entry    dq get_screen_row                  ;#0
    34 00000271 [D00A000000000000]                     dq get_cmos_time                   ;#1
    35 00000279 [1901000000000000]                     dq put_cstringxy64                 ;#2
    36 00000281 [6A12000000000000]                     dq create_process                  ;#3
    37 00000289 [A710000000000000]                     dq get_current_pid                 ;#4
    38 00000291 [F410000000000000]                     dq terminate_process               ;#5
    39 00000299 [A10B000000000000]                     dq get_cpu_number                  ;#6
    40 000002A1 [5811000000000000]                     dq create_thread                   ;#7
    41 000002A9 [9010000000000000]                     dq get_current_tid                 ;#8
    42 000002B1 [BE10000000000000]                     dq thread_exit                     ;#9
    43 000002B9 [B40B000000000000]                     dq memory_allocate                 ;#10
    44 000002C1 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    45                                  
    46                                  ;===============================================================================
    47                                  section core_code                                 ;内核代码段
    48                                  
    49                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    50                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    51                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    52                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    53                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    54                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    55                              <1> 
    56                              <1> %include "..\common\global_defs.wid"
    57                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    58                              <2> 
    59                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    60                              <2> 
    61                              <2> %ifndef _GLOBAL_DEFS_
    62                              <2>    %define _GLOBAL_DEFS_
    63                              <2> 
    64                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    65                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    66                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    67                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    68                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    69                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    70                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    71                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    72                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    73                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    74                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    75                              <2> 	                                        ;页目录指针表
    76                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    77                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    78                              <2> 
    79                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    80                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    81                              <2> 
    82                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    83                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    84                              <2> 	                                                                ;端起始线性地址
    85                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    86                              <2> 	                                                                ;性地址
    87                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    88                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    89                              <2> 
    90                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    91                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    92                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    93                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    94                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    95                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    96                              <2> 
    97                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    98                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    99                              <2> 			;时的起始地址
   100                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
   101                              <2> 			;时的起始地址
   102                              <2> 
   103                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
   104                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
   105                              <2> 
   106                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
   107                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
   108                              <2> 
   109                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
   110                              <2> 
   111                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
   112                              <2> 
   113                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   114                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
   115                              <2>             %%spin_lock:
   116                              <2>                        cmp %2, 0           	;锁是释放状态吗？
   117                              <2>                        je %%get_lock      	;获取锁
   118                              <2>                        pause
   119                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
   120                              <2>             %%get_lock:
   121                              <2>                        mov %1, 1
   122                              <2>                        xchg %1, %2
   123                              <2>                        cmp %1, 0          	;交换前为零？
   124                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
   125                              <2>    %endmacro
   126                              <2> 
   127                              <2> %endif
   128                              <2> 
    57                              <1> 
    58                              <1>          bits 64
    59                              <1> 
    60                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    61                              <1> %ifdef __MP__
    62 00000000 0000000000000000    <1> _prn_str_locker dq 0                  	;打印锁
    63                              <1> %endif
    64                              <1> 
    65                              <1> put_string64:       	;显示0终止的字符串并移动光标
    66                              <1>                      	;输入：RBX=字符串的线性地址
    67 00000008 53                  <1>          push rbx
    68 00000009 51                  <1>          push rcx
    69                              <1> 
    70 0000000A 9C                  <1>          pushfq     	;-->A
    71 0000000B FA                  <1>          cli
    72                              <1> %ifdef __MP__
    73                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    64                              <2>  %%spin_lock:
    65 0000000C 48833DECFFFFFF00    <2>  cmp %2, 0
    66 00000014 7404                <2>  je %%get_lock
    67 00000016 F390                <2>  pause
    68 00000018 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000001A B901000000          <2>  mov %1, 1
    71 0000001F 48870DDAFFFFFF      <2>  xchg %1, %2
    72 00000026 4883F900            <2>  cmp %1, 0
    73 0000002A 75E0                <2>  jne %%spin_lock
    74                              <1> %endif
    75                              <1> 
    76                              <1>   .getc:
    77 0000002C 8A0B                <1>          mov cl, [rbx]
    78 0000002E 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    79 00000030 740A                <1>          jz .exit                 	;显示完毕，返回
    80 00000032 E814000000          <1>          call put_char
    81 00000037 48FFC3              <1>          inc rbx
    82 0000003A EBF0                <1>          jmp .getc
    83                              <1> 
    84                              <1>   .exit:
    85                              <1> %ifdef __MP__
    86 0000003C 48C705B9FFFFFF0000- <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    86 00000045 0000                <1>
    87                              <1> %endif
    88 00000047 9D                  <1>          popfq                               	;A
    89                              <1> 
    90 00000048 59                  <1>          pop rcx
    91 00000049 5B                  <1>          pop rbx
    92                              <1> 
    93 0000004A C3                  <1>          ret                                	;段内返回
    94                              <1> 
    95                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    96                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
    97                              <1> 	;进光标。
    98                              <1>                                            	;输入：CL=字符ASCII码
    99 0000004B 50                  <1>          push rax
   100 0000004C 53                  <1>          push rbx
   101 0000004D 51                  <1>          push rcx
   102 0000004E 52                  <1>          push rdx
   103 0000004F 56                  <1>          push rsi
   104 00000050 57                  <1>          push rdi
   105                              <1> 
   106                              <1>          ;以下取当前光标位置
   107 00000051 66BAD403            <1>          mov dx, 0x3d4
   108 00000055 B00E                <1>          mov al, 0x0e
   109 00000057 EE                  <1>          out dx, al
   110 00000058 66FFC2              <1>          inc dx                        	;0x3d5
   111 0000005B EC                  <1>          in al, dx                     	;高字
   112 0000005C 88C4                <1>          mov ah, al
   113                              <1> 
   114 0000005E 66FFCA              <1>          dec dx                        	;0x3d4
   115 00000061 B00F                <1>          mov al, 0x0f
   116 00000063 EE                  <1>          out dx, al
   117 00000064 66FFC2              <1>          inc dx                        	;0x3d5
   118 00000067 EC                  <1>          in al, dx                     	;低字
   119 00000068 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
   120 0000006B 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
   121                              <1> 
   122 00000072 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
   123 00000075 750E                <1>          jnz .put_0a
   124 00000077 6689D8              <1>          mov ax, bx
   125 0000007A B350                <1>          mov bl, 80
   126 0000007C F6F3                <1>          div bl
   127 0000007E F6E3                <1>          mul bl
   128 00000080 6689C3              <1>          mov bx, ax
   129 00000083 EB6C                <1>          jmp .set_cursor
   130                              <1> 
   131                              <1>   .put_0a:
   132 00000085 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   133 00000088 7506                <1>          jnz .put_other
   134 0000008A 6683C350            <1>          add bx, 80
   135 0000008E EB16                <1>          jmp .roll_screen
   136                              <1> 
   137                              <1>   .put_other:                              	;正常显示字符
   138 00000090 66D1E3              <1>          shl bx, 1
   139 00000093 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   139 0000009C FF                  <1>
   140 0000009D 880C18              <1>          mov [rax + rbx], cl
   141                              <1> 
   142                              <1>          ;以下将光标位置推进一个字符
   143 000000A0 66D1EB              <1>          shr bx, 1
   144 000000A3 66FFC3              <1>          inc bx
   145                              <1> 
   146                              <1>   .roll_screen:
   147 000000A6 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   148 000000AB 7C44                <1>          jl .set_cursor
   149                              <1> 
   150 000000AD 6653                <1>          push bx
   151                              <1> 
   152 000000AF FC                  <1>          cld
   153 000000B0 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   153 000000B9 FF                  <1>
   154 000000BA 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   154 000000C3 FF                  <1>
   155 000000C4 B9E0010000          <1>          mov rcx, 480
   156 000000C9 F348A5              <1>          rep movsq
   157 000000CC 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   158 000000D0 B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   159                              <1>   .cls:
   160 000000D5 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   160 000000DE FF                  <1>
   161 000000DF 66C704182007        <1>          mov word[rax + rbx], 0x0720
   162 000000E5 6683C302            <1>          add bx, 2
   163 000000E9 E2EA                <1>          loop .cls
   164                              <1> 
   165 000000EB 665B                <1>          pop bx
   166 000000ED 6683EB50            <1>          sub bx, 80
   167                              <1> 
   168                              <1>   .set_cursor:
   169 000000F1 66BAD403            <1>          mov dx, 0x3d4
   170 000000F5 B00E                <1>          mov al, 0x0e
   171 000000F7 EE                  <1>          out dx, al
   172 000000F8 66FFC2              <1>          inc dx                         	;0x3d5
   173 000000FB 88F8                <1>          mov al, bh
   174 000000FD EE                  <1>          out dx, al
   175 000000FE 66FFCA              <1>          dec dx       	;0x3d4
   176 00000101 B00F                <1>          mov al, 0x0f
   177 00000103 EE                  <1>          out dx, al
   178 00000104 66FFC2              <1>          inc dx       	;0x3d5
   179 00000107 88D8                <1>          mov al, bl
   180 00000109 EE                  <1>          out dx, al
   181                              <1> 
   182 0000010A 5F                  <1>          pop rdi
   183 0000010B 5E                  <1>          pop rsi
   184 0000010C 5A                  <1>          pop rdx
   185 0000010D 59                  <1>          pop rcx
   186 0000010E 5B                  <1>          pop rbx
   187 0000010F 58                  <1>          pop rax
   188                              <1> 
   189 00000110 C3                  <1>          ret
   190                              <1> 
   191                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   192                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   193                              <1> ;不同，互不干扰，不需要加锁和互斥。
   194                              <1> %ifdef __MP__
   195 00000111 0000000000000000    <1> _prnxy_locker dq 0
   196                              <1> %endif
   197                              <1> 
   198                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   199                              <1>                                           	;DH=行，DL=列
   200                              <1>                                           	;R9B=颜色属性
   201 00000119 50                  <1>          push rax
   202 0000011A 53                  <1>          push rbx
   203 0000011B 51                  <1>          push rcx
   204 0000011C 52                  <1>          push rdx
   205 0000011D 4150                <1>          push r8
   206                              <1> 
   207                              <1>          ;指定坐标位置在显存内的偏移量
   208 0000011F 88F0                <1>          mov al, dh
   209 00000121 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   210 00000123 F6E5                <1>          mul ch
   211 00000125 D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   212 00000127 6681E2FF00          <1>          and dx, 0x00ff
   213 0000012C 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   214 0000012F 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   215                              <1> 
   216 00000135 9C                  <1>          pushfq                        	;-->A
   217 00000136 FA                  <1>          cli
   218                              <1> %ifdef __MP__
   219                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    64                              <2>  %%spin_lock:
    65 00000137 48833DD2FFFFFF00    <2>  cmp %2, 0
    66 0000013F 7404                <2>  je %%get_lock
    67 00000141 F390                <2>  pause
    68 00000143 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000145 41B801000000        <2>  mov %1, 1
    71 0000014B 4C8705BFFFFFFF      <2>  xchg %1, %2
    72 00000152 4983F800            <2>  cmp %1, 0
    73 00000156 75DF                <2>  jne %%spin_lock
   220                              <1> %endif
   221                              <1> 
   222 00000158 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   222 00000161 FF                  <1>
   223                              <1>   .nextc:
   224 00000162 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   225 00000164 08D2                <1>          or dl, dl
   226 00000166 7412                <1>          jz .exit
   227 00000168 41881400            <1>          mov byte [r8 + rax], dl
   228 0000016C 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   229 00000171 48FFC3              <1>          inc rbx
   230 00000174 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   231 00000178 EBE8                <1>          jmp .nextc
   232                              <1>   .exit:
   233 0000017A 4D31C0              <1>          xor r8, r8
   234                              <1> %ifdef __MP__
   235 0000017D 48C70589FFFFFF0000- <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   235 00000186 0000                <1>
   236                              <1> %endif
   237 00000188 9D                  <1>          popfq                              	;A
   238                              <1> 
   239 00000189 4158                <1>          pop r8
   240 0000018B 5A                  <1>          pop rdx
   241 0000018C 59                  <1>          pop rcx
   242 0000018D 5B                  <1>          pop rbx
   243 0000018E 58                  <1>          pop rax
   244                              <1> 
   245 0000018F C3                  <1>          ret
   246                              <1> 
   247                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   248                              <1> make_call_gate:                          	;创建64位的调用门
   249                              <1>                                           	;输入：RAX=例程的线性地址
   250                              <1>                                           	;输出：RDI:RSI=调用门
   251 00000190 4889C7              <1>          mov rdi, rax
   252 00000193 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   253                              <1> 
   254 00000197 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   255 00000198 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   256 0000019F 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   257 000001A3 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   258 000001AA 5E                  <1>          pop rsi
   259                              <1> 
   260 000001AB C3                  <1>          ret
   261                              <1> 
   262                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   263                              <1> make_interrupt_gate:                      	;创建64位的中断门
   264                              <1>                                             	;输入：RAX=例程的线性地址
   265                              <1>                                             	;输出：RDI:RSI=中断门
   266 000001AC 4889C7              <1>          mov rdi, rax
   267 000001AF 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   268                              <1> 
   269 000001B3 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   270 000001B4 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   271 000001BB 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   272 000001BF 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   273 000001C6 5E                  <1>          pop rsi
   274                              <1> 
   275 000001C7 C3                  <1>          ret
   276                              <1> 
   277                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   278                              <1> make_trap_gate:                             	;创建64位的陷阱门
   279                              <1>                                              	;输入：RAX=例程的线性地址
   280                              <1>                                              	;输出：RDI:RSI=陷阱门
   281 000001C8 4889C7              <1>          mov rdi, rax
   282 000001CB 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   283                              <1> 
   284 000001CF 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   285 000001D0 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   286 000001D7 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   287 000001DB 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   288 000001E2 5E                  <1>          pop rsi
   289                              <1> 
   290 000001E3 C3                  <1>          ret
   291                              <1> 
   292                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   293                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   294                              <1>                                           	;输入：RAX=TSS的线性地址
   295                              <1>                                           	;输出：RDI:RSI=TSS描述符
   296 000001E4 50                  <1>          push rax
   297                              <1> 
   298 000001E5 4889C7              <1>          mov rdi, rax
   299 000001E8 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   300                              <1> 
   301 000001EC 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   302 000001ED 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   303 000001F2 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   304 000001F8 8A442405            <1>          mov al, [rsp + 5]
   305 000001FC 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   306 00000200 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   307 00000205 C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   308 0000020A 5E                  <1>          pop rsi                       	;门的低64位
   309                              <1> 
   310 0000020B 58                  <1>          pop rax
   311                              <1> 
   312 0000020C C3                  <1>          ret
   313                              <1> 
   314                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   315                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   316                              <1>                                        	;R8=中断向量
   317                              <1>                                        	;RDI:RSI=门描述符
   318 0000020D 4150                <1>          push r8
   319 0000020F 4151                <1>          push r9
   320                              <1> 
   321 00000211 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   322 00000215 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   322 0000021E FF                  <1>
   323 0000021F 4B893401            <1>          mov [r9 + r8], rsi
   324 00000223 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   325                              <1> 
   326 00000228 4159                <1>          pop r9
   327 0000022A 4158                <1>          pop r8
   328                              <1> 
   329 0000022C C3                  <1>          ret
   330                              <1> 
   331                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   332                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   333 0000022D 50                  <1>          push rax
   334                              <1> 
   335 0000022E B011                <1>          mov al, 0x11
   336 00000230 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   337 00000232 B020                <1>          mov al, 0x20
   338 00000234 E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   339 00000236 B004                <1>          mov al, 0x04
   340 00000238 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   341 0000023A B001                <1>          mov al, 0x01
   342 0000023C E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   343                              <1> 
   344 0000023E B011                <1>          mov al, 0x11
   345 00000240 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   346 00000242 B028                <1>          mov al, 0x28
   347 00000244 E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   348 00000246 B002                <1>          mov al, 0x02
   349 00000248 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   350 0000024A B001                <1>          mov al, 0x01
   351 0000024C E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   352                              <1> 
   353 0000024E 58                  <1>          pop rax
   354 0000024F C3                  <1>          ret
   355                              <1> 
   356                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   357                              <1> %ifdef __MP__
   358 00000250 0000000000000000    <1> _read_hdd_locker dq 0                 	;读硬盘锁
   359                              <1> %endif
   360                              <1> 
   361                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   362                              <1>                                         	;RAX=逻辑扇区号
   363                              <1>                                         	;RBX=目标缓冲区线性地址
   364                              <1>                                         	;返回：RBX=RBX+512
   365 00000258 50                  <1>          push rax
   366 00000259 51                  <1>          push rcx
   367 0000025A 52                  <1>          push rdx
   368                              <1> 
   369 0000025B 9C                  <1>          pushfq                     	;-->A
   370 0000025C FA                  <1>          cli
   371                              <1> %ifdef __MP__
   372                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    64                              <2>  %%spin_lock:
    65 0000025D 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 00000265 7404                <2>  je %%get_lock
    67 00000267 F390                <2>  pause
    68 00000269 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000026B BA01000000          <2>  mov %1, 1
    71 00000270 488715D9FFFFFF      <2>  xchg %1, %2
    72 00000277 4883FA00            <2>  cmp %1, 0
    73 0000027B 75E0                <2>  jne %%spin_lock
   373                              <1> %endif
   374                              <1> 
   375 0000027D 50                  <1>          push rax
   376                              <1> 
   377 0000027E 66BAF201            <1>          mov dx, 0x1f2
   378 00000282 B001                <1>          mov al, 1
   379 00000284 EE                  <1>          out dx, al                	;读取的扇区数
   380                              <1> 
   381 00000285 66FFC2              <1>          inc dx                    	;0x1f3
   382 00000288 58                  <1>          pop rax
   383 00000289 EE                  <1>          out dx, al               	;LBA地址7~0
   384                              <1> 
   385 0000028A 66FFC2              <1>          inc dx                   	;0x1f4
   386 0000028D B108                <1>          mov cl, 8
   387 0000028F 48D3E8              <1>          shr rax, cl
   388 00000292 EE                  <1>          out dx, al   	;LBA地址15~8
   389                              <1> 
   390 00000293 66FFC2              <1>          inc dx       	;0x1f5
   391 00000296 48D3E8              <1>          shr rax, cl
   392 00000299 EE                  <1>          out dx, al  	;LBA地址23~16
   393                              <1> 
   394 0000029A 66FFC2              <1>          inc dx       	;0x1f6
   395 0000029D 48D3E8              <1>          shr rax, cl
   396 000002A0 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   397 000002A2 EE                  <1>          out dx, al
   398                              <1> 
   399 000002A3 66FFC2              <1>          inc dx       	;0x1f7
   400 000002A6 B020                <1>          mov al, 0x20 	;读命令
   401 000002A8 EE                  <1>          out dx, al
   402                              <1> 
   403                              <1>   .waits:
   404 000002A9 EC                  <1>          in al, dx
   405                              <1>          ;and al, 0x88
   406                              <1>          ;cmp al, 0x08
   407 000002AA A808                <1>          test al, 8
   408 000002AC 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   409                              <1> 
   410 000002AE B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   411 000002B3 66BAF001            <1>          mov dx, 0x1f0
   412                              <1>   .readw:
   413 000002B7 66ED                <1>          in ax, dx
   414 000002B9 668903              <1>          mov [rbx], ax
   415 000002BC 4883C302            <1>          add rbx, 2
   416 000002C0 E2F5                <1>          loop .readw
   417                              <1> 
   418                              <1> %ifdef __MP__
   419 000002C2 48C70583FFFFFF0000- <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   419 000002CB 0000                <1>
   420                              <1> %endif
   421 000002CD 9D                  <1>          popfq                              			;A
   422                              <1> 
   423 000002CE 5A                  <1>          pop rdx
   424 000002CF 59                  <1>          pop rcx
   425 000002D0 58                  <1>          pop rax
   426                              <1> 
   427 000002D1 C3                  <1>          ret
   428                              <1> 
   429                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   430 000002D2 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   431 00000312 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   432                              <1>   _page_map_len  equ $ - _page_bit_map
   433                              <1> 
   434                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   435                              <1>                                             			;输入：无
   436                              <1>                                             			;输出：RAX=页的物理地址
   437 000006D2 4831C0              <1>          xor rax, rax
   438                              <1>   .b1:
   439 000006D5 F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   440 000006DE 730B                <1>          jnc .b2
   441 000006E0 48FFC0              <1>          inc rax
   442 000006E3 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   443 000006E9 7CEA                <1>          jl .b1
   444                              <1> 
   445                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   446                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   447                              <1>          ;面的换入和换出。
   448                              <1> 
   449                              <1>   .b2:
   450 000006EB 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   451                              <1> 
   452 000006EF C3                  <1>          ret
   453                              <1> 
   454                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   455                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   456                              <1>                                      	;输入：R13=线性地址
   457                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   458 000006F0 4155                <1>          push r13
   459                              <1> 
   460 000006F2 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   460 000006FB 00                  <1>
   461 000006FC 4D21F5              <1>          and r13, r14
   462 000006FF 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   463                              <1> 
   464 00000703 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   465 0000070A 4D01EE              <1>          add r14, r13
   466                              <1> 
   467 0000070D 415D                <1>          pop r13
   468                              <1> 
   469 0000070F C3                  <1>          ret
   470                              <1> 
   471                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   472                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   473                              <1>                                     	;输入：R13=线性地址
   474                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   475 00000710 4155                <1>          push r13
   476                              <1> 
   477 00000712 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   477 0000071B 00                  <1>
   478 0000071C 4D21F5              <1>          and r13, r14
   479 0000071F 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   480                              <1> 
   481 00000723 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   482 0000072A 4D01EE              <1>          add r14, r13
   483                              <1> 
   484 0000072D 415D                <1>          pop r13
   485                              <1> 
   486 0000072F C3                  <1>          ret
   487                              <1> 
   488                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   489                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   490                              <1>                                      	;输入：R13=线性地址
   491                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   492 00000730 4155                <1>          push r13
   493                              <1> 
   494 00000732 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   494 0000073B 00                  <1>
   495                              <1> 	                                ;索引部分
   496 0000073C 4D21F5              <1>          and r13, r14
   497 0000073F 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   498                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   499 00000743 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   500 0000074A 4D01EE              <1>          add r14, r13
   501 0000074D 415D                <1>          pop r13
   502                              <1> 
   503 0000074F C3                  <1>          ret
   504                              <1> 
   505                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   506                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   507                              <1>                                    	;输入：R13=线性地址
   508                              <1>                                    	;输出：R14=对应的页表项的线性地址
   509 00000750 4155                <1>          push r13
   510                              <1> 
   511 00000752 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   511 0000075B 00                  <1>
   512                              <1> 	                                ;索引部分
   513 0000075C 4D21F5              <1>          and r13, r14
   514 0000075F 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   515                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   516 00000763 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   516 0000076C FF                  <1>
   517 0000076D 4D01EE              <1>          add r14, r13
   518                              <1> 
   519 00000770 415D                <1>          pop r13
   520 00000772 C3                  <1>          ret
   521                              <1> 
   522                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   523                              <1> %ifdef __MP__
   524 00000773 0000000000000000    <1> _spaging_locker dq 0
   525                              <1> %endif
   526                              <1> 
   527                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   528                              <1>                                    	;输入：R13=线性地址
   529 0000077B 51                  <1>          push rcx
   530 0000077C 50                  <1>          push rax
   531 0000077D 4156                <1>          push r14
   532                              <1> 
   533 0000077F 9C                  <1>          pushfq                   	;-->A
   534 00000780 FA                  <1>          cli
   535                              <1> %ifdef __MP__
   536                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    64                              <2>  %%spin_lock:
    65 00000781 48833DEAFFFFFF00    <2>  cmp %2, 0
    66 00000789 7404                <2>  je %%get_lock
    67 0000078B F390                <2>  pause
    68 0000078D EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000078F 41BE01000000        <2>  mov %1, 1
    71 00000795 4C8735D7FFFFFF      <2>  xchg %1, %2
    72 0000079C 4983FE00            <2>  cmp %1, 0
    73 000007A0 75DF                <2>  jne %%spin_lock
   537                              <1> %endif
   538                              <1> 
   539                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   540                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   541 000007A2 E849FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   542 000007A7 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   543 000007AE 752B                <1>          jnz .b0
   544                              <1> 
   545                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   546 000007B0 E81DFFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   547 000007B5 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   548 000007B9 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   549                              <1> 
   550                              <1>          ;清空刚分配的页目录指针表
   551 000007BC E84FFFFFFF          <1>          call lin_to_lin_of_pdpte
   552 000007C1 49C1EE0C            <1>          shr r14, 12
   553 000007C5 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   554 000007C9 B900020000          <1>          mov rcx, 512
   555                              <1>   .cls0:
   556 000007CE 49C70600000000      <1>          mov qword [r14], 0
   557 000007D5 4983C608            <1>          add r14, 8
   558 000007D9 E2F3                <1>          loop .cls0
   559                              <1> ;-------------------------------------------------
   560                              <1>   .b0:
   561                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   562 000007DB E830FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   563 000007E0 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   564 000007E7 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   565                              <1> 
   566                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   567 000007E9 E8E4FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   568 000007EE 4883C807            <1>          or rax, 0x07                  	;添加属性位
   569 000007F2 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   570                              <1> 
   571                              <1>          ;清空刚分配的页目录表
   572 000007F5 E836FFFFFF          <1>          call lin_to_lin_of_pdte
   573 000007FA 49C1EE0C            <1>          shr r14, 12
   574 000007FE 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   575 00000802 B900020000          <1>          mov rcx, 512
   576                              <1>   .cls1:
   577 00000807 49C70600000000      <1>          mov qword [r14], 0
   578 0000080E 4983C608            <1>          add r14, 8
   579 00000812 E2F3                <1>          loop .cls1
   580                              <1> ;-------------------------------------------------
   581                              <1>   .b1:
   582                              <1>          ;检查该线性地址所对应的页目录项是否存在
   583 00000814 E817FFFFFF          <1>          call lin_to_lin_of_pdte
   584 00000819 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   585 00000820 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   586                              <1> 
   587                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   588 00000822 E8ABFEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   589 00000827 4883C807            <1>          or rax, 0x07                      	;添加属性位
   590 0000082B 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   591                              <1> 
   592                              <1>          ;清空刚分配的页表
   593 0000082E E81DFFFFFF          <1>          call lin_to_lin_of_pte
   594 00000833 49C1EE0C            <1>          shr r14, 12
   595 00000837 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   596 0000083B B900020000          <1>          mov rcx, 512
   597                              <1>   .cls2:
   598 00000840 49C70600000000      <1>          mov qword [r14], 0
   599 00000847 4983C608            <1>          add r14, 8
   600 0000084B E2F3                <1>          loop .cls2
   601                              <1> ;-------------------------------------------------
   602                              <1>   .b2:
   603                              <1>          ;检查该线性地址所对应的页表项是否存在
   604 0000084D E8FEFEFFFF          <1>          call lin_to_lin_of_pte
   605 00000852 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   606 00000859 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   607                              <1> 
   608                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   609 0000085B E872FEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   610 00000860 4883C807            <1>          or rax, 0x07                     	;添加属性位
   611 00000864 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   612                              <1> 
   613                              <1>   .b3:
   614                              <1> %ifdef __MP__
   615 00000867 48C70501FFFFFF0000- <1>          mov qword [rel _spaging_locker], 0
   615 00000870 0000                <1>
   616                              <1> %endif
   617 00000872 9D                  <1>          popfq                      	;A
   618                              <1> 
   619 00000873 415E                <1>          pop r14
   620 00000875 58                  <1>          pop rax
   621 00000876 59                  <1>          pop rcx
   622                              <1> 
   623 00000877 C3                  <1>          ret
   624                              <1> 
   625                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   626                              <1> %ifdef __MP__
   627 00000878 0000000000000000    <1> _mapping_locker dq 0
   628                              <1> %endif
   629                              <1> 
   630                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   631                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   632                              <1>                                    	;输入：R13=线性地址
   633                              <1>                                                    ;RAX=页的物理地址（含属性）
   634 00000880 51                  <1>          push rcx
   635 00000881 4156                <1>          push r14
   636                              <1> 
   637 00000883 9C                  <1>          pushfq
   638 00000884 FA                  <1>          cli
   639                              <1> %ifdef __MP__
   640                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    64                              <2>  %%spin_lock:
    65 00000885 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 0000088D 7404                <2>  je %%get_lock
    67 0000088F F390                <2>  pause
    68 00000891 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000893 41BE01000000        <2>  mov %1, 1
    71 00000899 4C8735D8FFFFFF      <2>  xchg %1, %2
    72 000008A0 4983FE00            <2>  cmp %1, 0
    73 000008A4 75DF                <2>  jne %%spin_lock
   641                              <1> %endif
   642                              <1> 
   643 000008A6 50                  <1>          push rax
   644                              <1> 
   645                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   646                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   647 000008A7 E844FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   648 000008AC 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   649 000008B3 752B                <1>          jnz .b0
   650                              <1> 
   651                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   652 000008B5 E818FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   653 000008BA 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   654 000008BE 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   655                              <1> 
   656                              <1>          ;清空刚分配的页目录指针表
   657 000008C1 E84AFEFFFF          <1>          call lin_to_lin_of_pdpte
   658 000008C6 49C1EE0C            <1>          shr r14, 12
   659 000008CA 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   660 000008CE B900020000          <1>          mov rcx, 512
   661                              <1>   .cls0:
   662 000008D3 49C70600000000      <1>          mov qword [r14], 0
   663 000008DA 4983C608            <1>          add r14, 8
   664 000008DE E2F3                <1>          loop .cls0
   665                              <1> ;-------------------------------------------------
   666                              <1>   .b0:
   667                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   668 000008E0 E82BFEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   669 000008E5 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   670 000008EC 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   671                              <1> 
   672                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   673 000008EE E8DFFDFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   674 000008F3 4883C807            <1>          or rax, 0x07              	;添加属性位
   675 000008F7 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   676                              <1> 
   677                              <1>          ;清空刚分配的页目录表
   678 000008FA E831FEFFFF          <1>          call lin_to_lin_of_pdte
   679 000008FF 49C1EE0C            <1>          shr r14, 12
   680 00000903 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   681 00000907 B900020000          <1>          mov rcx, 512
   682                              <1>   .cls1:
   683 0000090C 49C70600000000      <1>          mov qword [r14], 0
   684 00000913 4983C608            <1>          add r14, 8
   685 00000917 E2F3                <1>          loop .cls1
   686                              <1> ;-------------------------------------------------
   687                              <1>   .b1:
   688                              <1>          ;检查该线性地址所对应的页目录项是否存在
   689 00000919 E812FEFFFF          <1>          call lin_to_lin_of_pdte
   690 0000091E 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   691 00000925 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   692                              <1> 
   693                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   694 00000927 E8A6FDFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   695 0000092C 4883C807            <1>          or rax, 0x07                  	;添加属性位
   696 00000930 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   697                              <1> 
   698                              <1>          ;清空刚分配的页表
   699 00000933 E818FEFFFF          <1>          call lin_to_lin_of_pte
   700 00000938 49C1EE0C            <1>          shr r14, 12
   701 0000093C 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   702 00000940 B900020000          <1>          mov rcx, 512
   703                              <1>   .cls2:
   704 00000945 49C70600000000      <1>          mov qword [r14], 0
   705 0000094C 4983C608            <1>          add r14, 8
   706 00000950 E2F3                <1>          loop .cls2
   707                              <1> ;-------------------------------------------------
   708                              <1>   .b2:
   709 00000952 E8F9FDFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   710 00000957 58                  <1>          pop rax
   711 00000958 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   712                              <1> 
   713                              <1> %ifdef __MP__
   714 0000095B 48C70512FFFFFF0000- <1>          mov qword [rel _mapping_locker], 0
   714 00000964 0000                <1>
   715                              <1> %endif
   716 00000966 9D                  <1>          popfq
   717                              <1> 
   718 00000967 415E                <1>          pop r14
   719 00000969 59                  <1>          pop rcx
   720                              <1> 
   721 0000096A C3                  <1>          ret
   722                              <1> 
   723                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   724 0000096B 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   725                              <1> 
   726                              <1> %ifdef __MP__
   727 00000973 0000000000000000    <1>   _core_alloc_locker dq 0
   728                              <1> %endif
   729                              <1> 
   730                              <1> core_memory_allocate:                 	        ;在虚拟地址空间的高端（内核）分配内存
   731                              <1>                                         	;输入：RCX=请求分配的字节数
   732                              <1>                                         	;输出：R13=本次分配的起始线性地址
   733                              <1>                                         	;      R14=下次分配的起始线性地址
   734 0000097B 9C                  <1>          pushfq                        	        ;A-->
   735 0000097C FA                  <1>          cli
   736                              <1> %ifdef __MP__
   737                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    64                              <2>  %%spin_lock:
    65 0000097D 48833DEEFFFFFF00    <2>  cmp %2, 0
    66 00000985 7404                <2>  je %%get_lock
    67 00000987 F390                <2>  pause
    68 00000989 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000098B 41BE01000000        <2>  mov %1, 1
    71 00000991 4C8735DBFFFFFF      <2>  xchg %1, %2
    72 00000998 4983FE00            <2>  cmp %1, 0
    73 0000099C 75DF                <2>  jne %%spin_lock
   738                              <1> %endif
   739                              <1> 
   740 0000099E 4C8B2DC6FFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   741 000009A5 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   742                              <1> 
   743 000009AA 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   744 000009B1 740C                <1>          jz .algn
   745 000009B3 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   746 000009B7 49C1EE03            <1>          shr r14, 3
   747 000009BB 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   748                              <1> 
   749                              <1>   .algn:
   750 000009BF 4C8935A5FFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   751                              <1> 
   752                              <1> %ifdef __MP__
   753 000009C6 48C705A2FFFFFF0000- <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   753 000009CF 0000                <1>
   754                              <1> %endif
   755 000009D1 9D                  <1>          popfq                             	;A
   756                              <1> 
   757 000009D2 4155                <1>          push r13
   758 000009D4 4156                <1>          push r14
   759                              <1> 
   760                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   761 000009D6 49C1ED0C            <1>          shr r13, 12
   762 000009DA 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   763 000009DE 49C1EE0C            <1>          shr r14, 12
   764 000009E2 49C1E60C            <1>          shl r14, 12                    	;too
   765                              <1>   .next:
   766 000009E6 E890FDFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   767 000009EB 4981C500100000      <1>          add r13, 0x1000               	;+4096
   768 000009F2 4D39F5              <1>          cmp r13, r14
   769 000009F5 7EEF                <1>          jle .next
   770                              <1> 
   771 000009F7 415E                <1>          pop r14
   772 000009F9 415D                <1>          pop r13
   773                              <1> 
   774 000009FB C3                  <1>          ret
   775                              <1> 
   776                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   777                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   778                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   779                              <1>                                    	;      RCX=希望分配的字节数
   780                              <1>                                    	;输出：R13=本次分配的起始线性地址
   781                              <1>                                    	;      R14=下次分配的起始线性地址
   782                              <1>          ;获得本次内存分配的起始线性地址
   783 000009FC 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   784 00000A00 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   785                              <1> 
   786 00000A05 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   787 00000A0C 740C                <1>          jz .algn
   788 00000A0E 49C1EE03            <1>          shr r14, 3
   789 00000A12 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   790 00000A16 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   791                              <1> 
   792                              <1>   .algn:
   793 00000A1A 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   794                              <1> 
   795 00000A1E 4155                <1>          push r13
   796 00000A20 4156                <1>          push r14
   797                              <1> 
   798                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   799 00000A22 49C1ED0C            <1>          shr r13, 12
   800 00000A26 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   801 00000A2A 49C1EE0C            <1>          shr r14, 12
   802 00000A2E 49C1E60C            <1>          shl r14, 12                 	;too
   803                              <1>   .next:
   804 00000A32 E844FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   805 00000A37 4981C500100000      <1>          add r13, 0x1000                ;+4096
   806 00000A3E 4D39F5              <1>          cmp r13, r14
   807 00000A41 7EEF                <1>          jle .next
   808                              <1> 
   809 00000A43 415E                <1>          pop r14
   810 00000A45 415D                <1>          pop r13
   811                              <1> 
   812 00000A47 C3                  <1>          ret
   813                              <1> 
   814                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   815                              <1> %ifdef __MP__
   816 00000A48 0000000000000000    <1> _copy_locker dq 0
   817                              <1> %endif
   818                              <1> 
   819                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   820                              <1>                                         	;输入：无
   821                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   822 00000A50 56                  <1>          push rsi
   823 00000A51 57                  <1>          push rdi
   824 00000A52 4155                <1>          push r13
   825 00000A54 51                  <1>          push rcx
   826                              <1> 
   827 00000A55 9C                  <1>          pushfq                                   	;-->A
   828 00000A56 FA                  <1>          cli
   829                              <1> %ifdef __MP__
   830                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    64                              <2>  %%spin_lock:
    65 00000A57 48833DE9FFFFFF00    <2>  cmp %2, 0
    66 00000A5F 7404                <2>  je %%get_lock
    67 00000A61 F390                <2>  pause
    68 00000A63 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000A65 B901000000          <2>  mov %1, 1
    71 00000A6A 48870DD7FFFFFF      <2>  xchg %1, %2
    72 00000A71 4883F900            <2>  cmp %1, 0
    73 00000A75 75E0                <2>  jne %%spin_lock
   831                              <1> %endif
   832                              <1> 
   833 00000A77 E856FCFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   834 00000A7C 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   835 00000A80 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   835 00000A89 FF                  <1>
   836 00000A8A E8F1FDFFFF          <1>          call mapping_laddr_to_page
   837                              <1> 
   838                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   839 00000A8F 410F017D00          <1>          invlpg [r13]
   840                              <1> 
   841 00000A94 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   842 00000A9B 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   843 00000A9E B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   844 00000AA3 FC                  <1>          cld
   845 00000AA4 F348A5              <1>          repe movsq
   846                              <1> 
   847 00000AA7 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   848 00000AAE 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   849                              <1> 
   850                              <1> %ifdef __MP__
   851 00000AB6 48C70587FFFFFF0000- <1>          mov qword [rel _copy_locker], 0
   851 00000ABF 0000                <1>
   852                              <1> %endif
   853 00000AC1 9D                  <1>          popfq                    	;A
   854                              <1> 
   855 00000AC2 59                  <1>          pop rcx
   856 00000AC3 415D                <1>          pop r13
   857 00000AC5 5F                  <1>          pop rdi
   858 00000AC6 5E                  <1>          pop rsi
   859                              <1> 
   860 00000AC7 C3                  <1>          ret
   861                              <1> 
   862                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   863                              <1> %ifdef __MP__
   864 00000AC8 0000000000000000    <1> _cmos_locker dq 0
   865                              <1> %endif
   866                              <1> 
   867                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   868                              <1>                                        	;输入：RBX=缓冲区线性地址
   869 00000AD0 50                  <1>          push rax
   870                              <1> 
   871 00000AD1 9C                  <1>          pushfq                       	;-->A
   872 00000AD2 FA                  <1>          cli
   873                              <1> %ifdef __MP__
   874                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
    64                              <2>  %%spin_lock:
    65 00000AD3 48833DEDFFFFFF00    <2>  cmp %2, 0
    66 00000ADB 7404                <2>  je %%get_lock
    67 00000ADD F390                <2>  pause
    68 00000ADF EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000AE1 B801000000          <2>  mov %1, 1
    71 00000AE6 488705DBFFFFFF      <2>  xchg %1, %2
    72 00000AED 4883F800            <2>  cmp %1, 0
    73 00000AF1 75E0                <2>  jne %%spin_lock
   875                              <1> %endif
   876                              <1> 
   877                              <1>   .w0:
   878 00000AF3 B08A                <1>          mov al, 0x8a
   879 00000AF5 E670                <1>          out 0x70, al
   880 00000AF7 E471                <1>          in al, 0x71                 	;读寄存器A
   881 00000AF9 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   882 00000AFB 75F6                <1>          jnz .w0
   883                              <1> 
   884 00000AFD B084                <1>          mov al, 0x84
   885 00000AFF E670                <1>          out 0x70, al
   886 00000B01 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   887 00000B03 88C4                <1>          mov ah, al
   888                              <1> 
   889 00000B05 C0EC04              <1>          shr ah, 4
   890 00000B08 80E40F              <1>          and ah, 0x0f
   891 00000B0B 80C430              <1>          add ah, 0x30
   892 00000B0E 8823                <1>          mov [rbx], ah
   893                              <1> 
   894 00000B10 240F                <1>          and al, 0x0f
   895 00000B12 0430                <1>          add al, 0x30
   896 00000B14 884301              <1>          mov [rbx + 1], al
   897                              <1> 
   898 00000B17 C643023A            <1>          mov byte [rbx + 2], ':'
   899                              <1> 
   900 00000B1B B082                <1>          mov al, 0x82
   901 00000B1D E670                <1>          out 0x70, al
   902 00000B1F E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   903 00000B21 88C4                <1>          mov ah, al
   904                              <1> 
   905 00000B23 C0EC04              <1>          shr ah, 4
   906 00000B26 80E40F              <1>          and ah, 0x0f
   907 00000B29 80C430              <1>          add ah, 0x30
   908 00000B2C 886303              <1>          mov [rbx + 3], ah
   909                              <1> 
   910 00000B2F 240F                <1>          and al, 0x0f
   911 00000B31 0430                <1>          add al, 0x30
   912 00000B33 884304              <1>          mov [rbx + 4], al
   913                              <1> 
   914 00000B36 C643053A            <1>          mov byte [rbx + 5], ':'
   915                              <1> 
   916 00000B3A B080                <1>          mov al, 0x80
   917 00000B3C E670                <1>          out 0x70, al
   918 00000B3E E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   919 00000B40 88C4                <1>          mov ah, al              	;分拆成两个数字
   920                              <1> 
   921 00000B42 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   922 00000B45 80E40F              <1>          and ah, 0x0f
   923 00000B48 80C430              <1>          add ah, 0x30
   924 00000B4B 886306              <1>          mov [rbx + 6], ah
   925                              <1> 
   926 00000B4E 240F                <1>          and al, 0x0f               	;仅保留低4位
   927 00000B50 0430                <1>          add al, 0x30               	;转换成ASCII
   928 00000B52 884307              <1>          mov [rbx + 7], al
   929                              <1> 
   930 00000B55 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   931                              <1> 
   932                              <1> %ifdef __MP__
   933 00000B59 48C70564FFFFFF0000- <1>          mov qword [rel _cmos_locker], 0
   933 00000B62 0000                <1>
   934                              <1> %endif
   935 00000B64 9D                  <1>          popfq                	;A
   936                              <1> 
   937 00000B65 58                  <1>          pop rax
   938                              <1> 
   939 00000B66 C3                  <1>          ret
   940                              <1> 
   941                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   942 00000B67 0000000000000000    <1>   _process_id        dq 0
   943                              <1> 
   944                              <1> generate_process_id:                  	;生成唯一的进程标识
   945                              <1>                                         	;返回：RAX=进程标识
   946 00000B6F B801000000          <1>          mov rax, 1
   947 00000B74 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   948                              <1> 
   949 00000B7D C3                  <1>          ret
   950                              <1> 
   951                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   952 00000B7E 0000000000000000    <1>   _thread_id dq 0
   953                              <1> 
   954                              <1> generate_thread_id:                 	;生成唯一的线程标识
   955                              <1>                                       	;返回：RAX=线程标识
   956 00000B86 B801000000          <1>          mov rax, 1
   957 00000B8B F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   958                              <1> 
   959 00000B94 C3                  <1>          ret
   960                              <1> 
   961                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   962 00000B95 08                  <1>   _screen_row        db 8
   963                              <1> 
   964                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   965                              <1>                                      	;返回：DH=行号
   966 00000B96 B601                <1>          mov dh, 1
   967 00000B98 F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   968                              <1> 
   969 00000BA0 C3                  <1>          ret
   970                              <1> 
   971                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   972                              <1> get_cpu_number:                        	;返回当前处理器的编号
   973                              <1>                                         	;返回：RAX=处理器编号
   974 00000BA1 9C                  <1>          pushfq
   975 00000BA2 FA                  <1>          cli
   976 00000BA3 0F01F8              <1>          swapgs
   977 00000BA6 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   978 00000BAF 0F01F8              <1>          swapgs
   979 00000BB2 9D                  <1>          popfq
   980 00000BB3 C3                  <1>          ret
   981                              <1> 
   982                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   983                              <1> memory_allocate:                       	;用户空间的内存分配
   984                              <1>                                          	;进入：RDX=期望分配的字节数
   985                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   986 00000BB4 51                  <1>          push rcx
   987 00000BB5 4153                <1>          push r11
   988 00000BB7 4156                <1>          push r14
   989                              <1> 
   990 00000BB9 9C                  <1>          pushfq
   991 00000BBA FA                  <1>          cli
   992 00000BBB 0F01F8              <1>          swapgs
   993 00000BBE 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
   994 00000BC7 0F01F8              <1>          swapgs
   995 00000BCA 9D                  <1>          popfq
   996                              <1> 
   997 00000BCB 4889D1              <1>          mov rcx, rdx
   998 00000BCE E829FEFFFF          <1>          call user_memory_allocate
   999                              <1> 
  1000 00000BD3 415E                <1>          pop r14
  1001 00000BD5 415B                <1>          pop r11
  1002 00000BD7 59                  <1>          pop rcx
  1003                              <1> 
  1004 00000BD8 C3                  <1>          ret
  1005                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    50                                  %include "..\common\user_static64.lib"
    51                              <1> ;user_static64.lib:用户程序使用的例程库，用来模拟高级语言的静态库。有些功能直接在本文件
    52                              <1> ;中实现，但有些功能需要通过syscall指令使用内核提供的系统调用。
    53                              <1> ;创建时间：2022-01-30 18:30，李忠
    54                              <1> ;此文件需要用预处理指令%include引入用户程序。
    55                              <1> 
    56                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    57                              <1>          bits 64
    58                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    59                              <1> bin64_to_dec:                                     ;将二进制数转换为十进制字符串。
    60                              <1>                                                   ;输入：R8=64位二进制数
    61                              <1>                                                   ;      RBX=目标缓冲区线性地址
    62 00000BD9 50                  <1>          push rax
    63 00000BDA 53                  <1>          push rbx
    64 00000BDB 51                  <1>          push rcx
    65 00000BDC 52                  <1>          push rdx
    66 00000BDD 4150                <1>          push r8
    67                              <1> 
    68 00000BDF 490FBAE03F          <1>          bt r8, 63
    69 00000BE4 7309                <1>          jnc .begin
    70 00000BE6 C6032D              <1>          mov byte [rbx], '-'
    71 00000BE9 49F7D8              <1>          neg r8
    72 00000BEC 48FFC3              <1>          inc rbx
    73                              <1>   .begin:
    74 00000BEF 4C89C0              <1>          mov rax, r8                              ;!!
    75 00000BF2 41B80A000000        <1>          mov r8, 10
    76 00000BF8 4831C9              <1>          xor rcx, rcx
    77                              <1> 
    78                              <1>   .next_div:
    79 00000BFB 4831D2              <1>          xor rdx, rdx
    80 00000BFE 49F7F0              <1>          div r8
    81 00000C01 52                  <1>          push rdx                                 ;保存分解的数位
    82 00000C02 48FFC1              <1>          inc rcx                                  ;递增压栈的次数
    83 00000C05 4809C0              <1>          or rax, rax                              ;商为0？
    84 00000C08 7402                <1>          jz .rotate
    85 00000C0A EBEF                <1>          jmp .next_div
    86                              <1> 
    87                              <1>   .rotate:
    88 00000C0C 5A                  <1>          pop rdx
    89 00000C0D 80C230              <1>          add dl, 0x30                             ;数位转换成ASCII编码
    90 00000C10 8813                <1>          mov [rbx], dl
    91 00000C12 48FFC3              <1>          inc rbx
    92 00000C15 E2F5                <1>          loop .rotate
    93                              <1> 
    94 00000C17 C60300              <1>          mov byte [rbx], 0
    95                              <1> 
    96 00000C1A 4158                <1>          pop r8
    97 00000C1C 5A                  <1>          pop rdx
    98 00000C1D 59                  <1>          pop rcx
    99 00000C1E 5B                  <1>          pop rbx
   100 00000C1F 58                  <1>          pop rax
   101                              <1> 
   102 00000C20 C3                  <1>          ret                                      ;段内返回
   103                              <1> 
   104                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   105                              <1> string_concatenates:                              ;将源字符串连接到目的字符串的尾部
   106                              <1>                                                   ;输入：RSI=源字符串的线性地址
   107                              <1>                                                   ;      RDI=目的字符串的线性地址
   108 00000C21 50                  <1>          push rax
   109 00000C22 56                  <1>          push rsi
   110 00000C23 57                  <1>          push rdi
   111                              <1> 
   112                              <1>   .r0:
   113 00000C24 803F00              <1>          cmp byte [rdi], 0
   114 00000C27 7405                <1>          jz .r1
   115 00000C29 48FFC7              <1>          inc rdi
   116 00000C2C EBF6                <1>          jmp .r0
   117                              <1> 
   118                              <1>   .r1:
   119 00000C2E 8A06                <1>          mov al, [rsi]
   120 00000C30 8807                <1>          mov [rdi], al
   121 00000C32 3C00                <1>          cmp al, 0
   122 00000C34 7408                <1>          jz .r2
   123 00000C36 48FFC6              <1>          inc rsi
   124 00000C39 48FFC7              <1>          inc rdi
   125 00000C3C EBF0                <1>          jmp .r1
   126                              <1> 
   127                              <1>   .r2:
   128 00000C3E 5F                  <1>          pop rdi
   129 00000C3F 5E                  <1>          pop rsi
   130 00000C40 58                  <1>          pop rax
   131                              <1> 
   132 00000C41 C3                  <1>          ret
   133                              <1> 
   134                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   135                              <1> 
    51                                           bits 64
    52                                  
    53                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    54 00000C42 F900                      _ap_string      db 249, 0
    55                                  
    56                                  ap_to_core_entry:                                 ;应用处理器（AP）进入内核的入口点
    57                                           ;启用GDT的高端线性地址并加载IDTR
    58 00000C44 48B8007E00000080FF-              mov rax, UPPER_SDA_LINEAR
    58 00000C4D FF                 
    59 00000C4E 0F015002                         lgdt [rax + 2]                           ;只有在64位模式下才能加载64位线性地址部分
    60 00000C52 0F01580C                         lidt [rax + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
    61                                  
    62                                           ;为当前处理器创建64位模式下的专属栈
    63 00000C56 B900100000                       mov rcx, 4096
    64 00000C5B E81BFDFFFF                       call core_memory_allocate
    65 00000C60 4C89F4                           mov rsp, r14
    66                                  
    67                                           ;创建当前处理器的专属存储区（含TSS），并安装TSS描述符到GDT
    68 00000C63 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
    69 00000C68 E80EFDFFFF                       call core_memory_allocate
    70 00000C6D 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
    71 00000C74 E86BF5FFFF                       call make_tss_descriptor
    72                                  
    73 00000C79 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区的高端线性地址（低端亦可）
    73 00000C82 FF                 
    74                                  
    75 00000C83 4D8B4704                         mov r8, [r15 + 4]                        ;R8=GDT的线性地址
    76 00000C87 490FB74F02                       movzx rcx, word [r15 + 2]                ;RCX=GDT的界限值
    77 00000C8C 4989740801                       mov [r8 + rcx + 1], rsi                  ;TSS描述符的低64位
    78 00000C91 49897C0809                       mov [r8 + rcx + 9], rdi                  ;TSS描述符的高64位
    79                                  
    80 00000C96 664183470210                     add word [r15 + 2], 16
    81 00000C9C 410F015702                       lgdt [r15 + 2]                           ;重新加载GDTR
    82                                  
    83 00000CA1 66C1E903                         shr cx, 3                                ;除以8（消除余数），得到索引号
    84 00000CA5 66FFC1                           inc cx                                   ;索引号递增
    85 00000CA8 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
    86                                  
    87 00000CAC 0F00D9                           ltr cx                                   ;为当前处理器加载任务寄存器TR
    88                                  
    89                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
    90 00000CAF B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
    91 00000CB4 4C89E8                           mov rax, r13                             ;只用EAX
    92 00000CB7 4C89EA                           mov rdx, r13
    93 00000CBA 48C1EA20                         shr rdx, 32                              ;只用EDX
    94 00000CBE 0F30                             wrmsr
    95                                  
    96                                           ;为快速系统调用SYSCALL和SYSRET准备参数
    97 00000CC0 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
    98 00000CC5 0F32                             rdmsr
    99 00000CC7 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   100 00000CCB 0F30                             wrmsr
   101                                  
   102 00000CCD B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   103 00000CD2 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   104 00000CD7 31C0                             xor eax, eax
   105 00000CD9 0F30                             wrmsr
   106                                  
   107 00000CDB B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   108 00000CE0 488B05(08000000)                 mov rax, [rel position]
   109 00000CE7 488D80[F1130000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   110 00000CEE 4889C2                           mov rdx, rax
   111 00000CF1 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   112 00000CF5 0F30                             wrmsr
   113                                  
   114 00000CF7 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   115 00000CFC 31D2                             xor edx, edx
   116 00000CFE B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   117 00000D03 0F30                             wrmsr
   118                                  
   119 00000D05 4C8B3D(08000000)                 mov r15, [rel position]
   120 00000D0C 498D9F[420C0000]                 lea rbx, [r15 + _ap_string]
   121 00000D13 E8F0F2FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   122                                  
   123 00000D18 0F01F8                           swapgs                                   ;准备用GS操作当前处理器的专属数据
   124 00000D1B 6548C7042508000000-              mov qword [gs:8], 0                      ;没有正在执行的任务
   124 00000D24 00000000           
   125 00000D28 4831C0                           xor rax, rax
   126 00000D2B 8A05(31010000)                   mov al, byte [rel ack_cpus]
   127 00000D31 654889042510000000               mov [gs:16], rax                         ;设置当前处理器的编号
   128 00000D3A 654889242518000000               mov [gs:24], rsp                         ;保存当前处理器的固有栈指针
   129 00000D43 0F01F8                           swapgs
   130                                  
   131 00000D46 FE05(31010000)                   inc byte [rel ack_cpus]                  ;递增应答计数值
   132                                  
   133 00000D4C C60425[82F00000]00               mov byte [AP_START_UP_ADDR + lock_var], 0;释放自旋锁
   134                                  
   135 00000D54 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   135 00000D5D FF                 
   136 00000D5E 0FBAAEF000000008                 bts dword [rsi + 0xf0], 8                ;设置SVR寄存器，允许LAPIC
   137                                  
   138 00000D66 FB                               sti                                      ;开放中断
   139                                  
   140                                    .do_idle:
   141 00000D67 F4                               hlt
   142 00000D68 EBFD                             jmp .do_idle
   143                                  
   144                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   145                                  general_interrupt_handler:                        ;通用中断处理过程
   146 00000D6A 48CF                             iretq
   147                                  
   148                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   149                                  general_exception_handler:                        ;通用异常处理过程
   150                                                                                    ;在24行0列显示红底白字的错误信息
   151 00000D6C 4C8B3D(08000000)                 mov r15, [rel position]
   152 00000D73 498D9F[880D0000]                 lea rbx, [r15 + exceptm]
   153 00000D7A B618                             mov dh, 24
   154 00000D7C B200                             mov dl, 0
   155 00000D7E 41B14F                           mov r9b, 0x4f
   156 00000D81 E893F3FFFF                       call put_cstringxy64                     ;位于core_utils64_mp.wid
   157                                  
   158 00000D86 FA                               cli
   159 00000D87 F4                               hlt                                      ;停机且不接受外部硬件中断
   160                                  
   161 00000D88 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
   161 00000D91 6F6E20726169736564-
   161 00000D9A 2C68616C742E00     
   162                                  
   163                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   164                                  search_for_a_ready_thread:                        ;查找一个就绪的线程并将其置为忙
   165                                                                                    ;返回：R11=就绪线程所属任务的PCB线性地址
   166                                                                                    ;      R12=就绪线程的TCB线性地址
   167                                           ;此例程通常是在中断处理过程内调用，默认中断是关闭状态。
   168 00000DA1 50                               push rax
   169 00000DA2 53                               push rbx
   170 00000DA3 51                               push rcx
   171                                  
   172 00000DA4 B901000000                       mov rcx, 1                               ;RCX=线程的“忙”状态
   173                                  
   174 00000DA9 0F01F8                           swapgs
   175 00000DAC 65488B1C2508000000               mov rbx, [gs:8]                          ;取得当前任务的PCB线性地址
   176 00000DB5 654C8B242520000000               mov r12, [gs:32]                         ;取得当前线程的TCB线性地址
   177 00000DBE 0F01F8                           swapgs
   178 00000DC1 4989DB                           mov r11, rbx
   179 00000DC4 4983FB00                         cmp r11, 0                               ;处理器当前未在执行任务？
   180 00000DC8 7511                             jne .nextt
   181 00000DCA 488B1D(C1020000)                 mov rbx, [rel pcb_ptr]                   ;是的。从PCB链表首节点及其第一个TCB开始搜索。
   182 00000DD1 4989DB                           mov r11, rbx
   183 00000DD4 4D8BA310010000                   mov r12, [r11 + 272]                     ;PCB链表首节点的第一个TCB节点
   184                                    .nextt:                                         ;这一部分遍历指定任务的TCB链表
   185 00000DDB 4983FC00                         cmp r12, 0                               ;正位于当前PCB的TCB链表末尾?
   186 00000DDF 7416                             je .nextp                                ;转去切换到PCB链表的下一个节点。
   187 00000DE1 4831C0                           xor rax, rax
   188 00000DE4 F0490FB14C2410                   lock cmpxchg [r12 + 16], rcx
   189 00000DEB 7425                             jz .retrn
   190 00000DED 4D8BA42418010000                 mov r12, [r12 + 280]                     ;取得下一个TCB节点
   191 00000DF5 EBE4                             jmp .nextt
   192                                    .nextp:                                         ;这一部分控制任务链表的遍历
   193 00000DF7 4D8B9B18010000                   mov r11, [r11 + 280]                     ;取得下一个PCB节点
   194 00000DFE 4939DB                           cmp r11, rbx                             ;是否转一圈回到初始PCB节点？
   195 00000E01 7409                             je .fmiss                                ;是。即，未找到就绪线程（节点）
   196 00000E03 4D8BA310010000                   mov r12, [r11 + 272]                     ;不是。从新的PCB中提取TCB链表首节点
   197 00000E0A EBCF                             jmp .nextt
   198                                    .fmiss:                                         ;看来系统中不存在就绪线程
   199 00000E0C 4D31DB                           xor r11, r11
   200 00000E0F 4D31E4                           xor r12, r12
   201                                    .retrn:
   202 00000E12 59                               pop rcx
   203 00000E13 5B                               pop rbx
   204 00000E14 58                               pop rax
   205                                  
   206 00000E15 C3                               ret
   207                                  
   208                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   209                                  resume_execute_a_thread:                          ;恢复执行一个线程
   210                                                                                    ;传入：R11=线程所属的任务的PCB线性地址
   211                                                                                    ;      R12=线程的TCB线性地址
   212                                           ;此例程在中断处理过程内调用，默认中断是关闭状态。
   213 00000E16 8B05(32010000)                   mov eax, [rel clocks_1ms]                ;以下计算新线程运行时间
   214 00000E1C 418B9C24F0000000                 mov ebx, [r12 + 240]                     ;为线程指定的时间片
   215 00000E24 F7E3                             mul ebx
   216                                  
   217 00000E26 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   217 00000E2F FF                 
   218 00000E30 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频
   218 00000E39 00                 
   219 00000E3A C78620030000FD0000-              mov dword [rsi + 0x320], 0xfd            ;单次击发模式，Fixed，中断号0xfd
   219 00000E43 00                 
   220                                  
   221 00000E44 498B5B38                         mov rbx, [r11 + 56]
   222 00000E48 0F22DB                           mov cr3, rbx                             ;切换地址空间
   223                                  
   224 00000E4B 0F01F8                           swapgs
   225 00000E4E 654C891C2508000000               mov [gs:8], r11                          ;将新线程所属的任务设置为当前任务
   226 00000E57 654C89242520000000               mov [gs:32], r12                         ;将新线程设置为当前线程
   227 00000E60 498B5C2420                       mov rbx, [r12 + 32]                      ;取TCB中的RSP0
   228 00000E65 6548891C2584000000               mov [gs:128 + 4], rbx                    ;置TSS的RSP0
   229 00000E6E 0F01F8                           swapgs
   230                                  
   231 00000E71 498B4C2450                       mov rcx, [r12 + 80]
   232 00000E76 498B542458                       mov rdx, [r12 + 88]
   233 00000E7B 498B7C2468                       mov rdi, [r12 + 104]
   234 00000E80 498B6C2470                       mov rbp, [r12 + 112]
   235 00000E85 498B642478                       mov rsp, [r12 + 120]
   236 00000E8A 4D8B842480000000                 mov r8, [r12 + 128]
   237 00000E92 4D8B8C2488000000                 mov r9, [r12 + 136]
   238 00000E9A 4D8B942490000000                 mov r10, [r12 + 144]
   239                                  
   240 00000EA2 4D8BAC24A8000000                 mov r13, [r12 + 168]
   241 00000EAA 4D8BB424B0000000                 mov r14, [r12 + 176]
   242 00000EB2 4D8BBC24B8000000                 mov r15, [r12 + 184]
   243 00000EBA 41FFB424D0000000                 push qword [r12 + 208]                   ;SS
   244 00000EC2 41FF742478                       push qword [r12 + 120]                   ;RSP
   245 00000EC7 41FFB424E8000000                 push qword [r12 + 232]                   ;RFLAGS
   246 00000ECF 41FFB424C8000000                 push qword [r12 + 200]                   ;CS
   247 00000ED7 41FFB424C0000000                 push qword [r12 + 192]                   ;RIP
   248                                  
   249 00000EDF 898680030000                     mov dword [rsi + 0x380], eax             ;开始计时
   250                                  
   251 00000EE5 498B442440                       mov rax, [r12 + 64]
   252 00000EEA 498B5C2448                       mov rbx, [r12 + 72]
   253 00000EEF 498B742460                       mov rsi, [r12 + 96]
   254 00000EF4 4D8B9C2498000000                 mov r11, [r12 + 152]
   255 00000EFC 4D8BA424A0000000                 mov r12, [r12 + 160]
   256                                  
   257 00000F04 48CF                             iretq                                    ;转入新线程执行
   258                                  
   259                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   260                                  time_slice_out_handler:                           ;时间片到期中断的处理过程
   261 00000F06 50                               push rax
   262 00000F07 53                               push rbx
   263 00000F08 4153                             push r11
   264 00000F0A 4154                             push r12
   265 00000F0C 4155                             push r13
   266                                  
   267 00000F0E 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   267 00000F17 FF                 
   268 00000F18 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   268 00000F21 0000               
   269                                  
   270 00000F23 E879FEFFFF                       call search_for_a_ready_thread
   271 00000F28 4D09DB                           or r11, r11
   272 00000F2B 0F8490000000                     jz .return                               ;未找到就绪的线程
   273                                  
   274 00000F31 0F01F8                           swapgs
   275 00000F34 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   276 00000F3D 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   277 00000F46 0F01F8                           swapgs
   278                                  
   279                                           ;保存当前任务和线程的状态以便将来恢复执行。
   280 00000F49 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   281 00000F4D 4C896838                         mov qword [rax + 56], r13
   282                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   283 00000F51 48894B50                         mov [rbx + 80], rcx
   284 00000F55 48895358                         mov [rbx + 88], rdx
   285 00000F59 48897360                         mov [rbx + 96], rsi
   286 00000F5D 48897B68                         mov [rbx + 104], rdi
   287 00000F61 48896B70                         mov [rbx + 112], rbp
   288 00000F65 48896378                         mov [rbx + 120], rsp
   289 00000F69 4C898380000000                   mov [rbx + 128], r8
   290 00000F70 4C898B88000000                   mov [rbx + 136], r9
   291 00000F77 4C899390000000                   mov [rbx + 144], r10
   292                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   293 00000F7E 4C89B3B0000000                   mov [rbx + 176], r14
   294 00000F85 4C89BBB8000000                   mov [rbx + 184], r15
   295 00000F8C 4C8B2D(08000000)                 mov r13, [rel position]
   296 00000F93 4D8DAD[C10F0000]                 lea r13, [r13 + .return]                 ;将来恢复执行时，是从中断返回也～
   297 00000F9A 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   298 00000FA1 8C8BC8000000                     mov [rbx + 200], cs
   299 00000FA7 8C93D0000000                     mov [rbx + 208], ss
   300 00000FAD 9C                               pushfq
   301 00000FAE 8F83E8000000                     pop qword [rbx + 232]
   302                                  
   303 00000FB4 48C7431000000000                 mov qword [rbx + 16], 0                  ;置线程状态为就绪
   304                                  
   305 00000FBC E955FEFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   306                                  
   307                                    .return:
   308 00000FC1 415D                             pop r13
   309 00000FC3 415C                             pop r12
   310 00000FC5 415B                             pop r11
   311 00000FC7 5B                               pop rbx
   312 00000FC8 58                               pop rax
   313 00000FC9 48CF                             iretq
   314                                  
   315                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   316                                  ;新任务/线程创建后，将广播新任务/线程创建消息给所有处理器，所有处理器执行此中断服务例程。
   317                                  new_task_notify_handler:                          ;任务/线程认领中断的处理过程
   318 00000FCB 56                               push rsi
   319 00000FCC 4153                             push r11
   320 00000FCE 4154                             push r12
   321                                  
   322 00000FD0 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   322 00000FD9 FF                 
   323 00000FDA C786B0000000000000-              mov dword [rsi + 0xb0], 0                ;发送EOI
   323 00000FE3 00                 
   324                                  
   325 00000FE4 0F01F8                           swapgs
   326 00000FE7 6548833C2508000000-              cmp qword [gs:8], 0                      ;当前处理器没有任务执行吗？
   326 00000FF0 00                 
   327 00000FF1 0F01F8                           swapgs
   328 00000FF4 7522                             jne .return                              ;是的（忙）。不打扰了 :)
   329                                  
   330 00000FF6 E8A6FDFFFF                       call search_for_a_ready_thread
   331 00000FFB 4D09DB                           or r11, r11
   332 00000FFE 7418                             jz .return                               ;未找到就绪的任务
   333                                  
   334 00001000 0F01F8                           swapgs
   335 00001003 4883C418                         add rsp, 24                              ;去掉进入例程时压入的三个参数
   336 00001007 654889242518000000               mov qword [gs:24], rsp                   ;保存固有栈当前指针以便将来返回
   337 00001010 0F01F8                           swapgs
   338                                  
   339 00001013 E9FEFDFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   340                                  
   341                                    .return:
   342 00001018 415C                             pop r12
   343 0000101A 415B                             pop r11
   344 0000101C 5E                               pop rsi
   345                                  
   346 0000101D 48CF                             iretq
   347                                  
   348                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   349 0000101F 0000000000000000          _append_lock  dq 0
   350                                  
   351                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   352                                                                                    ;输入：R11=PCB线性基地址
   353 00001027 50                               push rax
   354 00001028 53                               push rbx
   355                                  
   356 00001029 9C                               pushfq                                   ;-->A
   357 0000102A FA                               cli
   358                                           SET_SPIN_LOCK rax, qword [rel _append_lock]
    64                              <1>  %%spin_lock:
    65 0000102B 48833DECFFFFFF00    <1>  cmp %2, 0
    66 00001033 7404                <1>  je %%get_lock
    67 00001035 F390                <1>  pause
    68 00001037 EBF2                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00001039 B801000000          <1>  mov %1, 1
    71 0000103E 488705DAFFFFFF      <1>  xchg %1, %2
    72 00001045 4883F800            <1>  cmp %1, 0
    73 00001049 75E0                <1>  jne %%spin_lock
   359                                  
   360 0000104B 488B1D(C1020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   361 00001052 4809DB                           or rbx, rbx
   362 00001055 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   363 00001057 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   364 0000105A 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   365 00001061 4C891D(C1020000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   366 00001068 EB17                             jmp .return
   367                                  
   368                                    .not_empty:
   369 0000106A 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   370                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   371 0000106D 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   372 00001074 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   373 0000107B 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   374 0000107E 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   375                                  
   376                                    .return:
   377 00001081 48C70593FFFFFF0000-              mov qword [rel _append_lock], 0          ;释放锁
   377 0000108A 0000               
   378 0000108C 9D                               popfq                                    ;A
   379                                  
   380 0000108D 5B                               pop rbx
   381 0000108E 58                               pop rax
   382                                  
   383 0000108F C3                               ret
   384                                  
   385                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   386                                  get_current_tid:                                  ;返回当前线程的标识
   387 00001090 9C                               pushfq
   388 00001091 FA                               cli
   389 00001092 0F01F8                           swapgs
   390 00001095 65488B042520000000               mov rax, [gs:32]
   391 0000109E 488B4008                         mov rax, [rax + 8]
   392 000010A2 0F01F8                           swapgs
   393 000010A5 9D                               popfq
   394                                  
   395 000010A6 C3                               ret
   396                                  
   397                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   398                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   399 000010A7 9C                               pushfq
   400 000010A8 FA                               cli
   401 000010A9 0F01F8                           swapgs
   402 000010AC 65488B042508000000               mov rax, [gs:8]
   403 000010B5 488B4008                         mov rax, [rax + 8]
   404 000010B9 0F01F8                           swapgs
   405 000010BC 9D                               popfq
   406                                  
   407 000010BD C3                               ret
   408                                  
   409                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   410                                  thread_exit:                                      ;线程终止退出
   411                                                                                    ;输入：RDX=返回码
   412 000010BE FA                               cli
   413                                  
   414 000010BF 0F01F8                           swapgs
   415 000010C2 65488B1C2520000000               mov rbx, [gs:32]                         ;取出当前线程的TCB线性地址
   416 000010CB 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   417 000010D4 0F01F8                           swapgs
   418                                  
   419 000010D7 48C7431002000000                 mov qword [rbx + 16], 2                  ;线程状态：终止
   420 000010DF 48895318                         mov [rbx + 24], rdx                      ;返回代码
   421                                  
   422 000010E3 E8B9FCFFFF                       call search_for_a_ready_thread
   423 000010E8 4D09DB                           or r11, r11
   424 000010EB 7405                             jz .sleep                                ;未找到就绪的线程
   425                                  
   426 000010ED E924FDFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   427                                  
   428                                    .sleep:
   429 000010F2 48CF                             iretq                                    ;回到不执行线程的日子:)
   430                                  
   431                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   432                                  terminate_process:                                ;终止当前任务
   433 000010F4 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   433 000010FD FF                 
   434 000010FE C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   434 00001107 00                 
   435                                  
   436 00001108 FA                               cli
   437                                  
   438 00001109 0F01F8                           swapgs
   439 0000110C 65488B042508000000               mov rax, [gs:8]                          ;定位到当前任务的PCB节点
   440 00001115 48C7401002000000                 mov qword [rax + 16], 2                  ;任务状态=终止
   441 0000111D 65488B042520000000               mov rax, [gs:32]                         ;定位到当前线程的TCB节点
   442 00001126 48C7401002000000                 mov qword [rax + 16], 2                  ;线程状态=终止
   443 0000112E 6548C7042500000000-              mov qword [gs:0], 0
   443 00001137 00000000           
   444 0000113B 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   445 00001144 0F01F8                           swapgs
   446                                  
   447 00001147 E855FCFFFF                       call search_for_a_ready_thread
   448 0000114C 4D09DB                           or r11, r11
   449 0000114F 7405                             jz .sleep                                ;未找到就绪的任务
   450                                  
   451 00001151 E9C0FCFFFF                       jmp resume_execute_a_thread              ;恢复并执行新任务
   452                                  
   453                                    .sleep:
   454 00001156 48CF                             iretq                                    ;回到不执行任务的日子:)
   455                                  
   456                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   457                                  create_thread:                                    ;创建一个线程
   458                                                                                    ;输入：RSI=线程入口的线性地址
   459                                                                                    ;      RDI=传递给线程的参数
   460                                                                                    ;输出：RDX=线程标识
   461 00001158 50                               push rax
   462 00001159 53                               push rbx
   463 0000115A 51                               push rcx
   464 0000115B 4153                             push r11
   465 0000115D 4154                             push r12
   466 0000115F 4155                             push r13
   467 00001161 4156                             push r14
   468                                  
   469                                           ;先创建线程控制块TCB
   470 00001163 B900020000                       mov rcx, 512                             ;线程控制块TCB的尺寸
   471 00001168 E80EF8FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   472                                  
   473 0000116D 4C89EB                           mov rbx, r13                             ;以下，RBX专用于保存TCB线性地址
   474                                  
   475 00001170 E811FAFFFF                       call generate_thread_id
   476 00001175 48894308                         mov [rbx + 8], rax                       ;记录当前线程的标识
   477 00001179 4889C2                           mov rdx, rax                             ;用于返回线程标识
   478                                  
   479 0000117C 48C7431000000000                 mov qword [rbx + 16], 0                  ;线程状态=就绪
   480                                  
   481 00001184 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   482 00001189 E8EDF7FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   483 0000118E 4C897320                         mov [rbx + 32], r14                      ;填写TCB中的RSP0域的值
   484                                  
   485 00001192 9C                               pushfq
   486 00001193 FA                               cli
   487 00001194 0F01F8                           swapgs
   488 00001197 654C8B1C2508000000               mov r11, [gs:8]                          ;获取当前任务的PCB线性地址
   489 000011A0 654C8B242520000000               mov r12, [gs:32]                         ;获取当前线程的TCB线性地址
   490 000011A9 0F01F8                           swapgs
   491 000011AC 9D                               popfq
   492                                  
   493 000011AD B900000100                       mov rcx, 4096 * 16                       ;为线程开辟栈空间
   494 000011B2 E845F8FFFF                       call user_memory_allocate
   495 000011B7 4983EE20                         sub r14, 32                              ;在栈中开辟32字节的空间
   496 000011BB 4C897378                         mov [rbx + 120], r14                     ;线程执行时的RSP。
   497                                  
   498 000011BF 498D4E08                         lea rcx, [r14 + 8]                       ;得到线程返回地址
   499 000011C3 49890E                           mov [r14], rcx
   500                                           ;以下填写指令MOV RAX, 9的机器代码
   501 000011C6 C601B8                           mov byte [rcx], 0xb8
   502 000011C9 C6410109                         mov byte [rcx + 1], 0x09
   503 000011CD C6410200                         mov byte [rcx + 2], 0x00
   504 000011D1 C6410300                         mov byte [rcx + 3], 0x00
   505 000011D5 C6410400                         mov byte [rcx + 4], 0x00
   506                                           ;以下填写指令XOR RDX, RDX的机器代码
   507 000011D9 C6410548                         mov byte [rcx + 5], 0x48
   508 000011DD C6410631                         mov byte [rcx + 6], 0x31
   509 000011E1 C64107D2                         mov byte [rcx + 7], 0xd2
   510                                           ;以下填写指令SYSCALL的机器代码
   511 000011E5 C641080F                         mov byte [rcx + 8], 0x0f
   512 000011E9 C6410905                         mov byte [rcx + 9], 0x05
   513                                  
   514 000011ED 4889B3C0000000                   mov qword [rbx + 192], rsi               ;线程入口点（RIP）
   515                                  
   516 000011F4 48C783C80000003B00-              mov qword [rbx + 200], USER_CODE64_SEL   ;线程的代码段选择子
   516 000011FD 0000               
   517 000011FF 48C783D00000003300-              mov qword [rbx + 208], USER_STACK64_SEL  ;线程的栈段选择子
   517 00001208 0000               
   518                                  
   519 0000120A 9C                               pushfq
   520 0000120B 8F83E8000000                     pop qword [rbx + 232]                    ;线程执行时的标志寄存器
   521                                  
   522 00001211 48C783F00000003700-              mov qword [rbx + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片
   522 0000121A 0000               
   523                                  
   524 0000121C 48C783180100000000-              mov qword [rbx + 280], 0                 ;下一个TCB的线性地址，0=无
   524 00001225 0000               
   525                                  
   526                                    .again:
   527 00001227 4831C0                           xor rax, rax
   528 0000122A F0490FB19C24180100-              lock cmpxchg [r12 + 280], rbx            ;如果节点的后继为0，则新节点为其后继
   528 00001233 00                 
   529 00001234 740A                             jz .linkd
   530 00001236 4D8BA42418010000                 mov r12, [r12 + 280]
   531 0000123E EBE7                             jmp .again
   532                                    .linkd:
   533 00001240 48B900E0FFFF7FFFFF-              mov rcx, LAPIC_START_ADDR                ;Local APIC的线性地址
   533 00001249 FF                 
   534 0000124A C78110030000000000-              mov dword [rcx + 0x310], 0
   534 00001253 00                 
   535 00001254 C78100030000FE4008-              mov dword [rcx + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   535 0000125D 00                 
   536                                  
   537 0000125E 415E                             pop r14
   538 00001260 415D                             pop r13
   539 00001262 415C                             pop r12
   540 00001264 415B                             pop r11
   541 00001266 59                               pop rcx
   542 00001267 5B                               pop rbx
   543 00001268 58                               pop rax
   544                                  
   545 00001269 C3                               ret
   546                                  
   547                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   548                                  create_process:                                   ;创建新的任务及其主线程
   549                                                                                    ;输入：R8=程序的起始逻辑扇区号
   550 0000126A 50                               push rax
   551 0000126B 53                               push rbx
   552 0000126C 51                               push rcx
   553 0000126D 52                               push rdx
   554 0000126E 56                               push rsi
   555 0000126F 57                               push rdi
   556 00001270 55                               push rbp
   557 00001271 4150                             push r8
   558 00001273 4151                             push r9
   559 00001275 4152                             push r10
   560 00001277 4153                             push r11
   561 00001279 4154                             push r12
   562 0000127B 4155                             push r13
   563 0000127D 4156                             push r14
   564 0000127F 4157                             push r15
   565                                  
   566                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   567 00001281 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   568 00001286 E8F0F6FFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   569 0000128B 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   570                                  
   571 0000128E E8E8F6FFFF                       call core_memory_allocate                ;为线程控制块TCB分配内存
   572 00001293 4D89EC                           mov r12, r13                             ;以下，R12专用于保存TCB线性地址
   573                                  
   574 00001296 4D89A310010000                   mov qword [r11 + 272], r12               ;在PCB中登记第一个TCB
   575                                  
   576 0000129D 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   577                                  
   578                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   579 000012A5 E8A6F7FFFF                       call copy_current_pml4
   580 000012AA 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   581                                  
   582                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   583                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   584                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈是位于地址空间高端的栈。
   585                                  
   586 000012AE 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   587 000012B2 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   588                                  
   589                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   590 000012B5 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   591 000012BC B900010000                       mov rcx, 256
   592                                    .clsp:
   593 000012C1 48C70000000000                   mov qword [rax], 0
   594 000012C8 4883C008                         add rax, 8
   595 000012CC E2F3                             loop .clsp
   596                                  
   597 000012CE 0F20D8                           mov rax, cr3                             ;刷新TLB
   598 000012D1 0F22D8                           mov cr3, rax
   599                                  
   600 000012D4 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   601 000012D9 E89DF6FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   602 000012DE 4D89742420                       mov [r12 + 32], r14                      ;填写TCB中的RSP0域的值
   603                                  
   604 000012E3 B900000100                       mov rcx, 4096 * 16                       ;为主线程开辟栈空间
   605 000012E8 E80FF7FFFF                       call user_memory_allocate
   606 000012ED 4D89742478                       mov [r12 + 120], r14                     ;主线程执行时的RSP。
   607                                  
   608 000012F2 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=运行
   609 000012FA 49C744241000000000               mov qword [r12 + 16], 0                  ;线程状态=就绪
   610                                  
   611                                           ;以下开始加载用户程序
   612 00001303 B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   613 00001308 E8EFF6FFFF                       call user_memory_allocate
   614 0000130D 4C89EB                           mov rbx, r13
   615 00001310 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   616 00001313 E840EFFFFF                       call read_hard_disk_0
   617                                  
   618 00001318 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   619 0000131C 4D89EE                           mov r14, r13
   620 0000131F 4D037508                         add r14, [r13 + 8]
   621 00001323 4D89B424C0000000                 mov [r12 + 192], r14                     ;在TCB中登记程序的入口点线性地址
   622                                  
   623                                           ;以下判断整个程序有多大
   624 0000132B 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   625 0000132F 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   626 00001336 740F                             jz .y512
   627 00001338 48C1E909                         shr rcx, 9                               ;不能？凑整。
   628 0000133C 48C1E109                         shl rcx, 9
   629 00001340 4881C100020000                   add rcx, 512
   630                                    .y512:
   631 00001347 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   632 0000134E 7416                             jz .rdok
   633 00001350 E8A7F6FFFF                       call user_memory_allocate
   634                                           ;mov rbx, r13
   635 00001355 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   636 00001359 48FFC0                           inc rax                                  ;起始扇区号
   637                                    .b1:
   638 0000135C E8F7EEFFFF                       call read_hard_disk_0
   639 00001361 48FFC0                           inc rax
   640 00001364 E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   641                                  
   642                                    .rdok:
   643 00001366 49C78424C80000003B-              mov qword [r12 + 200], USER_CODE64_SEL   ;主线程的代码段选择子
   643 0000136F 000000             
   644 00001372 49C78424D000000033-              mov qword [r12 + 208], USER_STACK64_SEL  ;主线程的栈段选择子
   644 0000137B 000000             
   645                                  
   646 0000137E 9C                               pushfq
   647 0000137F 418F8424E8000000                 pop qword [r12 + 232]
   648                                  
   649 00001387 49C78424F000000037-              mov qword [r12 + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片
   649 00001390 000000             
   650                                  
   651 00001393 E8D7F7FFFF                       call generate_process_id
   652 00001398 49894308                         mov [r11 + 8], rax                       ;记录新任务的标识
   653                                  
   654 0000139C E8E5F7FFFF                       call generate_thread_id
   655 000013A1 4989442408                       mov [r12 + 8], rax                       ;记录主线程的标识
   656                                  
   657 000013A6 49C784241801000000-              mov qword [r12 + 280], 0                 ;下一个TCB的线性地址（0=无）
   657 000013AF 000000             
   658                                  
   659 000013B2 E870FCFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   660                                  
   661 000013B7 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   662                                  
   663 000013BB 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   663 000013C4 FF                 
   664 000013C5 C78610030000000000-              mov dword [rsi + 0x310], 0
   664 000013CE 00                 
   665 000013CF C78600030000FE4008-              mov dword [rsi + 0x300], 0x000840fe      ;向所有处理器发送任务/线程认领中断
   665 000013D8 00                 
   666                                  
   667 000013D9 415F                             pop r15
   668 000013DB 415E                             pop r14
   669 000013DD 415D                             pop r13
   670 000013DF 415C                             pop r12
   671 000013E1 415B                             pop r11
   672 000013E3 415A                             pop r10
   673 000013E5 4159                             pop r9
   674 000013E7 4158                             pop r8
   675 000013E9 5D                               pop rbp
   676 000013EA 5F                               pop rdi
   677 000013EB 5E                               pop rsi
   678 000013EC 5A                               pop rdx
   679 000013ED 59                               pop rcx
   680 000013EE 5B                               pop rbx
   681 000013EF 58                               pop rax
   682                                  
   683 000013F0 C3                               ret
   684                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   685                                  syscall_procedure:                                ;系统调用的处理过程
   686                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；进入时中断是禁止状态
   687 000013F1 0F01F8                           swapgs                                   ;切换GS到当前处理器的数据区
   688 000013F4 654889242500000000               mov [gs:0], rsp                          ;临时保存当前的3特权级栈指针
   689 000013FD 65488B242584000000               mov rsp, [gs:128+4]                      ;使用TSS的RSP0作为安全栈指针
   690 00001406 65FF342500000000                 push qword [gs:0]
   691 0000140E 0F01F8                           swapgs
   692 00001411 FB                               sti                                      ;准备工作全部完成，中断和任务切换无虞
   693                                  
   694 00001412 4157                             push r15
   695 00001414 4C8B3D(08000000)                 mov r15, [rel position]
   696 0000141B 4D03BCC7[69020000]               add r15, [r15 + rax * 8 + sys_entry]     ;得到指定的那个系统调用功能的线性地址
   697 00001423 41FFD7                           call r15
   698 00001426 415F                             pop r15
   699                                  
   700 00001428 FA                               cli
   701 00001429 5C                               pop rsp                                  ;恢复原先的3特权级栈指针
   702 0000142A 480F07                           o64 sysret
   703                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   704                                  init:    ;初始化内核的工作环境
   705                                  
   706                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   707                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   708 0000142D 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   708 00001436 FF                 
   709 00001437 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   710                                  
   711 0000143F 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   712                                  
   713                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   714                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   715 00001447 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   715 00001450 FF                 
   716 00001451 4801C4                           add rsp, rax                             ;栈指针必须转换为高端地址且必须是扩高地址
   717                                  
   718                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   719 00001454 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   719 0000145D FF                 
   720 0000145E 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   721                                  
   722                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   723 00001465 488B05(08000000)                 mov rax, [rel position]
   724 0000146C 4805[74140000]                   add rax, .to_upper
   725 00001472 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   726                                  
   727                                    .to_upper:
   728                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   729                                  
   730                                           ;为32个异常创建通用处理过程的中断门
   731 00001474 4C8B0D(08000000)                 mov r9, [rel position]
   732 0000147B 498D81[6C0D0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   733 00001482 E825EDFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   734                                  
   735 00001487 4D31C0                           xor r8, r8
   736                                    .idt0:
   737 0000148A E87EEDFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   738 0000148F 49FFC0                           inc r8
   739 00001492 4983F81F                         cmp r8, 31
   740 00001496 7EF2                             jle .idt0
   741                                  
   742                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   743 00001498 498D81[6A0D0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   744 0000149F E808EDFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   745                                  
   746 000014A4 41B820000000                     mov r8, 32
   747                                    .idt1:
   748 000014AA E85EEDFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   749 000014AF 49FFC0                           inc r8
   750 000014B2 4981F8FF000000                   cmp r8, 255
   751 000014B9 7EEF                             jle .idt1
   752                                  
   753 000014BB 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   753 000014C4 FF                 
   754 000014C5 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   754 000014CE FF                 
   755 000014CF 4889430E                         mov qword [rbx + 0x0e], rax
   756 000014D3 66C7430CFF0F                     mov word [rbx + 0x0c], 256*16-1
   757                                  
   758 000014D9 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   759                                  
   760 000014DD B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   761 000014DF E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   762                                  
   763                                           ;在64位模式下显示的第一条信息!
   764 000014E1 4C8B3D(08000000)                 mov r15, [rel position]
   765 000014E8 498D9F[36010000]                 lea rbx, [r15 + welcome]
   766 000014EF E814EBFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   767                                  
   768                                           ;安装系统服务（SYSCALL/SYSRET）所需要的代码段和栈段描述符
   769 000014F4 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区SDA的线性地址
   769 000014FD FF                 
   770 000014FE 4831DB                           xor rbx, rbx
   771 00001501 66418B5F02                       mov bx, [r15 + 2]                        ;BX=GDT的界限值
   772 00001506 66FFC3                           inc bx                                   ;BX=GDT的长度
   773 00001509 49035F04                         add rbx, [r15 + 4]                       ;RBX=新描述符的追加位置
   774                                  
   775 0000150D C703FFFF0000                     mov dword [rbx], 0x0000ffff              ;64位模式下不支持64位立即数传送
   776 00001513 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   777 0000151A C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   778 00001521 C7430C00000000                   mov dword [rbx + 12], 0
   779 00001528 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   780 0000152F C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   781 00001536 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   782 0000153D C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   783                                  
   784                                           ;我们为每个逻辑处理器都准备一个专属数据区，它是由每个处理器的GS所指向的。
   785                                           ;为当前处理器（BSP）准备专属数据区，设置GS并安装任务状态段TSS的描述符
   786 00001544 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
   787 00001549 E82DF4FFFF                       call core_memory_allocate
   788 0000154E 49C7450800000000                 mov qword [r13 + 8], 0                   ;提前将“当前任务的PCB指针域”清零
   789 00001556 49C7451000000000                 mov qword [r13 + 16], 0                  ;将当前处理器的编号设置为#0
   790 0000155E 49896518                         mov [r13 + 24], rsp                      ;设置当前处理器的专属栈
   791 00001562 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
   792 00001569 E876ECFFFF                       call make_tss_descriptor
   793 0000156E 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   794 00001572 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   795                                  
   796 00001576 664183470230                     add word [r15 + 2], 48                   ;4个段描述符和1个TSS描述符的总字节数
   797 0000157C 410F015702                       lgdt [r15 + 2]
   798                                  
   799 00001581 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   800 00001585 0F00D9                           ltr cx
   801                                  
   802                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
   803 00001588 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
   804 0000158D 4C89E8                           mov rax, r13                             ;只用EAX
   805 00001590 4C89EA                           mov rdx, r13
   806 00001593 48C1EA20                         shr rdx, 32                              ;只用EDX
   807 00001597 0F30                             wrmsr
   808                                  
   809                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   810 00001599 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   811 0000159E 0F32                             rdmsr
   812 000015A0 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   813 000015A4 0F30                             wrmsr
   814                                  
   815 000015A6 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   816 000015AB BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   817 000015B0 31C0                             xor eax, eax
   818 000015B2 0F30                             wrmsr
   819                                  
   820 000015B4 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   821 000015B9 488B05(08000000)                 mov rax, [rel position]
   822 000015C0 488D80[F1130000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   823 000015C7 4889C2                           mov rdx, rax
   824 000015CA 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   825 000015CE 0F30                             wrmsr
   826                                  
   827 000015D0 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   828 000015D5 31D2                             xor edx, edx
   829 000015D7 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   830 000015DC 0F30                             wrmsr
   831                                  
   832                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   833                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   834                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   835                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   836                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   837                                  
   838                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   839                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   840 000015DE 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   841 000015E7 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   842 000015E9 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   843                                    .looking:
   844 000015EE 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   845 000015F2 741B                             jz .looked
   846 000015F4 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   847 000015F8 E2F4                             loop .looking
   848                                  
   849                                    .acpi_err:
   850 000015FA 4C8B3D(08000000)                 mov r15, [rel position]
   851 00001601 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   852 00001608 E8FBE9FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   853 0000160D FA                               cli
   854 0000160E F4                               hlt
   855                                  
   856                                    .looked:
   857 0000160F 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   858 00001612 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   859 00001616 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   860 00001619 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   861                                    .maping:
   862 00001620 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   863 00001623 4889D8                           mov rax, rbx
   864 00001626 4821D0                           and rax, rdx
   865 00001629 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   866 0000162D E84EF2FFFF                       call mapping_laddr_to_page
   867 00001632 4881C300100000                   add rbx, 0x1000
   868 00001639 4839CB                           cmp rbx, rcx
   869 0000163C 7EE2                             jle .maping
   870                                  
   871                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   872 0000163E BB00000600                       mov rbx, 0x60000
   873 00001643 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   873 0000164C 20                 
   874                                    .searc:
   875 0000164D 48390B                           cmp qword [rbx], rcx
   876 00001650 740F                             je .finda
   877 00001652 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   878 00001656 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   879 0000165D 7CEE                             jl .searc
   880 0000165F EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   881                                  
   882                                    .finda:
   883                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   884                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   885 00001661 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   886 00001665 752B                             jne .vcpi_1
   887 00001667 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   888                                  
   889                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   890 0000166B 4831FF                           xor rdi, rdi
   891 0000166E 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   892 00001671 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   893 00001674 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   894                                    .madt0:
   895 00001678 4C8B1B                           mov r11, [rbx]
   896 0000167B 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   897 00001682 7436                             je .findm
   898 00001684 4883C308                         add rbx, 8                               ;下一个元素
   899 00001688 4839FB                           cmp rbx, rdi
   900 0000168B 7CEB                             jl .madt0
   901 0000168D E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   902                                  
   903                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   904                                    .vcpi_1:
   905 00001692 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   906                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   907 00001695 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   908 00001699 01DF                             add edi, ebx                             ;计算RSDT上边界的物理位置
   909 0000169B 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   910 0000169E 4D31DB                           xor r11, r11
   911                                    .madt1:
   912 000016A1 67448B1B                         mov r11d, [ebx]
   913 000016A5 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   914 000016AC 740C                             je .findm
   915 000016AE 83C304                           add ebx, 4                               ;下一个元素
   916 000016B1 39FB                             cmp ebx, edi
   917 000016B3 7CEC                             jl .madt1
   918 000016B5 E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   919                                  
   920                                    .findm:
   921                                           ;此时，R11是MADT的物理地址
   922 000016BA 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   923 000016BE 8915(28010000)                   mov [rel lapic_addr], edx
   924                                  
   925                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   926 000016C4 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   927 000016CB 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   928                                  
   929 000016D2 4831FF                           xor rdi, rdi
   930 000016D5 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   931 000016D9 4C01DF                           add rdi, r11                             ;RDI:MADT上部边界的物理地址
   932 000016DC 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   933                                    .enumd:
   934 000016E0 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   935 000016E4 7408                             je .l_apic
   936 000016E6 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   937 000016EA 741B                             je .ioapic
   938 000016EC EB2D                             jmp .m_end
   939                                    .l_apic:
   940 000016EE 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   941 000016F3 7426                             jz .m_end
   942 000016F5 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   943 000016F9 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   944 000016FC 49FFC7                           inc r15
   945 000016FF FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   946 00001705 EB14                             jmp .m_end
   947                                    .ioapic:
   948 00001707 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   949 0000170B 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   950 00001711 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   951 00001715 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   952                                     .m_end:
   953 0000171B 4831C0                           xor rax, rax
   954 0000171E 418A4301                         mov al, [r11 + 1]
   955 00001722 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   956 00001725 4939FB                           cmp r11, rdi
   957 00001728 7CB6                             jl .enumd
   958                                  
   959                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   960 0000172A 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   960 00001733 FF                 
   961 00001734 4831C0                           xor rax, rax
   962 00001737 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   963 0000173D 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   964 00001740 E83BF1FFFF                       call mapping_laddr_to_page
   965                                  
   966                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   967 00001745 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   967 0000174E FF                 
   968 0000174F 4831C0                           xor rax, rax
   969 00001752 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   970 00001758 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   971 0000175B E820F1FFFF                       call mapping_laddr_to_page
   972                                  
   973                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   974 00001760 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   974 00001769 FF                 
   975                                  
   976 0000176A C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发模式
   976 00001773 00                 
   977 00001774 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   977 0000177D 00                 
   978                                  
   979 0000177E B00B                             mov al, 0x0b                             ;RTC寄存器B
   980 00001780 0C80                             or al, 0x80                              ;阻断NMI
   981 00001782 E670                             out 0x70, al
   982 00001784 B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   983 00001786 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   984                                  
   985 00001788 B08A                             mov al, 0x8a                             ;CMOS寄存器A
   986 0000178A E670                             out 0x70, al
   987                                           ;in al, 0x71
   988 0000178C B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   989 0000178E E671                             out 0x71, al                             ;写回CMOS寄存器A
   990                                  
   991 00001790 B08C                             mov al, 0x8c
   992 00001792 E670                             out 0x70, al
   993 00001794 E471                             in al, 0x71                              ;读寄存器C
   994                                    .w0:
   995 00001796 E471                             in al, 0x71                              ;读寄存器C
   996 00001798 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   997 0000179D 73F7                             jnc .w0
   998 0000179F C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   998 000017A8 FF                 
   999                                    .w1:
  1000 000017A9 E471                             in al, 0x71                              ;读寄存器C
  1001 000017AB 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
  1002 000017B0 73F7                             jnc .w1
  1003 000017B2 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
  1004                                  
  1005 000017B8 B8FFFFFFFF                       mov eax, 0xffff_ffff
  1006 000017BD 29D0                             sub eax, edx
  1007 000017BF 31D2                             xor edx, edx
  1008 000017C1 BB7D000000                       mov ebx, 125                             ;125毫秒
  1009 000017C6 F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
  1010                                  
  1011 000017C8 8905(32010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
  1012                                  
  1013 000017CE B00B                             mov al, 0x0b                             ;RTC寄存器B
  1014 000017D0 0C80                             or al, 0x80                              ;阻断NMI
  1015 000017D2 E670                             out 0x70, al
  1016 000017D4 B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
  1017 000017D6 E671                             out 0x71, al
  1018                                  
  1019                                           ;以下安装新任务认领中断的处理过程
  1020 000017D8 4C8B0D(08000000)                 mov r9, [rel position]
  1021 000017DF 498D81[CB0F0000]                 lea rax, [r9 + new_task_notify_handler]  ;得到中断处理过程的线性地址
  1022 000017E6 E8C1E9FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1023                                  
  1024 000017EB FA                               cli
  1025 000017EC 41B8FE000000                     mov r8, 0xfe
  1026 000017F2 E816EAFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1027 000017F7 FB                               sti
  1028                                  
  1029                                           ;以下安装时间片到期中断的处理过程
  1030 000017F8 4C8B0D(08000000)                 mov r9, [rel position]
  1031 000017FF 498D81[060F0000]                 lea rax, [r9 + time_slice_out_handler]   ;得到中断处理过程的线性地址
  1032 00001806 E8A1E9FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1033                                  
  1034 0000180B FA                               cli
  1035 0000180C 41B8FD000000                     mov r8, 0xfd
  1036 00001812 E8F6E9FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1037 00001817 FB                               sti
  1038                                  
  1039                                           ;以下开始初始化应用处理器AP。先将初始化代码复制到物理内存最低端的选定位置
  1040 00001818 488B35(08000000)                 mov rsi, [rel position]
  1041 0000181F 488DB6[00000000]                 lea rsi, [rsi + section.ap_init_block.start]
  1042 00001826 BF00F00000                       mov rdi, AP_START_UP_ADDR
  1043 0000182B B983000000                       mov rcx, ap_init_tail - ap_init
  1044 00001830 FC                               cld
  1045 00001831 F3A4                             repe movsb
  1046                                  
  1047                                           ;所有处理器都应当在初始化期间递增应答计数值
  1048 00001833 FE05(31010000)                   inc byte [rel ack_cpus]                  ;BSP自己的应答计数值
  1049                                  
  1050                                           ;给其它处理器发送INIT IPI和SIPI，命令它们初始化自己
  1051 00001839 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
  1051 00001842 FF                 
  1052 00001843 C78610030000000000-              mov dword [rsi + 0x310], 0
  1052 0000184C 00                 
  1053 0000184D C7860003000000450C-              mov dword [rsi + 0x300], 0x000c4500      ;先发送INIT IPI
  1053 00001856 00                 
  1054 00001857 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
  1054 00001860 00                 
  1055 00001861 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
  1055 0000186A 00                 
  1056                                  
  1057 0000186B 8A05(27000000)                   mov al, [rel num_cpus]
  1058                                    .wcpus:
  1059 00001871 3A05(31010000)                   cmp al, [rel ack_cpus]
  1060 00001877 75F8                             jne .wcpus                               ;等待所有应用处理器的应答
  1061                                  
  1062                                           ;显示已应答的处理器的数量信息
  1063 00001879 4C8B3D(08000000)                 mov r15, [rel position]
  1064                                  
  1065 00001880 4D31C0                           xor r8, r8
  1066 00001883 448A05(31010000)                 mov r8b, [rel ack_cpus]
  1067 0000188A 498D9F[69010000]                 lea rbx, [r15 + buffer]
  1068 00001891 E843F3FFFF                       call bin64_to_dec
  1069 00001896 E86DE7FFFF                       call put_string64
  1070                                  
  1071 0000189B 498D9F[58010000]                 lea rbx, [r15 + cpu_init_ok]
  1072 000018A2 E861E7FFFF                       call put_string64                        ;位于core_utils64_mp.wid
  1073                                  
  1074                                           ;以下开始创建系统外壳任务（进程）
  1075 000018A7 41B832000000                     mov r8, 50
  1076 000018AD E8B8F9FFFF                       call create_process
  1077                                  
  1078 000018B2 E9B0F4FFFF                       jmp ap_to_core_entry.do_idle             ;去处理器集结休息区 :)
  1079                                  
  1080                                  ;===============================================================================
  1081                                  section ap_init_block vstart=0
  1082                                  
  1083                                           bits 16                                  ;应用处理器AP从实模式开始执行
  1084                                  
  1085                                  ap_init:                                          ;应用处理器AP的初始化代码
  1086 00000000 B8000F                           mov ax, AP_START_UP_ADDR >> 4
  1087 00000003 8ED8                             mov ds, ax
  1088                                  
  1089                                           SET_SPIN_LOCK al, byte [lock_var]        ;自旋直至获得锁
    64                              <1>  %%spin_lock:
    65 00000005 803E[8200]00        <1>  cmp %2, 0
    66 0000000A 7404                <1>  je %%get_lock
    67 0000000C F390                <1>  pause
    68 0000000E EBF5                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00000010 B001                <1>  mov %1, 1
    71 00000012 8606[8200]          <1>  xchg %1, %2
    72 00000016 3C00                <1>  cmp %1, 0
    73 00000018 75EB                <1>  jne %%spin_lock
  1090                                  
  1091 0000001A B8E007                           mov ax, SDA_PHY_ADDR >> 4                ;切换到系统数据区
  1092 0000001D 8ED8                             mov ds, ax
  1093                                  
  1094                                           ;加载描述符表寄存器GDTR
  1095 0000001F 0F01160200                       lgdt [2]                                 ;实模式下只加载6个字节的内容
  1096                                  
  1097 00000024 E492                             in al, 0x92                              ;南桥芯片内的端口
  1098 00000026 0C02                             or al, 0000_0010B
  1099 00000028 E692                             out 0x92, al                             ;打开A20
  1100                                  
  1101 0000002A FA                               cli                                      ;中断机制尚未工作
  1102                                  
  1103 0000002B 0F20C0                           mov eax, cr0
  1104 0000002E 6683C801                         or eax, 1
  1105 00000032 0F22C0                           mov cr0, eax                             ;设置PE位
  1106                                  
  1107                                           ;以下进入保护模式... ...
  1108 00000035 EA[3AF0]0800                     jmp 0x0008: AP_START_UP_ADDR + .flush    ;清流水线并串行化处理器
  1109                                  
  1110                                           [bits 32]
  1111                                    .flush:
  1112 0000003A B810000000                       mov eax, 0x0010                          ;加载数据段(4GB)选择子
  1113 0000003F 8ED0                             mov ss, eax                              ;加载堆栈段(4GB)选择子
  1114 00000041 BC007E0000                       mov esp, 0x7e00                          ;堆栈指针
  1115                                  
  1116                                           ;令CR3寄存器指向4级头表（保护模式下的32位CR3）
  1117 00000046 B800A00000                       mov eax, PML4_PHY_ADDR                   ;PCD=PWT=0
  1118 0000004B 0F22D8                           mov cr3, eax
  1119                                  
  1120                                           ;开启物理地址扩展PAE
  1121 0000004E 0F20E0                           mov eax, cr4
  1122 00000051 0FBAE805                         bts eax, 5
  1123 00000055 0F22E0                           mov cr4, eax
  1124                                  
  1125                                           ;设置型号专属寄存器IA32_EFER.LME，允许IA_32e模式
  1126 00000058 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
  1127 0000005D 0F32                             rdmsr
  1128 0000005F 0FBAE808                         bts eax, 8                               ;设置LME位
  1129 00000063 0F30                             wrmsr
  1130                                  
  1131                                           ;开启分页功能
  1132 00000065 0F20C0                           mov eax, cr0
  1133 00000068 0FBAE81F                         bts eax, 31                              ;置位CR0.PG
  1134 0000006C 0F22C0                           mov cr0, eax
  1135                                  
  1136                                           ;进入64位模式
  1137 0000006F EA[76F00000]1800                 jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
  1138                                    .to64:
  1139                                  
  1140                                           bits 64
  1141                                  
  1142                                           ;转入内核中继续初始化（使用高端线性地址）
  1143 00000076 48BB-                            mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
  1143 00000078 [440C02000080FFFF] 
  1144 00000080 FFE3                             jmp rbx
  1145                                  
  1146 00000082 00                        lock_var  db 0
  1147                                  
  1148                                  ap_init_tail:
  1149                                  
  1150                                  ;===============================================================================
  1151                                  section core_tail
  1152                                  core_end:
