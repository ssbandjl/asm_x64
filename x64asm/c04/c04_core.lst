     1                                  ;c04_core.asm:单处理器多任务内核，李忠，2022-01-20
     2                                  
     3                                  %include "..\common\global_defs.wid"
     4                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     5                              <1> 
     6                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     7                              <1> 
     8                              <1> %ifndef _GLOBAL_DEFS_
     9                              <1>    %define _GLOBAL_DEFS_
    10                              <1> 
    11                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    12                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    13                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    14                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    15                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    16                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    17                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    18                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    19                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    20                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    21                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    22                              <1> 	                                        ;页目录指针表
    23                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    24                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    25                              <1> 
    26                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    27                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    28                              <1> 
    29                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    30                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    31                              <1> 	                                                                ;端起始线性地址
    32                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    33                              <1> 	                                                                ;性地址
    34                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    35                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    36                              <1> 
    37                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    38                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    39                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    40                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    41                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    42                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    43                              <1> 
    44                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    45                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    46                              <1> 			;时的起始地址
    47                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    48                              <1> 			;时的起始地址
    49                              <1> 
    50                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    51                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    52                              <1> 
    53                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    54                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    55                              <1> 
    56                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    57                              <1> 
    58                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    59                              <1> 
    60                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    61                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    62                              <1>             %%spin_lock:
    63                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    64                              <1>                        je %%get_lock      	;获取锁
    65                              <1>                        pause
    66                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    67                              <1>             %%get_lock:
    68                              <1>                        mov %1, 1
    69                              <1>                        xchg %1, %2
    70                              <1>                        cmp %1, 0          	;交换前为零？
    71                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    72                              <1>    %endmacro
    73                              <1> 
    74                              <1> %endif
    75                              <1> 
     4                                  
     5                                  ;===============================================================================
     6                                  section core_header                               ;内核程序头部
     7 00000000 [C30F0000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     8 00000004 [8D0D0000]                init_entry   dd init                            ;#4：内核入口点
     9 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    10                                  
    11                                  ;===============================================================================
    12                                  section core_data                                 ;内核数据段
    13 00000000 457865637574696E67-       welcome      db "Executing in 64-bit mode.", 0x0d, 0x0a, 0
    13 00000009 20696E2036342D6269-
    13 00000012 74206D6F64652E0D0A-
    13 0000001B 00                 
    14 0000001C 0000000000000000          tss_ptr      dq 0                               ;任务状态段TSS从此处开始
    15 00000024 [FA09000000000000]        sys_entry    dq get_screen_row
    16 0000002C [5F09000000000000]                     dq get_cmos_time
    17 00000034 [DE00000000000000]                     dq put_cstringxy64
    18 0000003C [3C0C000000000000]                     dq create_process
    19 00000044 [1B0C000000000000]                     dq get_current_pid
    20 0000004C [270C000000000000]                     dq terminate_process
    21 00000054 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    22 0000005C 0000000000000000          cur_pcb      dq 0                               ;当前任务的PCB线性地址
    23                                  
    24                                  ;===============================================================================
    25                                  section core_code                                 ;内核代码段
    26                                  
    27                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    28                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    29                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    30                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    31                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    32                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    33                              <1> 
    34                              <1> %include "..\common\global_defs.wid"
    35                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    36                              <2> 
    37                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    38                              <2> 
    39                              <2> %ifndef _GLOBAL_DEFS_
    40                              <2>    %define _GLOBAL_DEFS_
    41                              <2> 
    42                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    43                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    44                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    45                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    46                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    47                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    48                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    49                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    50                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    51                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    52                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    53                              <2> 	                                        ;页目录指针表
    54                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    55                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    56                              <2> 
    57                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    58                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    59                              <2> 
    60                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    61                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    62                              <2> 	                                                                ;端起始线性地址
    63                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    64                              <2> 	                                                                ;性地址
    65                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    66                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    67                              <2> 
    68                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    69                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    70                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    71                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    72                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    73                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    74                              <2> 
    75                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    76                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    77                              <2> 			;时的起始地址
    78                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    79                              <2> 			;时的起始地址
    80                              <2> 
    81                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    82                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    83                              <2> 
    84                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    85                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    86                              <2> 
    87                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    88                              <2> 
    89                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    90                              <2> 
    91                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    92                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    93                              <2>             %%spin_lock:
    94                              <2>                        cmp %2, 0           	;锁是释放状态吗？
    95                              <2>                        je %%get_lock      	;获取锁
    96                              <2>                        pause
    97                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
    98                              <2>             %%get_lock:
    99                              <2>                        mov %1, 1
   100                              <2>                        xchg %1, %2
   101                              <2>                        cmp %1, 0          	;交换前为零？
   102                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
   103                              <2>    %endmacro
   104                              <2> 
   105                              <2> %endif
   106                              <2> 
    35                              <1> 
    36                              <1>          bits 64
    37                              <1> 
    38                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    39                              <1> %ifdef __MP__
    40                              <1> _prn_str_locker dq 0                  	;打印锁
    41                              <1> %endif
    42                              <1> 
    43                              <1> put_string64:       	;显示0终止的字符串并移动光标
    44                              <1>                      	;输入：RBX=字符串的线性地址
    45 00000000 53                  <1>          push rbx
    46 00000001 51                  <1>          push rcx
    47                              <1> 
    48 00000002 9C                  <1>          pushfq     	;-->A
    49 00000003 FA                  <1>          cli
    50                              <1> %ifdef __MP__
    51                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    52                              <1> %endif
    53                              <1> 
    54                              <1>   .getc:
    55 00000004 8A0B                <1>          mov cl, [rbx]
    56 00000006 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    57 00000008 740A                <1>          jz .exit                 	;显示完毕，返回
    58 0000000A E809000000          <1>          call put_char
    59 0000000F 48FFC3              <1>          inc rbx
    60 00000012 EBF0                <1>          jmp .getc
    61                              <1> 
    62                              <1>   .exit:
    63                              <1> %ifdef __MP__
    64                              <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    65                              <1> %endif
    66 00000014 9D                  <1>          popfq                               	;A
    67                              <1> 
    68 00000015 59                  <1>          pop rcx
    69 00000016 5B                  <1>          pop rbx
    70                              <1> 
    71 00000017 C3                  <1>          ret                                	;段内返回
    72                              <1> 
    73                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    74                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
    75                              <1> 	;进光标。
    76                              <1>                                            	;输入：CL=字符ASCII码
    77 00000018 50                  <1>          push rax
    78 00000019 53                  <1>          push rbx
    79 0000001A 51                  <1>          push rcx
    80 0000001B 52                  <1>          push rdx
    81 0000001C 56                  <1>          push rsi
    82 0000001D 57                  <1>          push rdi
    83                              <1> 
    84                              <1>          ;以下取当前光标位置
    85 0000001E 66BAD403            <1>          mov dx, 0x3d4
    86 00000022 B00E                <1>          mov al, 0x0e
    87 00000024 EE                  <1>          out dx, al
    88 00000025 66FFC2              <1>          inc dx                        	;0x3d5
    89 00000028 EC                  <1>          in al, dx                     	;高字
    90 00000029 88C4                <1>          mov ah, al
    91                              <1> 
    92 0000002B 66FFCA              <1>          dec dx                        	;0x3d4
    93 0000002E B00F                <1>          mov al, 0x0f
    94 00000030 EE                  <1>          out dx, al
    95 00000031 66FFC2              <1>          inc dx                        	;0x3d5
    96 00000034 EC                  <1>          in al, dx                     	;低字
    97 00000035 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
    98 00000038 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
    99                              <1> 
   100 0000003F 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
   101 00000042 750E                <1>          jnz .put_0a
   102 00000044 6689D8              <1>          mov ax, bx
   103 00000047 B350                <1>          mov bl, 80
   104 00000049 F6F3                <1>          div bl
   105 0000004B F6E3                <1>          mul bl
   106 0000004D 6689C3              <1>          mov bx, ax
   107 00000050 EB6C                <1>          jmp .set_cursor
   108                              <1> 
   109                              <1>   .put_0a:
   110 00000052 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   111 00000055 7506                <1>          jnz .put_other
   112 00000057 6683C350            <1>          add bx, 80
   113 0000005B EB16                <1>          jmp .roll_screen
   114                              <1> 
   115                              <1>   .put_other:                              	;正常显示字符
   116 0000005D 66D1E3              <1>          shl bx, 1
   117 00000060 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   117 00000069 FF                  <1>
   118 0000006A 880C18              <1>          mov [rax + rbx], cl
   119                              <1> 
   120                              <1>          ;以下将光标位置推进一个字符
   121 0000006D 66D1EB              <1>          shr bx, 1
   122 00000070 66FFC3              <1>          inc bx
   123                              <1> 
   124                              <1>   .roll_screen:
   125 00000073 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   126 00000078 7C44                <1>          jl .set_cursor
   127                              <1> 
   128 0000007A 6653                <1>          push bx
   129                              <1> 
   130 0000007C FC                  <1>          cld
   131 0000007D 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   131 00000086 FF                  <1>
   132 00000087 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   132 00000090 FF                  <1>
   133 00000091 B9E0010000          <1>          mov rcx, 480
   134 00000096 F348A5              <1>          rep movsq
   135 00000099 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   136 0000009D B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   137                              <1>   .cls:
   138 000000A2 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   138 000000AB FF                  <1>
   139 000000AC 66C704182007        <1>          mov word[rax + rbx], 0x0720
   140 000000B2 6683C302            <1>          add bx, 2
   141 000000B6 E2EA                <1>          loop .cls
   142                              <1> 
   143 000000B8 665B                <1>          pop bx
   144 000000BA 6683EB50            <1>          sub bx, 80
   145                              <1> 
   146                              <1>   .set_cursor:
   147 000000BE 66BAD403            <1>          mov dx, 0x3d4
   148 000000C2 B00E                <1>          mov al, 0x0e
   149 000000C4 EE                  <1>          out dx, al
   150 000000C5 66FFC2              <1>          inc dx                         	;0x3d5
   151 000000C8 88F8                <1>          mov al, bh
   152 000000CA EE                  <1>          out dx, al
   153 000000CB 66FFCA              <1>          dec dx       	;0x3d4
   154 000000CE B00F                <1>          mov al, 0x0f
   155 000000D0 EE                  <1>          out dx, al
   156 000000D1 66FFC2              <1>          inc dx       	;0x3d5
   157 000000D4 88D8                <1>          mov al, bl
   158 000000D6 EE                  <1>          out dx, al
   159                              <1> 
   160 000000D7 5F                  <1>          pop rdi
   161 000000D8 5E                  <1>          pop rsi
   162 000000D9 5A                  <1>          pop rdx
   163 000000DA 59                  <1>          pop rcx
   164 000000DB 5B                  <1>          pop rbx
   165 000000DC 58                  <1>          pop rax
   166                              <1> 
   167 000000DD C3                  <1>          ret
   168                              <1> 
   169                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   170                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   171                              <1> ;不同，互不干扰，不需要加锁和互斥。
   172                              <1> %ifdef __MP__
   173                              <1> _prnxy_locker dq 0
   174                              <1> %endif
   175                              <1> 
   176                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   177                              <1>                                           	;DH=行，DL=列
   178                              <1>                                           	;R9B=颜色属性
   179 000000DE 50                  <1>          push rax
   180 000000DF 53                  <1>          push rbx
   181 000000E0 51                  <1>          push rcx
   182 000000E1 52                  <1>          push rdx
   183 000000E2 4150                <1>          push r8
   184                              <1> 
   185                              <1>          ;指定坐标位置在显存内的偏移量
   186 000000E4 88F0                <1>          mov al, dh
   187 000000E6 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   188 000000E8 F6E5                <1>          mul ch
   189 000000EA D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   190 000000EC 6681E2FF00          <1>          and dx, 0x00ff
   191 000000F1 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   192 000000F4 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   193                              <1> 
   194 000000FA 9C                  <1>          pushfq                        	;-->A
   195 000000FB FA                  <1>          cli
   196                              <1> %ifdef __MP__
   197                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   198                              <1> %endif
   199                              <1> 
   200 000000FC 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   200 00000105 FF                  <1>
   201                              <1>   .nextc:
   202 00000106 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   203 00000108 08D2                <1>          or dl, dl
   204 0000010A 7412                <1>          jz .exit
   205 0000010C 41881400            <1>          mov byte [r8 + rax], dl
   206 00000110 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   207 00000115 48FFC3              <1>          inc rbx
   208 00000118 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   209 0000011C EBE8                <1>          jmp .nextc
   210                              <1>   .exit:
   211 0000011E 4D31C0              <1>          xor r8, r8
   212                              <1> %ifdef __MP__
   213                              <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   214                              <1> %endif
   215 00000121 9D                  <1>          popfq                              	;A
   216                              <1> 
   217 00000122 4158                <1>          pop r8
   218 00000124 5A                  <1>          pop rdx
   219 00000125 59                  <1>          pop rcx
   220 00000126 5B                  <1>          pop rbx
   221 00000127 58                  <1>          pop rax
   222                              <1> 
   223 00000128 C3                  <1>          ret
   224                              <1> 
   225                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   226                              <1> make_call_gate:                          	;创建64位的调用门
   227                              <1>                                           	;输入：RAX=例程的线性地址
   228                              <1>                                           	;输出：RDI:RSI=调用门
   229 00000129 4889C7              <1>          mov rdi, rax
   230 0000012C 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   231                              <1> 
   232 00000130 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   233 00000131 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   234 00000138 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   235 0000013C 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   236 00000143 5E                  <1>          pop rsi
   237                              <1> 
   238 00000144 C3                  <1>          ret
   239                              <1> 
   240                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   241                              <1> make_interrupt_gate:                      	;创建64位的中断门
   242                              <1>                                             	;输入：RAX=例程的线性地址
   243                              <1>                                             	;输出：RDI:RSI=中断门
   244 00000145 4889C7              <1>          mov rdi, rax
   245 00000148 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   246                              <1> 
   247 0000014C 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   248 0000014D 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   249 00000154 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   250 00000158 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   251 0000015F 5E                  <1>          pop rsi
   252                              <1> 
   253 00000160 C3                  <1>          ret
   254                              <1> 
   255                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   256                              <1> make_trap_gate:                             	;创建64位的陷阱门
   257                              <1>                                              	;输入：RAX=例程的线性地址
   258                              <1>                                              	;输出：RDI:RSI=陷阱门
   259 00000161 4889C7              <1>          mov rdi, rax
   260 00000164 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   261                              <1> 
   262 00000168 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   263 00000169 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   264 00000170 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   265 00000174 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   266 0000017B 5E                  <1>          pop rsi
   267                              <1> 
   268 0000017C C3                  <1>          ret
   269                              <1> 
   270                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   271                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   272                              <1>                                           	;输入：RAX=TSS的线性地址
   273                              <1>                                           	;输出：RDI:RSI=TSS描述符
   274 0000017D 50                  <1>          push rax
   275                              <1> 
   276 0000017E 4889C7              <1>          mov rdi, rax
   277 00000181 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   278                              <1> 
   279 00000185 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   280 00000186 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   281 0000018B 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   282 00000191 8A442405            <1>          mov al, [rsp + 5]
   283 00000195 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   284 00000199 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   285 0000019E C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   286 000001A3 5E                  <1>          pop rsi                       	;门的低64位
   287                              <1> 
   288 000001A4 58                  <1>          pop rax
   289                              <1> 
   290 000001A5 C3                  <1>          ret
   291                              <1> 
   292                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   293                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   294                              <1>                                        	;R8=中断向量
   295                              <1>                                        	;RDI:RSI=门描述符
   296 000001A6 4150                <1>          push r8
   297 000001A8 4151                <1>          push r9
   298                              <1> 
   299 000001AA 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   300 000001AE 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   300 000001B7 FF                  <1>
   301 000001B8 4B893401            <1>          mov [r9 + r8], rsi
   302 000001BC 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   303                              <1> 
   304 000001C1 4159                <1>          pop r9
   305 000001C3 4158                <1>          pop r8
   306                              <1> 
   307 000001C5 C3                  <1>          ret
   308                              <1> 
   309                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   310                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   311 000001C6 50                  <1>          push rax
   312                              <1> 
   313 000001C7 B011                <1>          mov al, 0x11
   314 000001C9 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   315 000001CB B020                <1>          mov al, 0x20
   316 000001CD E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   317 000001CF B004                <1>          mov al, 0x04
   318 000001D1 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   319 000001D3 B001                <1>          mov al, 0x01
   320 000001D5 E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   321                              <1> 
   322 000001D7 B011                <1>          mov al, 0x11
   323 000001D9 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   324 000001DB B028                <1>          mov al, 0x28
   325 000001DD E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   326 000001DF B002                <1>          mov al, 0x02
   327 000001E1 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   328 000001E3 B001                <1>          mov al, 0x01
   329 000001E5 E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   330                              <1> 
   331 000001E7 58                  <1>          pop rax
   332 000001E8 C3                  <1>          ret
   333                              <1> 
   334                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   335                              <1> %ifdef __MP__
   336                              <1> _read_hdd_locker dq 0                 	;读硬盘锁
   337                              <1> %endif
   338                              <1> 
   339                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   340                              <1>                                         	;RAX=逻辑扇区号
   341                              <1>                                         	;RBX=目标缓冲区线性地址
   342                              <1>                                         	;返回：RBX=RBX+512
   343 000001E9 50                  <1>          push rax
   344 000001EA 51                  <1>          push rcx
   345 000001EB 52                  <1>          push rdx
   346                              <1> 
   347 000001EC 9C                  <1>          pushfq                     	;-->A
   348 000001ED FA                  <1>          cli
   349                              <1> %ifdef __MP__
   350                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   351                              <1> %endif
   352                              <1> 
   353 000001EE 50                  <1>          push rax
   354                              <1> 
   355 000001EF 66BAF201            <1>          mov dx, 0x1f2
   356 000001F3 B001                <1>          mov al, 1
   357 000001F5 EE                  <1>          out dx, al                	;读取的扇区数
   358                              <1> 
   359 000001F6 66FFC2              <1>          inc dx                    	;0x1f3
   360 000001F9 58                  <1>          pop rax
   361 000001FA EE                  <1>          out dx, al               	;LBA地址7~0
   362                              <1> 
   363 000001FB 66FFC2              <1>          inc dx                   	;0x1f4
   364 000001FE B108                <1>          mov cl, 8
   365 00000200 48D3E8              <1>          shr rax, cl
   366 00000203 EE                  <1>          out dx, al   	;LBA地址15~8
   367                              <1> 
   368 00000204 66FFC2              <1>          inc dx       	;0x1f5
   369 00000207 48D3E8              <1>          shr rax, cl
   370 0000020A EE                  <1>          out dx, al  	;LBA地址23~16
   371                              <1> 
   372 0000020B 66FFC2              <1>          inc dx       	;0x1f6
   373 0000020E 48D3E8              <1>          shr rax, cl
   374 00000211 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   375 00000213 EE                  <1>          out dx, al
   376                              <1> 
   377 00000214 66FFC2              <1>          inc dx       	;0x1f7
   378 00000217 B020                <1>          mov al, 0x20 	;读命令
   379 00000219 EE                  <1>          out dx, al
   380                              <1> 
   381                              <1>   .waits:
   382 0000021A EC                  <1>          in al, dx
   383                              <1>          ;and al, 0x88
   384                              <1>          ;cmp al, 0x08
   385 0000021B A808                <1>          test al, 8
   386 0000021D 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   387                              <1> 
   388 0000021F B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   389 00000224 66BAF001            <1>          mov dx, 0x1f0
   390                              <1>   .readw:
   391 00000228 66ED                <1>          in ax, dx
   392 0000022A 668903              <1>          mov [rbx], ax
   393 0000022D 4883C302            <1>          add rbx, 2
   394 00000231 E2F5                <1>          loop .readw
   395                              <1> 
   396                              <1> %ifdef __MP__
   397                              <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   398                              <1> %endif
   399 00000233 9D                  <1>          popfq                              			;A
   400                              <1> 
   401 00000234 5A                  <1>          pop rdx
   402 00000235 59                  <1>          pop rcx
   403 00000236 58                  <1>          pop rax
   404                              <1> 
   405 00000237 C3                  <1>          ret
   406                              <1> 
   407                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   408 00000238 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   409 00000278 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   410                              <1>   _page_map_len  equ $ - _page_bit_map
   411                              <1> 
   412                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   413                              <1>                                             			;输入：无
   414                              <1>                                             			;输出：RAX=页的物理地址
   415 00000638 4831C0              <1>          xor rax, rax
   416                              <1>   .b1:
   417 0000063B F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   418 00000644 730B                <1>          jnc .b2
   419 00000646 48FFC0              <1>          inc rax
   420 00000649 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   421 0000064F 7CEA                <1>          jl .b1
   422                              <1> 
   423                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   424                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   425                              <1>          ;面的换入和换出。
   426                              <1> 
   427                              <1>   .b2:
   428 00000651 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   429                              <1> 
   430 00000655 C3                  <1>          ret
   431                              <1> 
   432                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   433                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   434                              <1>                                      	;输入：R13=线性地址
   435                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   436 00000656 4155                <1>          push r13
   437                              <1> 
   438 00000658 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   438 00000661 00                  <1>
   439 00000662 4D21F5              <1>          and r13, r14
   440 00000665 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   441                              <1> 
   442 00000669 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   443 00000670 4D01EE              <1>          add r14, r13
   444                              <1> 
   445 00000673 415D                <1>          pop r13
   446                              <1> 
   447 00000675 C3                  <1>          ret
   448                              <1> 
   449                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   450                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   451                              <1>                                     	;输入：R13=线性地址
   452                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   453 00000676 4155                <1>          push r13
   454                              <1> 
   455 00000678 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   455 00000681 00                  <1>
   456 00000682 4D21F5              <1>          and r13, r14
   457 00000685 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   458                              <1> 
   459 00000689 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   460 00000690 4D01EE              <1>          add r14, r13
   461                              <1> 
   462 00000693 415D                <1>          pop r13
   463                              <1> 
   464 00000695 C3                  <1>          ret
   465                              <1> 
   466                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   467                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   468                              <1>                                      	;输入：R13=线性地址
   469                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   470 00000696 4155                <1>          push r13
   471                              <1> 
   472 00000698 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   472 000006A1 00                  <1>
   473                              <1> 	;索引部分
   474 000006A2 4D21F5              <1>          and r13, r14
   475 000006A5 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   476                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   477 000006A9 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   478 000006B0 4D01EE              <1>          add r14, r13
   479 000006B3 415D                <1>          pop r13
   480                              <1> 
   481 000006B5 C3                  <1>          ret
   482                              <1> 
   483                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   484                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   485                              <1>                                    	;输入：R13=线性地址
   486                              <1>                                    	;输出：R14=对应的页表项的线性地址
   487 000006B6 4155                <1>          push r13
   488                              <1> 
   489 000006B8 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   489 000006C1 00                  <1>
   490                              <1> 	                                ;索引部分
   491 000006C2 4D21F5              <1>          and r13, r14
   492 000006C5 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   493                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   494 000006C9 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   494 000006D2 FF                  <1>
   495 000006D3 4D01EE              <1>          add r14, r13
   496                              <1> 
   497 000006D6 415D                <1>          pop r13
   498 000006D8 C3                  <1>          ret
   499                              <1> 
   500                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   501                              <1> %ifdef __MP__
   502                              <1> _spaging_locker dq 0
   503                              <1> %endif
   504                              <1> 
   505                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   506                              <1>                                    	;输入：R13=线性地址
   507 000006D9 51                  <1>          push rcx
   508 000006DA 50                  <1>          push rax
   509 000006DB 4156                <1>          push r14
   510                              <1> 
   511 000006DD 9C                  <1>          pushfq                   	;-->A
   512 000006DE FA                  <1>          cli
   513                              <1> %ifdef __MP__
   514                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   515                              <1> %endif
   516                              <1> 
   517                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   518                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   519 000006DF E872FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   520 000006E4 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   521 000006EB 752B                <1>          jnz .b0
   522                              <1> 
   523                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   524 000006ED E846FFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   525 000006F2 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   526 000006F6 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   527                              <1> 
   528                              <1>          ;清空刚分配的页目录指针表
   529 000006F9 E878FFFFFF          <1>          call lin_to_lin_of_pdpte
   530 000006FE 49C1EE0C            <1>          shr r14, 12
   531 00000702 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   532 00000706 B900020000          <1>          mov rcx, 512
   533                              <1>   .cls0:
   534 0000070B 49C70600000000      <1>          mov qword [r14], 0
   535 00000712 4983C608            <1>          add r14, 8
   536 00000716 E2F3                <1>          loop .cls0
   537                              <1> ;-------------------------------------------------
   538                              <1>   .b0:
   539                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   540 00000718 E859FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   541 0000071D 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   542 00000724 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   543                              <1> 
   544                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   545 00000726 E80DFFFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   546 0000072B 4883C807            <1>          or rax, 0x07                  	;添加属性位
   547 0000072F 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   548                              <1> 
   549                              <1>          ;清空刚分配的页目录表
   550 00000732 E85FFFFFFF          <1>          call lin_to_lin_of_pdte
   551 00000737 49C1EE0C            <1>          shr r14, 12
   552 0000073B 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   553 0000073F B900020000          <1>          mov rcx, 512
   554                              <1>   .cls1:
   555 00000744 49C70600000000      <1>          mov qword [r14], 0
   556 0000074B 4983C608            <1>          add r14, 8
   557 0000074F E2F3                <1>          loop .cls1
   558                              <1> ;-------------------------------------------------
   559                              <1>   .b1:
   560                              <1>          ;检查该线性地址所对应的页目录项是否存在
   561 00000751 E840FFFFFF          <1>          call lin_to_lin_of_pdte
   562 00000756 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   563 0000075D 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   564                              <1> 
   565                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   566 0000075F E8D4FEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   567 00000764 4883C807            <1>          or rax, 0x07                      	;添加属性位
   568 00000768 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   569                              <1> 
   570                              <1>          ;清空刚分配的页表
   571 0000076B E846FFFFFF          <1>          call lin_to_lin_of_pte
   572 00000770 49C1EE0C            <1>          shr r14, 12
   573 00000774 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   574 00000778 B900020000          <1>          mov rcx, 512
   575                              <1>   .cls2:
   576 0000077D 49C70600000000      <1>          mov qword [r14], 0
   577 00000784 4983C608            <1>          add r14, 8
   578 00000788 E2F3                <1>          loop .cls2
   579                              <1> ;-------------------------------------------------
   580                              <1>   .b2:
   581                              <1>          ;检查该线性地址所对应的页表项是否存在
   582 0000078A E827FFFFFF          <1>          call lin_to_lin_of_pte
   583 0000078F 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   584 00000796 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   585                              <1> 
   586                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   587 00000798 E89BFEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   588 0000079D 4883C807            <1>          or rax, 0x07                     	;添加属性位
   589 000007A1 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   590                              <1> 
   591                              <1>   .b3:
   592                              <1> %ifdef __MP__
   593                              <1>          mov qword [rel _spaging_locker], 0
   594                              <1> %endif
   595 000007A4 9D                  <1>          popfq                      	;A
   596                              <1> 
   597 000007A5 415E                <1>          pop r14
   598 000007A7 58                  <1>          pop rax
   599 000007A8 59                  <1>          pop rcx
   600                              <1> 
   601 000007A9 C3                  <1>          ret
   602                              <1> 
   603                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   604                              <1> %ifdef __MP__
   605                              <1> _mapping_locker dq 0
   606                              <1> %endif
   607                              <1> 
   608                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   609                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   610                              <1>                                    	;输入：R13=线性地址
   611                              <1>                                                    ;RAX=页的物理地址（含属性）
   612 000007AA 51                  <1>          push rcx
   613 000007AB 4156                <1>          push r14
   614                              <1> 
   615 000007AD 9C                  <1>          pushfq
   616 000007AE FA                  <1>          cli
   617                              <1> %ifdef __MP__
   618                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   619                              <1> %endif
   620                              <1> 
   621 000007AF 50                  <1>          push rax
   622                              <1> 
   623                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   624                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   625 000007B0 E8A1FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   626 000007B5 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   627 000007BC 752B                <1>          jnz .b0
   628                              <1> 
   629                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   630 000007BE E875FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   631 000007C3 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   632 000007C7 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   633                              <1> 
   634                              <1>          ;清空刚分配的页目录指针表
   635 000007CA E8A7FEFFFF          <1>          call lin_to_lin_of_pdpte
   636 000007CF 49C1EE0C            <1>          shr r14, 12
   637 000007D3 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   638 000007D7 B900020000          <1>          mov rcx, 512
   639                              <1>   .cls0:
   640 000007DC 49C70600000000      <1>          mov qword [r14], 0
   641 000007E3 4983C608            <1>          add r14, 8
   642 000007E7 E2F3                <1>          loop .cls0
   643                              <1> ;-------------------------------------------------
   644                              <1>   .b0:
   645                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   646 000007E9 E888FEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   647 000007EE 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   648 000007F5 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   649                              <1> 
   650                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   651 000007F7 E83CFEFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   652 000007FC 4883C807            <1>          or rax, 0x07              	;添加属性位
   653 00000800 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   654                              <1> 
   655                              <1>          ;清空刚分配的页目录表
   656 00000803 E88EFEFFFF          <1>          call lin_to_lin_of_pdte
   657 00000808 49C1EE0C            <1>          shr r14, 12
   658 0000080C 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   659 00000810 B900020000          <1>          mov rcx, 512
   660                              <1>   .cls1:
   661 00000815 49C70600000000      <1>          mov qword [r14], 0
   662 0000081C 4983C608            <1>          add r14, 8
   663 00000820 E2F3                <1>          loop .cls1
   664                              <1> ;-------------------------------------------------
   665                              <1>   .b1:
   666                              <1>          ;检查该线性地址所对应的页目录项是否存在
   667 00000822 E86FFEFFFF          <1>          call lin_to_lin_of_pdte
   668 00000827 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   669 0000082E 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   670                              <1> 
   671                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   672 00000830 E803FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   673 00000835 4883C807            <1>          or rax, 0x07                  	;添加属性位
   674 00000839 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   675                              <1> 
   676                              <1>          ;清空刚分配的页表
   677 0000083C E875FEFFFF          <1>          call lin_to_lin_of_pte
   678 00000841 49C1EE0C            <1>          shr r14, 12
   679 00000845 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   680 00000849 B900020000          <1>          mov rcx, 512
   681                              <1>   .cls2:
   682 0000084E 49C70600000000      <1>          mov qword [r14], 0
   683 00000855 4983C608            <1>          add r14, 8
   684 00000859 E2F3                <1>          loop .cls2
   685                              <1> ;-------------------------------------------------
   686                              <1>   .b2:
   687 0000085B E856FEFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   688 00000860 58                  <1>          pop rax
   689 00000861 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   690                              <1> 
   691                              <1> %ifdef __MP__
   692                              <1>          mov qword [rel _mapping_locker], 0
   693                              <1> %endif
   694 00000864 9D                  <1>          popfq
   695                              <1> 
   696 00000865 415E                <1>          pop r14
   697 00000867 59                  <1>          pop rcx
   698                              <1> 
   699 00000868 C3                  <1>          ret
   700                              <1> 
   701                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   702 00000869 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   703                              <1> 
   704                              <1> %ifdef __MP__
   705                              <1>   _core_alloc_locker dq 0
   706                              <1> %endif
   707                              <1> 
   708                              <1> core_memory_allocate:                 	;在虚拟地址空间的高端（内核）分配内存
   709                              <1>                                         	;输入：RCX=请求分配的字节数
   710                              <1>                                         	;输出：R13=本次分配的起始线性地址
   711                              <1>                                         	;      R14=下次分配的起始线性地址
   712 00000871 9C                  <1>          pushfq                        	;A-->
   713 00000872 FA                  <1>          cli
   714                              <1> %ifdef __MP__
   715                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   716                              <1> %endif
   717                              <1> 
   718 00000873 4C8B2DEFFFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   719 0000087A 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   720                              <1> 
   721 0000087F 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   722 00000886 740C                <1>          jz .algn
   723 00000888 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   724 0000088C 49C1EE03            <1>          shr r14, 3
   725 00000890 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   726                              <1> 
   727                              <1>   .algn:
   728 00000894 4C8935CEFFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   729                              <1> 
   730                              <1> %ifdef __MP__
   731                              <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   732                              <1> %endif
   733 0000089B 9D                  <1>          popfq                             	;A
   734                              <1> 
   735 0000089C 4155                <1>          push r13
   736 0000089E 4156                <1>          push r14
   737                              <1> 
   738                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   739 000008A0 49C1ED0C            <1>          shr r13, 12
   740 000008A4 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   741 000008A8 49C1EE0C            <1>          shr r14, 12
   742 000008AC 49C1E60C            <1>          shl r14, 12                    	;too
   743                              <1>   .next:
   744 000008B0 E824FEFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   745 000008B5 4981C500100000      <1>          add r13, 0x1000               	;+4096
   746 000008BC 4D39F5              <1>          cmp r13, r14
   747 000008BF 7EEF                <1>          jle .next
   748                              <1> 
   749 000008C1 415E                <1>          pop r14
   750 000008C3 415D                <1>          pop r13
   751                              <1> 
   752 000008C5 C3                  <1>          ret
   753                              <1> 
   754                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   755                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   756                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   757                              <1>                                    	;      RCX=希望分配的字节数
   758                              <1>                                    	;输出：R13=本次分配的起始线性地址
   759                              <1>                                    	;      R14=下次分配的起始线性地址
   760                              <1>          ;获得本次内存分配的起始线性地址
   761 000008C6 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   762 000008CA 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   763                              <1> 
   764 000008CF 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   765 000008D6 740C                <1>          jz .algn
   766 000008D8 49C1EE03            <1>          shr r14, 3
   767 000008DC 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   768 000008E0 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   769                              <1> 
   770                              <1>   .algn:
   771 000008E4 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   772                              <1> 
   773 000008E8 4155                <1>          push r13
   774 000008EA 4156                <1>          push r14
   775                              <1> 
   776                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   777 000008EC 49C1ED0C            <1>          shr r13, 12
   778 000008F0 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   779 000008F4 49C1EE0C            <1>          shr r14, 12
   780 000008F8 49C1E60C            <1>          shl r14, 12                 	;too
   781                              <1>   .next:
   782 000008FC E8D8FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   783 00000901 4981C500100000      <1>          add r13, 0x1000                ;+4096
   784 00000908 4D39F5              <1>          cmp r13, r14
   785 0000090B 7EEF                <1>          jle .next
   786                              <1> 
   787 0000090D 415E                <1>          pop r14
   788 0000090F 415D                <1>          pop r13
   789                              <1> 
   790 00000911 C3                  <1>          ret
   791                              <1> 
   792                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   793                              <1> %ifdef __MP__
   794                              <1> _copy_locker dq 0
   795                              <1> %endif
   796                              <1> 
   797                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   798                              <1>                                         	;输入：无
   799                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   800 00000912 56                  <1>          push rsi
   801 00000913 57                  <1>          push rdi
   802 00000914 4155                <1>          push r13
   803 00000916 51                  <1>          push rcx
   804                              <1> 
   805 00000917 9C                  <1>          pushfq                                   	;-->A
   806 00000918 FA                  <1>          cli
   807                              <1> %ifdef __MP__
   808                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   809                              <1> %endif
   810                              <1> 
   811 00000919 E81AFDFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   812 0000091E 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   813 00000922 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   813 0000092B FF                  <1>
   814 0000092C E879FEFFFF          <1>          call mapping_laddr_to_page
   815                              <1> 
   816                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   817 00000931 410F017D00          <1>          invlpg [r13]
   818                              <1> 
   819 00000936 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   820 0000093D 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   821 00000940 B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   822 00000945 FC                  <1>          cld
   823 00000946 F348A5              <1>          repe movsq
   824                              <1> 
   825 00000949 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   826 00000950 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   827                              <1> 
   828                              <1> %ifdef __MP__
   829                              <1>          mov qword [rel _copy_locker], 0
   830                              <1> %endif
   831 00000958 9D                  <1>          popfq                    	;A
   832                              <1> 
   833 00000959 59                  <1>          pop rcx
   834 0000095A 415D                <1>          pop r13
   835 0000095C 5F                  <1>          pop rdi
   836 0000095D 5E                  <1>          pop rsi
   837                              <1> 
   838 0000095E C3                  <1>          ret
   839                              <1> 
   840                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   841                              <1> %ifdef __MP__
   842                              <1> _cmos_locker dq 0
   843                              <1> %endif
   844                              <1> 
   845                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   846                              <1>                                        	;输入：RBX=缓冲区线性地址
   847 0000095F 50                  <1>          push rax
   848                              <1> 
   849 00000960 9C                  <1>          pushfq                       	;-->A
   850 00000961 FA                  <1>          cli
   851                              <1> %ifdef __MP__
   852                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   853                              <1> %endif
   854                              <1> 
   855                              <1>   .w0:
   856 00000962 B08A                <1>          mov al, 0x8a
   857 00000964 E670                <1>          out 0x70, al
   858 00000966 E471                <1>          in al, 0x71                 	;读寄存器A
   859 00000968 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   860 0000096A 75F6                <1>          jnz .w0
   861                              <1> 
   862 0000096C B084                <1>          mov al, 0x84
   863 0000096E E670                <1>          out 0x70, al
   864 00000970 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   865 00000972 88C4                <1>          mov ah, al
   866                              <1> 
   867 00000974 C0EC04              <1>          shr ah, 4
   868 00000977 80E40F              <1>          and ah, 0x0f
   869 0000097A 80C430              <1>          add ah, 0x30
   870 0000097D 8823                <1>          mov [rbx], ah
   871                              <1> 
   872 0000097F 240F                <1>          and al, 0x0f
   873 00000981 0430                <1>          add al, 0x30
   874 00000983 884301              <1>          mov [rbx + 1], al
   875                              <1> 
   876 00000986 C643023A            <1>          mov byte [rbx + 2], ':'
   877                              <1> 
   878 0000098A B082                <1>          mov al, 0x82
   879 0000098C E670                <1>          out 0x70, al
   880 0000098E E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   881 00000990 88C4                <1>          mov ah, al
   882                              <1> 
   883 00000992 C0EC04              <1>          shr ah, 4
   884 00000995 80E40F              <1>          and ah, 0x0f
   885 00000998 80C430              <1>          add ah, 0x30
   886 0000099B 886303              <1>          mov [rbx + 3], ah
   887                              <1> 
   888 0000099E 240F                <1>          and al, 0x0f
   889 000009A0 0430                <1>          add al, 0x30
   890 000009A2 884304              <1>          mov [rbx + 4], al
   891                              <1> 
   892 000009A5 C643053A            <1>          mov byte [rbx + 5], ':'
   893                              <1> 
   894 000009A9 B080                <1>          mov al, 0x80
   895 000009AB E670                <1>          out 0x70, al
   896 000009AD E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   897 000009AF 88C4                <1>          mov ah, al              	;分拆成两个数字
   898                              <1> 
   899 000009B1 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   900 000009B4 80E40F              <1>          and ah, 0x0f
   901 000009B7 80C430              <1>          add ah, 0x30
   902 000009BA 886306              <1>          mov [rbx + 6], ah
   903                              <1> 
   904 000009BD 240F                <1>          and al, 0x0f               	;仅保留低4位
   905 000009BF 0430                <1>          add al, 0x30               	;转换成ASCII
   906 000009C1 884307              <1>          mov [rbx + 7], al
   907                              <1> 
   908 000009C4 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   909                              <1> 
   910                              <1> %ifdef __MP__
   911                              <1>          mov qword [rel _cmos_locker], 0
   912                              <1> %endif
   913 000009C8 9D                  <1>          popfq                	;A
   914                              <1> 
   915 000009C9 58                  <1>          pop rax
   916                              <1> 
   917 000009CA C3                  <1>          ret
   918                              <1> 
   919                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   920 000009CB 0000000000000000    <1>   _process_id        dq 0
   921                              <1> 
   922                              <1> generate_process_id:                  	;生成唯一的进程标识
   923                              <1>                                         	;返回：RAX=进程标识
   924 000009D3 B801000000          <1>          mov rax, 1
   925 000009D8 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   926                              <1> 
   927 000009E1 C3                  <1>          ret
   928                              <1> 
   929                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   930 000009E2 0000000000000000    <1>   _thread_id dq 0
   931                              <1> 
   932                              <1> generate_thread_id:                 	;生成唯一的线程标识
   933                              <1>                                       	;返回：RAX=线程标识
   934 000009EA B801000000          <1>          mov rax, 1
   935 000009EF F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   936                              <1> 
   937 000009F8 C3                  <1>          ret
   938                              <1> 
   939                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   940 000009F9 08                  <1>   _screen_row        db 8
   941                              <1> 
   942                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   943                              <1>                                      	;返回：DH=行号
   944 000009FA B601                <1>          mov dh, 1
   945 000009FC F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   946                              <1> 
   947 00000A04 C3                  <1>          ret
   948                              <1> 
   949                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   950                              <1> get_cpu_number:                        	;返回当前处理器的编号
   951                              <1>                                         	;返回：RAX=处理器编号
   952 00000A05 9C                  <1>          pushfq
   953 00000A06 FA                  <1>          cli
   954 00000A07 0F01F8              <1>          swapgs
   955 00000A0A 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   956 00000A13 0F01F8              <1>          swapgs
   957 00000A16 9D                  <1>          popfq
   958 00000A17 C3                  <1>          ret
   959                              <1> 
   960                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   961                              <1> memory_allocate:                       	;用户空间的内存分配
   962                              <1>                                          	;进入：RDX=期望分配的字节数
   963                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   964 00000A18 51                  <1>          push rcx
   965 00000A19 4153                <1>          push r11
   966 00000A1B 4156                <1>          push r14
   967                              <1> 
   968 00000A1D 9C                  <1>          pushfq
   969 00000A1E FA                  <1>          cli
   970 00000A1F 0F01F8              <1>          swapgs
   971 00000A22 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
   972 00000A2B 0F01F8              <1>          swapgs
   973 00000A2E 9D                  <1>          popfq
   974                              <1> 
   975 00000A2F 4889D1              <1>          mov rcx, rdx
   976 00000A32 E88FFEFFFF          <1>          call user_memory_allocate
   977                              <1> 
   978 00000A37 415E                <1>          pop r14
   979 00000A39 415B                <1>          pop r11
   980 00000A3B 59                  <1>          pop rcx
   981                              <1> 
   982 00000A3C C3                  <1>          ret
   983                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    28                                  
    29                                           bits 64
    30                                  
    31                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    32                                  general_interrupt_handler:                        ;通用中断处理过程
    33 00000A3D 48CF                             iretq
    34                                  
    35                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    36                                  general_exception_handler:                        ;通用异常处理过程
    37                                                                                    ;在24行0列显示红底白字的错误信息
    38 00000A3F 4C8B3D(08000000)                 mov r15, [rel position]
    39 00000A46 498D9F[5B0A0000]                 lea rbx, [r15 + exceptm]
    40 00000A4D B618                             mov dh, 24
    41 00000A4F B200                             mov dl, 0
    42 00000A51 41B14F                           mov r9b, 0x4f
    43 00000A54 E885F6FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
    44                                  
    45 00000A59 FA                               cli
    46 00000A5A F4                               hlt                                      ;停机且不接受外部硬件中断
    47                                  
    48 00000A5B 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
    48 00000A64 6F6E20726169736564-
    48 00000A6D 2C68616C742E00     
    49                                  
    50                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    51                                  general_8259ints_handler:                         ;通用的8259中断处理过程
    52 00000A74 50                               push rax
    53                                  
    54 00000A75 B020                             mov al, 0x20                             ;中断结束命令EOI
    55 00000A77 E6A0                             out 0xa0, al                             ;向从片发送
    56 00000A79 E620                             out 0x20, al                             ;向主片发送
    57                                  
    58 00000A7B 58                               pop rax
    59                                  
    60 00000A7C 48CF                             iretq
    61                                  
    62                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    63                                  rtm_interrupt_handle:                             ;实时时钟中断处理过程（任务切换）
    64 00000A7E 4150                             push r8
    65 00000A80 50                               push rax
    66 00000A81 53                               push rbx
    67                                  
    68 00000A82 B020                             mov al, 0x20                             ;中断结束命令EOI
    69 00000A84 E6A0                             out 0xa0, al                             ;向8259A从片发送
    70 00000A86 E620                             out 0x20, al                             ;向8259A主片发送
    71                                  
    72 00000A88 B00C                             mov al, 0x0c                             ;寄存器C的索引。且开放NMI
    73 00000A8A E670                             out 0x70, al
    74 00000A8C E471                             in al, 0x71                              ;读一下RTC的寄存器C，否则只发生一次中断
    75                                                                                    ;此处不考虑闹钟和周期性中断的情况
    76                                           ;以下开始执行任务切换
    77                                           ;任务切换的原理是，它发生在所有任务的全局空间。在任务A的全局空间执行任务切换，切换
    78                                           ;到任务B，实际上也是从任务B的全局空间返回任务B的私有空间。
    79                                  
    80                                           ;从PCB链表中寻找就绪的任务。
    81 00000A8E 4C8B05(5C000000)                 mov r8, [rel cur_pcb]                    ;定位到当前任务的PCB节点
    82                                    .again:
    83 00000A95 4D8B8018010000                   mov r8, [r8 + 280]                       ;取得下一个节点
    84 00000A9C 4C3B05(5C000000)                 cmp r8, [rel cur_pcb]                    ;是否转一圈回到当前节点？
    85 00000AA3 0F842F010000                     jz .return                               ;是。未找到就绪任务（节点），返回
    86 00000AA9 4983781000                       cmp qword [r8 + 16], 0                   ;是就绪任务（节点）？
    87 00000AAE 7402                             jz .found                                ;是。转任务切换
    88 00000AB0 EBE3                             jmp .again
    89                                  
    90                                    .found:
    91 00000AB2 488B05(5C000000)                 mov rax, [rel cur_pcb]                   ;取得当前任务的PCB（线性地址）
    92 00000AB9 4883781002                       cmp qword [rax + 16], 2                  ;当前任务有可能已经被标记为终止。
    93 00000ABE 7479                             jz .restore
    94                                  
    95                                           ;保存当前任务的状态以便将来恢复执行
    96 00000AC0 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
    97                                           ;mov [rax + 64], rax                     ;不需设置，将来恢复执行时从栈中弹出
    98                                           ;mov [rax + 72], rbx                     ;不需设置，将来恢复执行时从栈中弹出
    99 00000AC8 48894850                         mov [rax + 80], rcx
   100 00000ACC 48895058                         mov [rax + 88], rdx
   101 00000AD0 48897060                         mov [rax + 96], rsi
   102 00000AD4 48897868                         mov [rax + 104], rdi
   103 00000AD8 48896870                         mov [rax + 112], rbp
   104 00000ADC 48896078                         mov [rax + 120], rsp
   105                                           ;mov [rax + 128], r8                     ;不需设置，将来恢复执行时从栈中弹出
   106 00000AE0 4C898888000000                   mov [rax + 136], r9
   107 00000AE7 4C899090000000                   mov [rax + 144], r10
   108 00000AEE 4C899898000000                   mov [rax + 152], r11
   109 00000AF5 4C89A0A0000000                   mov [rax + 160], r12
   110 00000AFC 4C89A8A8000000                   mov [rax + 168], r13
   111 00000B03 4C89B0B0000000                   mov [rax + 176], r14
   112 00000B0A 4C89B8B8000000                   mov [rax + 184], r15
   113 00000B11 488B1D(08000000)                 mov rbx, [rel position]
   114 00000B18 488D9B[D80B0000]                 lea rbx, [rbx + .return]
   115 00000B1F 488998C0000000                   mov [rax + 192], rbx                     ;RIP为中断返回点
   116 00000B26 8C88C8000000                     mov [rax + 200], cs
   117 00000B2C 8C90D0000000                     mov [rax + 208], ss
   118 00000B32 9C                               pushfq
   119 00000B33 8F80E8000000                     pop qword [rax + 232]
   120                                  
   121                                    .restore:
   122                                           ;恢复新任务的状态
   123 00000B39 4C8905(5C000000)                 mov [rel cur_pcb], r8                    ;将新任务设置为当前任务
   124 00000B40 49C7401001000000                 mov qword [r8 + 16], 1                   ;置任务状态为忙
   125                                  
   126 00000B48 498B4020                         mov rax, [r8 + 32]                       ;取PCB中的RSP0
   127 00000B4C 488B1D(1C000000)                 mov rbx, [rel tss_ptr]
   128 00000B53 48894304                         mov [rbx + 4], rax                       ;置TSS的RSP0
   129                                  
   130 00000B57 498B4038                         mov rax, [r8 + 56]
   131 00000B5B 0F22D8                           mov cr3, rax                             ;切换地址空间
   132                                  
   133 00000B5E 498B4040                         mov rax, [r8 + 64]
   134 00000B62 498B5848                         mov rbx, [r8 + 72]
   135 00000B66 498B4850                         mov rcx, [r8 + 80]
   136 00000B6A 498B5058                         mov rdx, [r8 + 88]
   137 00000B6E 498B7060                         mov rsi, [r8 + 96]
   138 00000B72 498B7868                         mov rdi, [r8 + 104]
   139 00000B76 498B6870                         mov rbp, [r8 + 112]
   140 00000B7A 498B6078                         mov rsp, [r8 + 120]
   141 00000B7E 4D8B8888000000                   mov r9, [r8 + 136]
   142 00000B85 4D8B9090000000                   mov r10, [r8 + 144]
   143 00000B8C 4D8B9898000000                   mov r11, [r8 + 152]
   144 00000B93 4D8BA0A0000000                   mov r12, [r8 + 160]
   145 00000B9A 4D8BA8A8000000                   mov r13, [r8 + 168]
   146 00000BA1 4D8BB0B0000000                   mov r14, [r8 + 176]
   147 00000BA8 4D8BB8B8000000                   mov r15, [r8 + 184]
   148 00000BAF 41FFB0D0000000                   push qword [r8 + 208]                    ;SS
   149 00000BB6 41FF7078                         push qword [r8 + 120]                    ;RSP
   150 00000BBA 41FFB0E8000000                   push qword [r8 + 232]                    ;RFLAGS
   151 00000BC1 41FFB0C8000000                   push qword [r8 + 200]                    ;CS
   152 00000BC8 41FFB0C0000000                   push qword [r8 + 192]                    ;RIP
   153                                  
   154 00000BCF 4D8B8080000000                   mov r8, [r8 + 128]                       ;恢复R8的值
   155                                  
   156 00000BD6 48CF                             iretq                                    ;转入新任务局部空间执行
   157                                  
   158                                    .return:
   159 00000BD8 5B                               pop rbx
   160 00000BD9 58                               pop rax
   161 00000BDA 4158                             pop r8
   162                                  
   163 00000BDC 48CF                             iretq
   164                                  
   165                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   166                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   167                                                                                    ;输入：R11=PCB线性基地址
   168 00000BDE 50                               push rax
   169 00000BDF 53                               push rbx
   170                                  
   171 00000BE0 FA                               cli
   172                                  
   173 00000BE1 488B1D(54000000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   174 00000BE8 4809DB                           or rbx, rbx
   175 00000BEB 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   176 00000BED 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   177 00000BF0 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   178 00000BF7 4C891D(54000000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   179 00000BFE EB17                             jmp .return
   180                                  
   181                                    .not_empty:
   182 00000C00 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   183                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   184 00000C03 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   185 00000C0A 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   186 00000C11 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   187 00000C14 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   188                                  
   189                                    .return:
   190 00000C17 FB                               sti
   191                                  
   192 00000C18 5B                               pop rbx
   193 00000C19 58                               pop rax
   194                                  
   195 00000C1A C3                               ret
   196                                  
   197                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   198                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   199 00000C1B 488B05(5C000000)                 mov rax, [rel cur_pcb]
   200 00000C22 488B4008                         mov rax, [rax + 8]
   201                                  
   202 00000C26 C3                               ret
   203                                  
   204                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   205                                  terminate_process:                                ;终止当前任务
   206 00000C27 FA                               cli                                      ;执行流改变期间禁止时钟中断引发的任务切换
   207                                  
   208 00000C28 488B05(5C000000)                 mov rax, [rel cur_pcb]                   ;定位到当前任务的PCB节点
   209 00000C2F 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   210                                  
   211 00000C37 E942FEFFFF                       jmp rtm_interrupt_handle                 ;强制任务调度，交还处理器控制权
   212                                  
   213                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   214                                  create_process:                                   ;创建新的任务
   215                                                                                    ;输入：R8=程序的起始逻辑扇区号
   216 00000C3C 50                               push rax
   217 00000C3D 53                               push rbx
   218 00000C3E 51                               push rcx
   219 00000C3F 52                               push rdx
   220 00000C40 56                               push rsi
   221 00000C41 57                               push rdi
   222 00000C42 55                               push rbp
   223 00000C43 4150                             push r8
   224 00000C45 4151                             push r9
   225 00000C47 4152                             push r10
   226 00000C49 4153                             push r11
   227 00000C4B 4154                             push r12
   228 00000C4D 4155                             push r13
   229 00000C4F 4156                             push r14
   230 00000C51 4157                             push r15
   231                                  
   232                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   233 00000C53 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   234 00000C58 E814FCFFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   235                                  
   236 00000C5D 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   237                                  
   238 00000C60 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   239                                  
   240                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   241 00000C68 E8A5FCFFFF                       call copy_current_pml4
   242 00000C6D 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   243                                  
   244                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系， 我们正
   245                                           ;在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有任务的高端（全
   246                                           ;局）部分都相同。同时，当前使用的栈位于地址空间高端的栈。
   247 00000C71 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   248 00000C75 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   249                                  
   250                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   251 00000C78 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   252 00000C7F B900010000                       mov rcx, 256
   253                                    .clsp:
   254 00000C84 48C70000000000                   mov qword [rax], 0
   255 00000C8B 4883C008                         add rax, 8
   256 00000C8F E2F3                             loop .clsp
   257                                  
   258 00000C91 0F20D8                           mov rax, cr3                             ;刷新TLB
   259 00000C94 0F22D8                           mov cr3, rax
   260                                  
   261 00000C97 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   262 00000C9C E8D0FBFFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   263 00000CA1 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   264                                  
   265 00000CA5 B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   266 00000CAA E817FCFFFF                       call user_memory_allocate
   267 00000CAF 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   268                                  
   269 00000CB3 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   270                                  
   271                                           ;以下开始加载用户程序
   272 00000CBB B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   273 00000CC0 E801FCFFFF                       call user_memory_allocate
   274 00000CC5 4C89EB                           mov rbx, r13
   275 00000CC8 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   276 00000CCB E819F5FFFF                       call read_hard_disk_0
   277                                  
   278 00000CD0 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   279 00000CD4 4D89EE                           mov r14, r13
   280 00000CD7 4D037508                         add r14, [r13 + 8]
   281 00000CDB 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   282                                  
   283                                           ;以下判断整个程序有多大
   284 00000CE2 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   285 00000CE6 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   286 00000CED 740F                             jz .y512
   287 00000CEF 48C1E909                         shr rcx, 9                               ;不能？凑整。
   288 00000CF3 48C1E109                         shl rcx, 9
   289 00000CF7 4881C100020000                   add rcx, 512
   290                                    .y512:
   291 00000CFE 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   292 00000D05 7416                             jz .rdok
   293 00000D07 E8BAFBFFFF                       call user_memory_allocate
   294                                           ;mov rbx, r13
   295 00000D0C 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   296 00000D10 48FFC0                           inc rax                                  ;起始扇区号
   297                                    .b1:
   298 00000D13 E8D1F4FFFF                       call read_hard_disk_0
   299 00000D18 48FFC0                           inc rax
   300 00000D1B E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   301                                  
   302                                    .rdok:
   303 00000D1D 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   303 00000D26 0000               
   304 00000D28 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   304 00000D31 0000               
   305                                  
   306 00000D33 9C                               pushfq
   307 00000D34 418F83E8000000                   pop qword [r11 + 232]
   308                                  
   309 00000D3B E893FCFFFF                       call generate_process_id
   310 00000D40 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   311                                  
   312 00000D44 E895FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   313                                  
   314 00000D49 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   315                                  
   316 00000D4D 415F                             pop r15
   317 00000D4F 415E                             pop r14
   318 00000D51 415D                             pop r13
   319 00000D53 415C                             pop r12
   320 00000D55 415B                             pop r11
   321 00000D57 415A                             pop r10
   322 00000D59 4159                             pop r9
   323 00000D5B 4158                             pop r8
   324 00000D5D 5D                               pop rbp
   325 00000D5E 5F                               pop rdi
   326 00000D5F 5E                               pop rsi
   327 00000D60 5A                               pop rdx
   328 00000D61 59                               pop rcx
   329 00000D62 5B                               pop rbx
   330 00000D63 58                               pop rax
   331                                  
   332 00000D64 C3                               ret
   333                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   334                                  syscall_procedure:                                ;系统调用的处理过程
   335                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；RBP和R15由此例程占用。如
   336                                           ;有必要，请用户程序在调用syscall前保存它们，在系统调用返回后自行恢复。
   337 00000D65 4889E5                           mov rbp, rsp
   338 00000D68 4C8B3D(1C000000)                 mov r15, [rel tss_ptr]
   339 00000D6F 498B6704                         mov rsp, [r15 + 4]                       ;使用TSS的RSP0作为安全栈
   340                                  
   341 00000D73 FB                               sti
   342                                  
   343 00000D74 4C8B3D(08000000)                 mov r15, [rel position]
   344 00000D7B 4D03BCC7[24000000]               add r15, [r15 + rax * 8 + sys_entry]
   345 00000D83 41FFD7                           call r15
   346                                  
   347 00000D86 FA                               cli
   348 00000D87 4889EC                           mov rsp, rbp                             ;还原到用户程序的栈
   349 00000D8A 480F07                           o64 sysret
   350                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   351                                  init:    ;初始化内核的工作环境
   352                                  
   353                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   354                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   355 00000D8D 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   355 00000D96 FF                 
   356 00000D97 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   357                                  
   358 00000D9F 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   359                                  
   360                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   361                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   362 00000DA7 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   362 00000DB0 FF                 
   363 00000DB1 4801C4                           add rsp,rax                              ;栈指针必须转换为高端地址且必须是扩高地址
   364                                  
   365                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   366 00000DB4 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   366 00000DBD FF                 
   367 00000DBE 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   368                                  
   369                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   370 00000DC5 488B05(08000000)                 mov rax, [rel position]
   371 00000DCC 4805[D40D0000]                   add rax, .to_upper
   372 00000DD2 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   373                                  
   374                                    .to_upper:
   375                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   376                                  
   377                                           ;为32个异常创建通用处理过程的中断门
   378 00000DD4 4C8B0D(08000000)                 mov r9, [rel position]
   379 00000DDB 498D81[3F0A0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   380 00000DE2 E85EF3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   381                                  
   382 00000DE7 4D31C0                           xor r8, r8
   383                                    .idt0:
   384 00000DEA E8B7F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   385 00000DEF 49FFC0                           inc r8
   386 00000DF2 4983F81F                         cmp r8, 31
   387 00000DF6 7EF2                             jle .idt0
   388                                  
   389                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   390 00000DF8 498D81[3D0A0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   391 00000DFF E841F3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   392                                  
   393 00000E04 41B820000000                     mov r8, 32
   394                                    .idt1:
   395 00000E0A E897F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   396 00000E0F 49FFC0                           inc r8
   397 00000E12 4981F8FF000000                   cmp r8, 255
   398 00000E19 7EEF                             jle .idt1
   399                                  
   400 00000E1B 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   400 00000E24 FF                 
   401 00000E25 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   401 00000E2E FF                 
   402 00000E2F 4889430E                         mov qword [rbx + 0x0e], rax
   403 00000E33 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   404                                  
   405 00000E39 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   406                                  
   407                                           ;初始化8259中断控制器，包括重新设置中断向量号
   408 00000E3D E884F3FFFF                       call init_8259
   409                                  
   410                                           ;创建并安装16个8259中断处理过程的中断门，向量0x20--0x2f
   411 00000E42 498D81[740A0000]                 lea rax, [r9 + general_8259ints_handler] ;得到通用8259中断处理过程的线性地址
   412 00000E49 E8F7F2FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   413                                  
   414 00000E4E 41B820000000                     mov r8, 0x20
   415                                    .8259:
   416 00000E54 E84DF3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   417 00000E59 49FFC0                           inc r8
   418 00000E5C 4983F82F                         cmp r8, 0x2f
   419 00000E60 7EF2                             jle .8259
   420                                  
   421 00000E62 FB                               sti                                      ;开放硬件中断
   422                                  
   423                                           ;在64位模式下显示的第一条信息!
   424 00000E63 4C8B3D(08000000)                 mov r15, [rel position]
   425 00000E6A 498D9F[00000000]                 lea rbx, [r15 + welcome]
   426 00000E71 E88AF1FFFF                       call put_string64                        ;位于core_utils64.wid
   427                                           ;----------------------------------------------------------------------
   428                                           ;安装系统服务所需要的代码段和栈段描述符
   429 00000E76 4883EC10                         sub rsp, 16                              ;开辟16字节的空间操作GDT和GDTR
   430 00000E7A 0F010424                         sgdt [rsp]
   431 00000E7E 4831DB                           xor rbx, rbx
   432 00000E81 668B1C24                         mov bx, [rsp]                            ;得到GDT的界限值
   433 00000E85 66FFC3                           inc bx                                   ;得到GDT的长度（字节数）
   434 00000E88 48035C2402                       add rbx, [rsp + 2]
   435                                           ;以下，处理器不支持从64位立即数到内存之间的传送!!!
   436 00000E8D C703FFFF0000                     mov dword [rbx], 0x0000ffff
   437 00000E93 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   438 00000E9A C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   439 00000EA1 C7430C00000000                   mov dword [rbx + 12], 0
   440 00000EA8 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   441 00000EAF C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   442 00000EB6 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   443 00000EBD C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   444                                  
   445                                           ;安装任务状态段TSS的描述符
   446 00000EC4 B968000000                       mov rcx, 104                             ;TSS的标准长度
   447 00000EC9 E8A3F9FFFF                       call core_memory_allocate
   448 00000ECE 4C892D(1C000000)                 mov [rel tss_ptr], r13
   449 00000ED5 4C89E8                           mov rax, r13
   450 00000ED8 E8A0F2FFFF                       call make_tss_descriptor
   451 00000EDD 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   452 00000EE1 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   453                                  
   454 00000EE5 6683042430                       add word [rsp], 48                       ;4个段描述符和1个TSS描述符的总字节数
   455 00000EEA 0F011424                         lgdt [rsp]
   456 00000EEE 4883C410                         add rsp, 16                              ;恢复栈平衡
   457                                  
   458 00000EF2 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   459 00000EF6 0F00D9                           ltr cx
   460                                  
   461                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   462 00000EF9 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   463 00000EFE 0F32                             rdmsr
   464 00000F00 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   465 00000F04 0F30                             wrmsr
   466                                  
   467 00000F06 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   468 00000F0B BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   469 00000F10 31C0                             xor eax, eax
   470 00000F12 0F30                             wrmsr
   471                                  
   472 00000F14 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   473 00000F19 488B05(08000000)                 mov rax, [rel position]
   474 00000F20 488D80[650D0000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   475 00000F27 4889C2                           mov rdx, rax
   476 00000F2A 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   477 00000F2E 0F30                             wrmsr
   478                                  
   479 00000F30 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   480 00000F35 31D2                             xor edx, edx
   481 00000F37 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   482 00000F3C 0F30                             wrmsr
   483                                  
   484                                           ;以下安装用于任务切换的实时时钟中断处理过程
   485 00000F3E 4C8B0D(08000000)                 mov r9, [rel position]
   486 00000F45 498D81[7E0A0000]                 lea rax, [r9 + rtm_interrupt_handle]     ;得到中断处理过程的线性地址
   487 00000F4C E8F4F1FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   488                                  
   489 00000F51 FA                               cli
   490                                  
   491 00000F52 41B828000000                     mov r8, 0x28                             ;使用0x20时，应调整bochs的时间速率
   492 00000F58 E849F2FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   493                                  
   494                                           ;设置和时钟中断相关的硬件
   495 00000F5D B00B                             mov al, 0x0b                             ;RTC寄存器B
   496 00000F5F 0C80                             or al, 0x80                              ;阻断NMI
   497 00000F61 E670                             out 0x70, al
   498 00000F63 B012                             mov al, 0x12                             ;设置寄存器B，禁止周期性中断，开放更
   499 00000F65 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   500                                  
   501 00000F67 E4A1                             in al, 0xa1                              ;读8259从片的IMR寄存器
   502 00000F69 24FE                             and al, 0xfe                             ;清除bit 0(此位连接RTC)
   503 00000F6B E6A1                             out 0xa1, al                             ;写回此寄存器
   504                                  
   505 00000F6D FB                               sti
   506                                  
   507 00000F6E B00C                             mov al, 0x0c
   508 00000F70 E670                             out 0x70, al
   509 00000F72 E471                             in al, 0x71                              ;读RTC寄存器C，复位未决的中断状态
   510                                  
   511                                           ;以下开始创建系统外壳任务（进程）
   512 00000F74 41B832000000                     mov r8, 50
   513 00000F7A E8BDFCFFFF                       call create_process
   514                                  
   515 00000F7F 488B1D(54000000)                 mov rbx, [rel pcb_ptr]                   ;得到外壳任务PCB的线性地址
   516 00000F86 488B4338                         mov rax, [rbx + 56]                      ;从PCB中取出CR3
   517 00000F8A 0F22D8                           mov cr3, rax                             ;切换到新进程的地址空间
   518                                  
   519 00000F8D 48891D(5C000000)                 mov [rel cur_pcb], rbx                   ;设置当前任务的PCB。
   520 00000F94 48C7431001000000                 mov qword [rbx + 16], 1                  ;设置任务状态为“忙”。
   521                                  
   522 00000F9C 488B4320                         mov rax, [rbx + 32]                      ;从PCB中取出RSP0
   523 00000FA0 488B15(1C000000)                 mov rdx, [rel tss_ptr]                   ;得到TSS的线性地址
   524 00000FA7 48894204                         mov [rdx + 4], rax                       ;在TSS中填写RSP0
   525                                  
   526 00000FAB FFB3D0000000                     push qword [rbx + 208]                   ;用户程序的SS
   527 00000FB1 FF7378                           push qword [rbx + 120]                   ;用户程序的RSP
   528 00000FB4 9C                               pushfq
   529 00000FB5 FFB3C8000000                     push qword [rbx + 200]                   ;用户程序的CS
   530 00000FBB FFB3C0000000                     push qword [rbx + 192]                   ;用户程序的RIP
   531                                  
   532 00000FC1 48CF                             iretq                                    ;返回当前任务的私有空间执行
   533                                  
   534                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   535                                  core_end:
