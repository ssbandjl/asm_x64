     1                                  ;c06_core.asm:多处理器多任务内核，李忠，2022-04-23
     2                                  
     3                                  %define __MP__
     4                                  
     5                                  %include "..\common\global_defs.wid"
     6                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     7                              <1> 
     8                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     9                              <1> 
    10                              <1> %ifndef _GLOBAL_DEFS_
    11                              <1>    %define _GLOBAL_DEFS_
    12                              <1> 
    13                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    14                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    15                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    16                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    17                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    18                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    19                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    20                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    21                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    22                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    23                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    24                              <1> 	                                        ;页目录指针表
    25                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    26                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    27                              <1> 
    28                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    29                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    30                              <1> 
    31                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    32                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    33                              <1> 	                                                                ;端起始线性地址
    34                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    35                              <1> 	                                                                ;性地址
    36                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    37                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    38                              <1> 
    39                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    40                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    41                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    42                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    43                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    44                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    45                              <1> 
    46                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    47                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    48                              <1> 			;时的起始地址
    49                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    50                              <1> 			;时的起始地址
    51                              <1> 
    52                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    53                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    54                              <1> 
    55                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    56                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    57                              <1> 
    58                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    59                              <1> 
    60                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    61                              <1> 
    62                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    63                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    64                              <1>             %%spin_lock:
    65                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    66                              <1>                        je %%get_lock      	;获取锁
    67                              <1>                        pause
    68                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    69                              <1>             %%get_lock:
    70                              <1>                        mov %1, 1
    71                              <1>                        xchg %1, %2
    72                              <1>                        cmp %1, 0          	;交换前为零？
    73                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    74                              <1>    %endmacro
    75                              <1> 
    76                              <1> %endif
    77                              <1> 
     6                                  
     7                                  ;===============================================================================
     8                                  section core_header                               ;内核程序头部
     9 00000000 [00000000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
    10 00000004 [35120000]                init_entry   dd init                            ;#4：内核入口点
    11 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    12                                  
    13                                  ;===============================================================================
    14                                  section core_data                                 ;内核数据段
    15 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    15 00000009 6F7420737570706F72-
    15 00000012 746564206F72206461-
    15 0000001B 7461206572726F722E-
    15 00000024 0D0A00             
    16                                  
    17 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    18 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    19 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    20                                  
    21 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    22 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    23                                  
    24 00000131 00                        ack_cpus     db 0                               ;处理器初始化应答计数
    25                                  
    26 00000132 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    27                                  
    28 00000136 457865637574696E67-       welcome      db "Executing in 64-bit mode.Init MP", 249, 0
    28 0000013F 20696E2036342D6269-
    28 00000148 74206D6F64652E496E-
    28 00000151 6974204D50F900     
    29 00000158 204350552873292072-       cpu_init_ok  db " CPU(s) ready.", 0x0d, 0x0a, 0
    29 00000161 656164792E0D0A00   
    30                                  
    31 00000169 00<rep 100h>              buffer       times 256 db 0
    32                                  
    33 00000269 [960B000000000000]        sys_entry    dq get_screen_row
    34 00000271 [D00A000000000000]                     dq get_cmos_time
    35 00000279 [1901000000000000]                     dq put_cstringxy64
    36 00000281 [A710000000000000]                     dq create_process
    37 00000289 [3D10000000000000]                     dq get_current_pid
    38 00000291 [5410000000000000]                     dq terminate_process
    39 00000299 [A10B000000000000]                     dq get_cpu_number
    40 000002A1 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    41                                  
    42                                  ;===============================================================================
    43                                  section core_code                                 ;内核代码段
    44                                  
    45                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    46                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    47                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    48                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    49                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    50                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    51                              <1> 
    52                              <1> %include "..\common\global_defs.wid"
    53                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    54                              <2> 
    55                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    56                              <2> 
    57                              <2> %ifndef _GLOBAL_DEFS_
    58                              <2>    %define _GLOBAL_DEFS_
    59                              <2> 
    60                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    61                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    62                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    63                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    64                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    65                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    66                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    67                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    68                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    69                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    70                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    71                              <2> 	                                        ;页目录指针表
    72                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    73                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    74                              <2> 
    75                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    76                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    77                              <2> 
    78                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    79                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    80                              <2> 	                                                                ;端起始线性地址
    81                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    82                              <2> 	                                                                ;性地址
    83                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    84                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    85                              <2> 
    86                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    87                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    88                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    89                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    90                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    91                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    92                              <2> 
    93                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    94                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    95                              <2> 			;时的起始地址
    96                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    97                              <2> 			;时的起始地址
    98                              <2> 
    99                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
   100                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
   101                              <2> 
   102                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
   103                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
   104                              <2> 
   105                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
   106                              <2> 
   107                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
   108                              <2> 
   109                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   110                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
   111                              <2>             %%spin_lock:
   112                              <2>                        cmp %2, 0           	;锁是释放状态吗？
   113                              <2>                        je %%get_lock      	;获取锁
   114                              <2>                        pause
   115                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
   116                              <2>             %%get_lock:
   117                              <2>                        mov %1, 1
   118                              <2>                        xchg %1, %2
   119                              <2>                        cmp %1, 0          	;交换前为零？
   120                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
   121                              <2>    %endmacro
   122                              <2> 
   123                              <2> %endif
   124                              <2> 
    53                              <1> 
    54                              <1>          bits 64
    55                              <1> 
    56                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    57                              <1> %ifdef __MP__
    58 00000000 0000000000000000    <1> _prn_str_locker dq 0                  	;打印锁
    59                              <1> %endif
    60                              <1> 
    61                              <1> put_string64:       	;显示0终止的字符串并移动光标
    62                              <1>                      	;输入：RBX=字符串的线性地址
    63 00000008 53                  <1>          push rbx
    64 00000009 51                  <1>          push rcx
    65                              <1> 
    66 0000000A 9C                  <1>          pushfq     	;-->A
    67 0000000B FA                  <1>          cli
    68                              <1> %ifdef __MP__
    69                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    64                              <2>  %%spin_lock:
    65 0000000C 48833DECFFFFFF00    <2>  cmp %2, 0
    66 00000014 7404                <2>  je %%get_lock
    67 00000016 F390                <2>  pause
    68 00000018 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000001A B901000000          <2>  mov %1, 1
    71 0000001F 48870DDAFFFFFF      <2>  xchg %1, %2
    72 00000026 4883F900            <2>  cmp %1, 0
    73 0000002A 75E0                <2>  jne %%spin_lock
    70                              <1> %endif
    71                              <1> 
    72                              <1>   .getc:
    73 0000002C 8A0B                <1>          mov cl, [rbx]
    74 0000002E 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    75 00000030 740A                <1>          jz .exit                 	;显示完毕，返回
    76 00000032 E814000000          <1>          call put_char
    77 00000037 48FFC3              <1>          inc rbx
    78 0000003A EBF0                <1>          jmp .getc
    79                              <1> 
    80                              <1>   .exit:
    81                              <1> %ifdef __MP__
    82 0000003C 48C705B9FFFFFF0000- <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    82 00000045 0000                <1>
    83                              <1> %endif
    84 00000047 9D                  <1>          popfq                               	;A
    85                              <1> 
    86 00000048 59                  <1>          pop rcx
    87 00000049 5B                  <1>          pop rbx
    88                              <1> 
    89 0000004A C3                  <1>          ret                                	;段内返回
    90                              <1> 
    91                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    92                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
    93                              <1> 	;进光标。
    94                              <1>                                            	;输入：CL=字符ASCII码
    95 0000004B 50                  <1>          push rax
    96 0000004C 53                  <1>          push rbx
    97 0000004D 51                  <1>          push rcx
    98 0000004E 52                  <1>          push rdx
    99 0000004F 56                  <1>          push rsi
   100 00000050 57                  <1>          push rdi
   101                              <1> 
   102                              <1>          ;以下取当前光标位置
   103 00000051 66BAD403            <1>          mov dx, 0x3d4
   104 00000055 B00E                <1>          mov al, 0x0e
   105 00000057 EE                  <1>          out dx, al
   106 00000058 66FFC2              <1>          inc dx                        	;0x3d5
   107 0000005B EC                  <1>          in al, dx                     	;高字
   108 0000005C 88C4                <1>          mov ah, al
   109                              <1> 
   110 0000005E 66FFCA              <1>          dec dx                        	;0x3d4
   111 00000061 B00F                <1>          mov al, 0x0f
   112 00000063 EE                  <1>          out dx, al
   113 00000064 66FFC2              <1>          inc dx                        	;0x3d5
   114 00000067 EC                  <1>          in al, dx                     	;低字
   115 00000068 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
   116 0000006B 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
   117                              <1> 
   118 00000072 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
   119 00000075 750E                <1>          jnz .put_0a
   120 00000077 6689D8              <1>          mov ax, bx
   121 0000007A B350                <1>          mov bl, 80
   122 0000007C F6F3                <1>          div bl
   123 0000007E F6E3                <1>          mul bl
   124 00000080 6689C3              <1>          mov bx, ax
   125 00000083 EB6C                <1>          jmp .set_cursor
   126                              <1> 
   127                              <1>   .put_0a:
   128 00000085 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   129 00000088 7506                <1>          jnz .put_other
   130 0000008A 6683C350            <1>          add bx, 80
   131 0000008E EB16                <1>          jmp .roll_screen
   132                              <1> 
   133                              <1>   .put_other:                              	;正常显示字符
   134 00000090 66D1E3              <1>          shl bx, 1
   135 00000093 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   135 0000009C FF                  <1>
   136 0000009D 880C18              <1>          mov [rax + rbx], cl
   137                              <1> 
   138                              <1>          ;以下将光标位置推进一个字符
   139 000000A0 66D1EB              <1>          shr bx, 1
   140 000000A3 66FFC3              <1>          inc bx
   141                              <1> 
   142                              <1>   .roll_screen:
   143 000000A6 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   144 000000AB 7C44                <1>          jl .set_cursor
   145                              <1> 
   146 000000AD 6653                <1>          push bx
   147                              <1> 
   148 000000AF FC                  <1>          cld
   149 000000B0 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   149 000000B9 FF                  <1>
   150 000000BA 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   150 000000C3 FF                  <1>
   151 000000C4 B9E0010000          <1>          mov rcx, 480
   152 000000C9 F348A5              <1>          rep movsq
   153 000000CC 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   154 000000D0 B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   155                              <1>   .cls:
   156 000000D5 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   156 000000DE FF                  <1>
   157 000000DF 66C704182007        <1>          mov word[rax + rbx], 0x0720
   158 000000E5 6683C302            <1>          add bx, 2
   159 000000E9 E2EA                <1>          loop .cls
   160                              <1> 
   161 000000EB 665B                <1>          pop bx
   162 000000ED 6683EB50            <1>          sub bx, 80
   163                              <1> 
   164                              <1>   .set_cursor:
   165 000000F1 66BAD403            <1>          mov dx, 0x3d4
   166 000000F5 B00E                <1>          mov al, 0x0e
   167 000000F7 EE                  <1>          out dx, al
   168 000000F8 66FFC2              <1>          inc dx                         	;0x3d5
   169 000000FB 88F8                <1>          mov al, bh
   170 000000FD EE                  <1>          out dx, al
   171 000000FE 66FFCA              <1>          dec dx       	;0x3d4
   172 00000101 B00F                <1>          mov al, 0x0f
   173 00000103 EE                  <1>          out dx, al
   174 00000104 66FFC2              <1>          inc dx       	;0x3d5
   175 00000107 88D8                <1>          mov al, bl
   176 00000109 EE                  <1>          out dx, al
   177                              <1> 
   178 0000010A 5F                  <1>          pop rdi
   179 0000010B 5E                  <1>          pop rsi
   180 0000010C 5A                  <1>          pop rdx
   181 0000010D 59                  <1>          pop rcx
   182 0000010E 5B                  <1>          pop rbx
   183 0000010F 58                  <1>          pop rax
   184                              <1> 
   185 00000110 C3                  <1>          ret
   186                              <1> 
   187                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   188                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   189                              <1> ;不同，互不干扰，不需要加锁和互斥。
   190                              <1> %ifdef __MP__
   191 00000111 0000000000000000    <1> _prnxy_locker dq 0
   192                              <1> %endif
   193                              <1> 
   194                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   195                              <1>                                           	;DH=行，DL=列
   196                              <1>                                           	;R9B=颜色属性
   197 00000119 50                  <1>          push rax
   198 0000011A 53                  <1>          push rbx
   199 0000011B 51                  <1>          push rcx
   200 0000011C 52                  <1>          push rdx
   201 0000011D 4150                <1>          push r8
   202                              <1> 
   203                              <1>          ;指定坐标位置在显存内的偏移量
   204 0000011F 88F0                <1>          mov al, dh
   205 00000121 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   206 00000123 F6E5                <1>          mul ch
   207 00000125 D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   208 00000127 6681E2FF00          <1>          and dx, 0x00ff
   209 0000012C 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   210 0000012F 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   211                              <1> 
   212 00000135 9C                  <1>          pushfq                        	;-->A
   213 00000136 FA                  <1>          cli
   214                              <1> %ifdef __MP__
   215                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    64                              <2>  %%spin_lock:
    65 00000137 48833DD2FFFFFF00    <2>  cmp %2, 0
    66 0000013F 7404                <2>  je %%get_lock
    67 00000141 F390                <2>  pause
    68 00000143 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000145 41B801000000        <2>  mov %1, 1
    71 0000014B 4C8705BFFFFFFF      <2>  xchg %1, %2
    72 00000152 4983F800            <2>  cmp %1, 0
    73 00000156 75DF                <2>  jne %%spin_lock
   216                              <1> %endif
   217                              <1> 
   218 00000158 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   218 00000161 FF                  <1>
   219                              <1>   .nextc:
   220 00000162 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   221 00000164 08D2                <1>          or dl, dl
   222 00000166 7412                <1>          jz .exit
   223 00000168 41881400            <1>          mov byte [r8 + rax], dl
   224 0000016C 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   225 00000171 48FFC3              <1>          inc rbx
   226 00000174 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   227 00000178 EBE8                <1>          jmp .nextc
   228                              <1>   .exit:
   229 0000017A 4D31C0              <1>          xor r8, r8
   230                              <1> %ifdef __MP__
   231 0000017D 48C70589FFFFFF0000- <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   231 00000186 0000                <1>
   232                              <1> %endif
   233 00000188 9D                  <1>          popfq                              	;A
   234                              <1> 
   235 00000189 4158                <1>          pop r8
   236 0000018B 5A                  <1>          pop rdx
   237 0000018C 59                  <1>          pop rcx
   238 0000018D 5B                  <1>          pop rbx
   239 0000018E 58                  <1>          pop rax
   240                              <1> 
   241 0000018F C3                  <1>          ret
   242                              <1> 
   243                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   244                              <1> make_call_gate:                          	;创建64位的调用门
   245                              <1>                                           	;输入：RAX=例程的线性地址
   246                              <1>                                           	;输出：RDI:RSI=调用门
   247 00000190 4889C7              <1>          mov rdi, rax
   248 00000193 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   249                              <1> 
   250 00000197 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   251 00000198 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   252 0000019F 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   253 000001A3 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   254 000001AA 5E                  <1>          pop rsi
   255                              <1> 
   256 000001AB C3                  <1>          ret
   257                              <1> 
   258                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   259                              <1> make_interrupt_gate:                      	;创建64位的中断门
   260                              <1>                                             	;输入：RAX=例程的线性地址
   261                              <1>                                             	;输出：RDI:RSI=中断门
   262 000001AC 4889C7              <1>          mov rdi, rax
   263 000001AF 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   264                              <1> 
   265 000001B3 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   266 000001B4 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   267 000001BB 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   268 000001BF 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   269 000001C6 5E                  <1>          pop rsi
   270                              <1> 
   271 000001C7 C3                  <1>          ret
   272                              <1> 
   273                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   274                              <1> make_trap_gate:                             	;创建64位的陷阱门
   275                              <1>                                              	;输入：RAX=例程的线性地址
   276                              <1>                                              	;输出：RDI:RSI=陷阱门
   277 000001C8 4889C7              <1>          mov rdi, rax
   278 000001CB 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   279                              <1> 
   280 000001CF 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   281 000001D0 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   282 000001D7 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   283 000001DB 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   284 000001E2 5E                  <1>          pop rsi
   285                              <1> 
   286 000001E3 C3                  <1>          ret
   287                              <1> 
   288                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   289                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   290                              <1>                                           	;输入：RAX=TSS的线性地址
   291                              <1>                                           	;输出：RDI:RSI=TSS描述符
   292 000001E4 50                  <1>          push rax
   293                              <1> 
   294 000001E5 4889C7              <1>          mov rdi, rax
   295 000001E8 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   296                              <1> 
   297 000001EC 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   298 000001ED 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   299 000001F2 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   300 000001F8 8A442405            <1>          mov al, [rsp + 5]
   301 000001FC 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   302 00000200 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   303 00000205 C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   304 0000020A 5E                  <1>          pop rsi                       	;门的低64位
   305                              <1> 
   306 0000020B 58                  <1>          pop rax
   307                              <1> 
   308 0000020C C3                  <1>          ret
   309                              <1> 
   310                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   311                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   312                              <1>                                        	;R8=中断向量
   313                              <1>                                        	;RDI:RSI=门描述符
   314 0000020D 4150                <1>          push r8
   315 0000020F 4151                <1>          push r9
   316                              <1> 
   317 00000211 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   318 00000215 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   318 0000021E FF                  <1>
   319 0000021F 4B893401            <1>          mov [r9 + r8], rsi
   320 00000223 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   321                              <1> 
   322 00000228 4159                <1>          pop r9
   323 0000022A 4158                <1>          pop r8
   324                              <1> 
   325 0000022C C3                  <1>          ret
   326                              <1> 
   327                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   328                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   329 0000022D 50                  <1>          push rax
   330                              <1> 
   331 0000022E B011                <1>          mov al, 0x11
   332 00000230 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   333 00000232 B020                <1>          mov al, 0x20
   334 00000234 E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   335 00000236 B004                <1>          mov al, 0x04
   336 00000238 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   337 0000023A B001                <1>          mov al, 0x01
   338 0000023C E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   339                              <1> 
   340 0000023E B011                <1>          mov al, 0x11
   341 00000240 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   342 00000242 B028                <1>          mov al, 0x28
   343 00000244 E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   344 00000246 B002                <1>          mov al, 0x02
   345 00000248 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   346 0000024A B001                <1>          mov al, 0x01
   347 0000024C E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   348                              <1> 
   349 0000024E 58                  <1>          pop rax
   350 0000024F C3                  <1>          ret
   351                              <1> 
   352                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   353                              <1> %ifdef __MP__
   354 00000250 0000000000000000    <1> _read_hdd_locker dq 0                 	;读硬盘锁
   355                              <1> %endif
   356                              <1> 
   357                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   358                              <1>                                         	;RAX=逻辑扇区号
   359                              <1>                                         	;RBX=目标缓冲区线性地址
   360                              <1>                                         	;返回：RBX=RBX+512
   361 00000258 50                  <1>          push rax
   362 00000259 51                  <1>          push rcx
   363 0000025A 52                  <1>          push rdx
   364                              <1> 
   365 0000025B 9C                  <1>          pushfq                     	;-->A
   366 0000025C FA                  <1>          cli
   367                              <1> %ifdef __MP__
   368                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    64                              <2>  %%spin_lock:
    65 0000025D 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 00000265 7404                <2>  je %%get_lock
    67 00000267 F390                <2>  pause
    68 00000269 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000026B BA01000000          <2>  mov %1, 1
    71 00000270 488715D9FFFFFF      <2>  xchg %1, %2
    72 00000277 4883FA00            <2>  cmp %1, 0
    73 0000027B 75E0                <2>  jne %%spin_lock
   369                              <1> %endif
   370                              <1> 
   371 0000027D 50                  <1>          push rax
   372                              <1> 
   373 0000027E 66BAF201            <1>          mov dx, 0x1f2
   374 00000282 B001                <1>          mov al, 1
   375 00000284 EE                  <1>          out dx, al                	;读取的扇区数
   376                              <1> 
   377 00000285 66FFC2              <1>          inc dx                    	;0x1f3
   378 00000288 58                  <1>          pop rax
   379 00000289 EE                  <1>          out dx, al               	;LBA地址7~0
   380                              <1> 
   381 0000028A 66FFC2              <1>          inc dx                   	;0x1f4
   382 0000028D B108                <1>          mov cl, 8
   383 0000028F 48D3E8              <1>          shr rax, cl
   384 00000292 EE                  <1>          out dx, al   	;LBA地址15~8
   385                              <1> 
   386 00000293 66FFC2              <1>          inc dx       	;0x1f5
   387 00000296 48D3E8              <1>          shr rax, cl
   388 00000299 EE                  <1>          out dx, al  	;LBA地址23~16
   389                              <1> 
   390 0000029A 66FFC2              <1>          inc dx       	;0x1f6
   391 0000029D 48D3E8              <1>          shr rax, cl
   392 000002A0 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   393 000002A2 EE                  <1>          out dx, al
   394                              <1> 
   395 000002A3 66FFC2              <1>          inc dx       	;0x1f7
   396 000002A6 B020                <1>          mov al, 0x20 	;读命令
   397 000002A8 EE                  <1>          out dx, al
   398                              <1> 
   399                              <1>   .waits:
   400 000002A9 EC                  <1>          in al, dx
   401                              <1>          ;and al, 0x88
   402                              <1>          ;cmp al, 0x08
   403 000002AA A808                <1>          test al, 8
   404 000002AC 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   405                              <1> 
   406 000002AE B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   407 000002B3 66BAF001            <1>          mov dx, 0x1f0
   408                              <1>   .readw:
   409 000002B7 66ED                <1>          in ax, dx
   410 000002B9 668903              <1>          mov [rbx], ax
   411 000002BC 4883C302            <1>          add rbx, 2
   412 000002C0 E2F5                <1>          loop .readw
   413                              <1> 
   414                              <1> %ifdef __MP__
   415 000002C2 48C70583FFFFFF0000- <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   415 000002CB 0000                <1>
   416                              <1> %endif
   417 000002CD 9D                  <1>          popfq                              			;A
   418                              <1> 
   419 000002CE 5A                  <1>          pop rdx
   420 000002CF 59                  <1>          pop rcx
   421 000002D0 58                  <1>          pop rax
   422                              <1> 
   423 000002D1 C3                  <1>          ret
   424                              <1> 
   425                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   426 000002D2 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   427 00000312 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   428                              <1>   _page_map_len  equ $ - _page_bit_map
   429                              <1> 
   430                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   431                              <1>                                             			;输入：无
   432                              <1>                                             			;输出：RAX=页的物理地址
   433 000006D2 4831C0              <1>          xor rax, rax
   434                              <1>   .b1:
   435 000006D5 F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   436 000006DE 730B                <1>          jnc .b2
   437 000006E0 48FFC0              <1>          inc rax
   438 000006E3 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   439 000006E9 7CEA                <1>          jl .b1
   440                              <1> 
   441                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   442                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   443                              <1>          ;面的换入和换出。
   444                              <1> 
   445                              <1>   .b2:
   446 000006EB 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   447                              <1> 
   448 000006EF C3                  <1>          ret
   449                              <1> 
   450                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   451                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   452                              <1>                                      	;输入：R13=线性地址
   453                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   454 000006F0 4155                <1>          push r13
   455                              <1> 
   456 000006F2 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   456 000006FB 00                  <1>
   457 000006FC 4D21F5              <1>          and r13, r14
   458 000006FF 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   459                              <1> 
   460 00000703 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   461 0000070A 4D01EE              <1>          add r14, r13
   462                              <1> 
   463 0000070D 415D                <1>          pop r13
   464                              <1> 
   465 0000070F C3                  <1>          ret
   466                              <1> 
   467                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   468                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   469                              <1>                                     	;输入：R13=线性地址
   470                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   471 00000710 4155                <1>          push r13
   472                              <1> 
   473 00000712 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   473 0000071B 00                  <1>
   474 0000071C 4D21F5              <1>          and r13, r14
   475 0000071F 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   476                              <1> 
   477 00000723 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   478 0000072A 4D01EE              <1>          add r14, r13
   479                              <1> 
   480 0000072D 415D                <1>          pop r13
   481                              <1> 
   482 0000072F C3                  <1>          ret
   483                              <1> 
   484                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   485                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   486                              <1>                                      	;输入：R13=线性地址
   487                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   488 00000730 4155                <1>          push r13
   489                              <1> 
   490 00000732 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   490 0000073B 00                  <1>
   491                              <1> 	;索引部分
   492 0000073C 4D21F5              <1>          and r13, r14
   493 0000073F 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   494                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   495 00000743 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   496 0000074A 4D01EE              <1>          add r14, r13
   497 0000074D 415D                <1>          pop r13
   498                              <1> 
   499 0000074F C3                  <1>          ret
   500                              <1> 
   501                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   502                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   503                              <1>                                    	;输入：R13=线性地址
   504                              <1>                                    	;输出：R14=对应的页表项的线性地址
   505 00000750 4155                <1>          push r13
   506                              <1> 
   507 00000752 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   507 0000075B 00                  <1>
   508                              <1> 	                                ;索引部分
   509 0000075C 4D21F5              <1>          and r13, r14
   510 0000075F 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   511                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   512 00000763 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   512 0000076C FF                  <1>
   513 0000076D 4D01EE              <1>          add r14, r13
   514                              <1> 
   515 00000770 415D                <1>          pop r13
   516 00000772 C3                  <1>          ret
   517                              <1> 
   518                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   519                              <1> %ifdef __MP__
   520 00000773 0000000000000000    <1> _spaging_locker dq 0
   521                              <1> %endif
   522                              <1> 
   523                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   524                              <1>                                    	;输入：R13=线性地址
   525 0000077B 51                  <1>          push rcx
   526 0000077C 50                  <1>          push rax
   527 0000077D 4156                <1>          push r14
   528                              <1> 
   529 0000077F 9C                  <1>          pushfq                   	;-->A
   530 00000780 FA                  <1>          cli
   531                              <1> %ifdef __MP__
   532                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    64                              <2>  %%spin_lock:
    65 00000781 48833DEAFFFFFF00    <2>  cmp %2, 0
    66 00000789 7404                <2>  je %%get_lock
    67 0000078B F390                <2>  pause
    68 0000078D EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000078F 41BE01000000        <2>  mov %1, 1
    71 00000795 4C8735D7FFFFFF      <2>  xchg %1, %2
    72 0000079C 4983FE00            <2>  cmp %1, 0
    73 000007A0 75DF                <2>  jne %%spin_lock
   533                              <1> %endif
   534                              <1> 
   535                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   536                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   537 000007A2 E849FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   538 000007A7 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   539 000007AE 752B                <1>          jnz .b0
   540                              <1> 
   541                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   542 000007B0 E81DFFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   543 000007B5 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   544 000007B9 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   545                              <1> 
   546                              <1>          ;清空刚分配的页目录指针表
   547 000007BC E84FFFFFFF          <1>          call lin_to_lin_of_pdpte
   548 000007C1 49C1EE0C            <1>          shr r14, 12
   549 000007C5 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   550 000007C9 B900020000          <1>          mov rcx, 512
   551                              <1>   .cls0:
   552 000007CE 49C70600000000      <1>          mov qword [r14], 0
   553 000007D5 4983C608            <1>          add r14, 8
   554 000007D9 E2F3                <1>          loop .cls0
   555                              <1> ;-------------------------------------------------
   556                              <1>   .b0:
   557                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   558 000007DB E830FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   559 000007E0 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   560 000007E7 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   561                              <1> 
   562                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   563 000007E9 E8E4FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   564 000007EE 4883C807            <1>          or rax, 0x07                  	;添加属性位
   565 000007F2 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   566                              <1> 
   567                              <1>          ;清空刚分配的页目录表
   568 000007F5 E836FFFFFF          <1>          call lin_to_lin_of_pdte
   569 000007FA 49C1EE0C            <1>          shr r14, 12
   570 000007FE 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   571 00000802 B900020000          <1>          mov rcx, 512
   572                              <1>   .cls1:
   573 00000807 49C70600000000      <1>          mov qword [r14], 0
   574 0000080E 4983C608            <1>          add r14, 8
   575 00000812 E2F3                <1>          loop .cls1
   576                              <1> ;-------------------------------------------------
   577                              <1>   .b1:
   578                              <1>          ;检查该线性地址所对应的页目录项是否存在
   579 00000814 E817FFFFFF          <1>          call lin_to_lin_of_pdte
   580 00000819 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   581 00000820 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   582                              <1> 
   583                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   584 00000822 E8ABFEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   585 00000827 4883C807            <1>          or rax, 0x07                      	;添加属性位
   586 0000082B 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   587                              <1> 
   588                              <1>          ;清空刚分配的页表
   589 0000082E E81DFFFFFF          <1>          call lin_to_lin_of_pte
   590 00000833 49C1EE0C            <1>          shr r14, 12
   591 00000837 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   592 0000083B B900020000          <1>          mov rcx, 512
   593                              <1>   .cls2:
   594 00000840 49C70600000000      <1>          mov qword [r14], 0
   595 00000847 4983C608            <1>          add r14, 8
   596 0000084B E2F3                <1>          loop .cls2
   597                              <1> ;-------------------------------------------------
   598                              <1>   .b2:
   599                              <1>          ;检查该线性地址所对应的页表项是否存在
   600 0000084D E8FEFEFFFF          <1>          call lin_to_lin_of_pte
   601 00000852 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   602 00000859 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   603                              <1> 
   604                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   605 0000085B E872FEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   606 00000860 4883C807            <1>          or rax, 0x07                     	;添加属性位
   607 00000864 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   608                              <1> 
   609                              <1>   .b3:
   610                              <1> %ifdef __MP__
   611 00000867 48C70501FFFFFF0000- <1>          mov qword [rel _spaging_locker], 0
   611 00000870 0000                <1>
   612                              <1> %endif
   613 00000872 9D                  <1>          popfq                      	;A
   614                              <1> 
   615 00000873 415E                <1>          pop r14
   616 00000875 58                  <1>          pop rax
   617 00000876 59                  <1>          pop rcx
   618                              <1> 
   619 00000877 C3                  <1>          ret
   620                              <1> 
   621                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   622                              <1> %ifdef __MP__
   623 00000878 0000000000000000    <1> _mapping_locker dq 0
   624                              <1> %endif
   625                              <1> 
   626                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   627                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   628                              <1>                                    	;输入：R13=线性地址
   629                              <1>                                                    ;RAX=页的物理地址（含属性）
   630 00000880 51                  <1>          push rcx
   631 00000881 4156                <1>          push r14
   632                              <1> 
   633 00000883 9C                  <1>          pushfq
   634 00000884 FA                  <1>          cli
   635                              <1> %ifdef __MP__
   636                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    64                              <2>  %%spin_lock:
    65 00000885 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 0000088D 7404                <2>  je %%get_lock
    67 0000088F F390                <2>  pause
    68 00000891 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000893 41BE01000000        <2>  mov %1, 1
    71 00000899 4C8735D8FFFFFF      <2>  xchg %1, %2
    72 000008A0 4983FE00            <2>  cmp %1, 0
    73 000008A4 75DF                <2>  jne %%spin_lock
   637                              <1> %endif
   638                              <1> 
   639 000008A6 50                  <1>          push rax
   640                              <1> 
   641                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   642                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   643 000008A7 E844FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   644 000008AC 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   645 000008B3 752B                <1>          jnz .b0
   646                              <1> 
   647                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   648 000008B5 E818FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   649 000008BA 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   650 000008BE 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   651                              <1> 
   652                              <1>          ;清空刚分配的页目录指针表
   653 000008C1 E84AFEFFFF          <1>          call lin_to_lin_of_pdpte
   654 000008C6 49C1EE0C            <1>          shr r14, 12
   655 000008CA 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   656 000008CE B900020000          <1>          mov rcx, 512
   657                              <1>   .cls0:
   658 000008D3 49C70600000000      <1>          mov qword [r14], 0
   659 000008DA 4983C608            <1>          add r14, 8
   660 000008DE E2F3                <1>          loop .cls0
   661                              <1> ;-------------------------------------------------
   662                              <1>   .b0:
   663                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   664 000008E0 E82BFEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   665 000008E5 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   666 000008EC 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   667                              <1> 
   668                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   669 000008EE E8DFFDFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   670 000008F3 4883C807            <1>          or rax, 0x07              	;添加属性位
   671 000008F7 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   672                              <1> 
   673                              <1>          ;清空刚分配的页目录表
   674 000008FA E831FEFFFF          <1>          call lin_to_lin_of_pdte
   675 000008FF 49C1EE0C            <1>          shr r14, 12
   676 00000903 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   677 00000907 B900020000          <1>          mov rcx, 512
   678                              <1>   .cls1:
   679 0000090C 49C70600000000      <1>          mov qword [r14], 0
   680 00000913 4983C608            <1>          add r14, 8
   681 00000917 E2F3                <1>          loop .cls1
   682                              <1> ;-------------------------------------------------
   683                              <1>   .b1:
   684                              <1>          ;检查该线性地址所对应的页目录项是否存在
   685 00000919 E812FEFFFF          <1>          call lin_to_lin_of_pdte
   686 0000091E 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   687 00000925 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   688                              <1> 
   689                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   690 00000927 E8A6FDFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   691 0000092C 4883C807            <1>          or rax, 0x07                  	;添加属性位
   692 00000930 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   693                              <1> 
   694                              <1>          ;清空刚分配的页表
   695 00000933 E818FEFFFF          <1>          call lin_to_lin_of_pte
   696 00000938 49C1EE0C            <1>          shr r14, 12
   697 0000093C 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   698 00000940 B900020000          <1>          mov rcx, 512
   699                              <1>   .cls2:
   700 00000945 49C70600000000      <1>          mov qword [r14], 0
   701 0000094C 4983C608            <1>          add r14, 8
   702 00000950 E2F3                <1>          loop .cls2
   703                              <1> ;-------------------------------------------------
   704                              <1>   .b2:
   705 00000952 E8F9FDFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   706 00000957 58                  <1>          pop rax
   707 00000958 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   708                              <1> 
   709                              <1> %ifdef __MP__
   710 0000095B 48C70512FFFFFF0000- <1>          mov qword [rel _mapping_locker], 0
   710 00000964 0000                <1>
   711                              <1> %endif
   712 00000966 9D                  <1>          popfq
   713                              <1> 
   714 00000967 415E                <1>          pop r14
   715 00000969 59                  <1>          pop rcx
   716                              <1> 
   717 0000096A C3                  <1>          ret
   718                              <1> 
   719                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   720 0000096B 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   721                              <1> 
   722                              <1> %ifdef __MP__
   723 00000973 0000000000000000    <1>   _core_alloc_locker dq 0
   724                              <1> %endif
   725                              <1> 
   726                              <1> core_memory_allocate:                 	;在虚拟地址空间的高端（内核）分配内存
   727                              <1>                                         	;输入：RCX=请求分配的字节数
   728                              <1>                                         	;输出：R13=本次分配的起始线性地址
   729                              <1>                                         	;      R14=下次分配的起始线性地址
   730 0000097B 9C                  <1>          pushfq                        	;A-->
   731 0000097C FA                  <1>          cli
   732                              <1> %ifdef __MP__
   733                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    64                              <2>  %%spin_lock:
    65 0000097D 48833DEEFFFFFF00    <2>  cmp %2, 0
    66 00000985 7404                <2>  je %%get_lock
    67 00000987 F390                <2>  pause
    68 00000989 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000098B 41BE01000000        <2>  mov %1, 1
    71 00000991 4C8735DBFFFFFF      <2>  xchg %1, %2
    72 00000998 4983FE00            <2>  cmp %1, 0
    73 0000099C 75DF                <2>  jne %%spin_lock
   734                              <1> %endif
   735                              <1> 
   736 0000099E 4C8B2DC6FFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   737 000009A5 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   738                              <1> 
   739 000009AA 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   740 000009B1 740C                <1>          jz .algn
   741 000009B3 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   742 000009B7 49C1EE03            <1>          shr r14, 3
   743 000009BB 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   744                              <1> 
   745                              <1>   .algn:
   746 000009BF 4C8935A5FFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   747                              <1> 
   748                              <1> %ifdef __MP__
   749 000009C6 48C705A2FFFFFF0000- <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   749 000009CF 0000                <1>
   750                              <1> %endif
   751 000009D1 9D                  <1>          popfq                             	;A
   752                              <1> 
   753 000009D2 4155                <1>          push r13
   754 000009D4 4156                <1>          push r14
   755                              <1> 
   756                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   757 000009D6 49C1ED0C            <1>          shr r13, 12
   758 000009DA 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   759 000009DE 49C1EE0C            <1>          shr r14, 12
   760 000009E2 49C1E60C            <1>          shl r14, 12                    	;too
   761                              <1>   .next:
   762 000009E6 E890FDFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   763 000009EB 4981C500100000      <1>          add r13, 0x1000               	;+4096
   764 000009F2 4D39F5              <1>          cmp r13, r14
   765 000009F5 7EEF                <1>          jle .next
   766                              <1> 
   767 000009F7 415E                <1>          pop r14
   768 000009F9 415D                <1>          pop r13
   769                              <1> 
   770 000009FB C3                  <1>          ret
   771                              <1> 
   772                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   773                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   774                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   775                              <1>                                    	;      RCX=希望分配的字节数
   776                              <1>                                    	;输出：R13=本次分配的起始线性地址
   777                              <1>                                    	;      R14=下次分配的起始线性地址
   778                              <1>          ;获得本次内存分配的起始线性地址
   779 000009FC 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   780 00000A00 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   781                              <1> 
   782 00000A05 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   783 00000A0C 740C                <1>          jz .algn
   784 00000A0E 49C1EE03            <1>          shr r14, 3
   785 00000A12 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   786 00000A16 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   787                              <1> 
   788                              <1>   .algn:
   789 00000A1A 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   790                              <1> 
   791 00000A1E 4155                <1>          push r13
   792 00000A20 4156                <1>          push r14
   793                              <1> 
   794                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   795 00000A22 49C1ED0C            <1>          shr r13, 12
   796 00000A26 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   797 00000A2A 49C1EE0C            <1>          shr r14, 12
   798 00000A2E 49C1E60C            <1>          shl r14, 12                 	;too
   799                              <1>   .next:
   800 00000A32 E844FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   801 00000A37 4981C500100000      <1>          add r13, 0x1000                ;+4096
   802 00000A3E 4D39F5              <1>          cmp r13, r14
   803 00000A41 7EEF                <1>          jle .next
   804                              <1> 
   805 00000A43 415E                <1>          pop r14
   806 00000A45 415D                <1>          pop r13
   807                              <1> 
   808 00000A47 C3                  <1>          ret
   809                              <1> 
   810                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   811                              <1> %ifdef __MP__
   812 00000A48 0000000000000000    <1> _copy_locker dq 0
   813                              <1> %endif
   814                              <1> 
   815                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   816                              <1>                                         	;输入：无
   817                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   818 00000A50 56                  <1>          push rsi
   819 00000A51 57                  <1>          push rdi
   820 00000A52 4155                <1>          push r13
   821 00000A54 51                  <1>          push rcx
   822                              <1> 
   823 00000A55 9C                  <1>          pushfq                                   	;-->A
   824 00000A56 FA                  <1>          cli
   825                              <1> %ifdef __MP__
   826                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    64                              <2>  %%spin_lock:
    65 00000A57 48833DE9FFFFFF00    <2>  cmp %2, 0
    66 00000A5F 7404                <2>  je %%get_lock
    67 00000A61 F390                <2>  pause
    68 00000A63 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000A65 B901000000          <2>  mov %1, 1
    71 00000A6A 48870DD7FFFFFF      <2>  xchg %1, %2
    72 00000A71 4883F900            <2>  cmp %1, 0
    73 00000A75 75E0                <2>  jne %%spin_lock
   827                              <1> %endif
   828                              <1> 
   829 00000A77 E856FCFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   830 00000A7C 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   831 00000A80 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   831 00000A89 FF                  <1>
   832 00000A8A E8F1FDFFFF          <1>          call mapping_laddr_to_page
   833                              <1> 
   834                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   835 00000A8F 410F017D00          <1>          invlpg [r13]
   836                              <1> 
   837 00000A94 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   838 00000A9B 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   839 00000A9E B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   840 00000AA3 FC                  <1>          cld
   841 00000AA4 F348A5              <1>          repe movsq
   842                              <1> 
   843 00000AA7 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   844 00000AAE 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   845                              <1> 
   846                              <1> %ifdef __MP__
   847 00000AB6 48C70587FFFFFF0000- <1>          mov qword [rel _copy_locker], 0
   847 00000ABF 0000                <1>
   848                              <1> %endif
   849 00000AC1 9D                  <1>          popfq                    	;A
   850                              <1> 
   851 00000AC2 59                  <1>          pop rcx
   852 00000AC3 415D                <1>          pop r13
   853 00000AC5 5F                  <1>          pop rdi
   854 00000AC6 5E                  <1>          pop rsi
   855                              <1> 
   856 00000AC7 C3                  <1>          ret
   857                              <1> 
   858                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   859                              <1> %ifdef __MP__
   860 00000AC8 0000000000000000    <1> _cmos_locker dq 0
   861                              <1> %endif
   862                              <1> 
   863                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   864                              <1>                                        	;输入：RBX=缓冲区线性地址
   865 00000AD0 50                  <1>          push rax
   866                              <1> 
   867 00000AD1 9C                  <1>          pushfq                       	;-->A
   868 00000AD2 FA                  <1>          cli
   869                              <1> %ifdef __MP__
   870                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
    64                              <2>  %%spin_lock:
    65 00000AD3 48833DEDFFFFFF00    <2>  cmp %2, 0
    66 00000ADB 7404                <2>  je %%get_lock
    67 00000ADD F390                <2>  pause
    68 00000ADF EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000AE1 B801000000          <2>  mov %1, 1
    71 00000AE6 488705DBFFFFFF      <2>  xchg %1, %2
    72 00000AED 4883F800            <2>  cmp %1, 0
    73 00000AF1 75E0                <2>  jne %%spin_lock
   871                              <1> %endif
   872                              <1> 
   873                              <1>   .w0:
   874 00000AF3 B08A                <1>          mov al, 0x8a
   875 00000AF5 E670                <1>          out 0x70, al
   876 00000AF7 E471                <1>          in al, 0x71                 	;读寄存器A
   877 00000AF9 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   878 00000AFB 75F6                <1>          jnz .w0
   879                              <1> 
   880 00000AFD B084                <1>          mov al, 0x84
   881 00000AFF E670                <1>          out 0x70, al
   882 00000B01 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   883 00000B03 88C4                <1>          mov ah, al
   884                              <1> 
   885 00000B05 C0EC04              <1>          shr ah, 4
   886 00000B08 80E40F              <1>          and ah, 0x0f
   887 00000B0B 80C430              <1>          add ah, 0x30
   888 00000B0E 8823                <1>          mov [rbx], ah
   889                              <1> 
   890 00000B10 240F                <1>          and al, 0x0f
   891 00000B12 0430                <1>          add al, 0x30
   892 00000B14 884301              <1>          mov [rbx + 1], al
   893                              <1> 
   894 00000B17 C643023A            <1>          mov byte [rbx + 2], ':'
   895                              <1> 
   896 00000B1B B082                <1>          mov al, 0x82
   897 00000B1D E670                <1>          out 0x70, al
   898 00000B1F E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   899 00000B21 88C4                <1>          mov ah, al
   900                              <1> 
   901 00000B23 C0EC04              <1>          shr ah, 4
   902 00000B26 80E40F              <1>          and ah, 0x0f
   903 00000B29 80C430              <1>          add ah, 0x30
   904 00000B2C 886303              <1>          mov [rbx + 3], ah
   905                              <1> 
   906 00000B2F 240F                <1>          and al, 0x0f
   907 00000B31 0430                <1>          add al, 0x30
   908 00000B33 884304              <1>          mov [rbx + 4], al
   909                              <1> 
   910 00000B36 C643053A            <1>          mov byte [rbx + 5], ':'
   911                              <1> 
   912 00000B3A B080                <1>          mov al, 0x80
   913 00000B3C E670                <1>          out 0x70, al
   914 00000B3E E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   915 00000B40 88C4                <1>          mov ah, al              	;分拆成两个数字
   916                              <1> 
   917 00000B42 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   918 00000B45 80E40F              <1>          and ah, 0x0f
   919 00000B48 80C430              <1>          add ah, 0x30
   920 00000B4B 886306              <1>          mov [rbx + 6], ah
   921                              <1> 
   922 00000B4E 240F                <1>          and al, 0x0f               	;仅保留低4位
   923 00000B50 0430                <1>          add al, 0x30               	;转换成ASCII
   924 00000B52 884307              <1>          mov [rbx + 7], al
   925                              <1> 
   926 00000B55 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   927                              <1> 
   928                              <1> %ifdef __MP__
   929 00000B59 48C70564FFFFFF0000- <1>          mov qword [rel _cmos_locker], 0
   929 00000B62 0000                <1>
   930                              <1> %endif
   931 00000B64 9D                  <1>          popfq                	;A
   932                              <1> 
   933 00000B65 58                  <1>          pop rax
   934                              <1> 
   935 00000B66 C3                  <1>          ret
   936                              <1> 
   937                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   938 00000B67 0000000000000000    <1>   _process_id        dq 0
   939                              <1> 
   940                              <1> generate_process_id:                  	;生成唯一的进程标识
   941                              <1>                                         	;返回：RAX=进程标识
   942 00000B6F B801000000          <1>          mov rax, 1
   943 00000B74 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   944                              <1> 
   945 00000B7D C3                  <1>          ret
   946                              <1> 
   947                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   948 00000B7E 0000000000000000    <1>   _thread_id dq 0
   949                              <1> 
   950                              <1> generate_thread_id:                 	;生成唯一的线程标识
   951                              <1>                                       	;返回：RAX=线程标识
   952 00000B86 B801000000          <1>          mov rax, 1
   953 00000B8B F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   954                              <1> 
   955 00000B94 C3                  <1>          ret
   956                              <1> 
   957                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   958 00000B95 08                  <1>   _screen_row        db 8
   959                              <1> 
   960                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   961                              <1>                                      	;返回：DH=行号
   962 00000B96 B601                <1>          mov dh, 1
   963 00000B98 F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   964                              <1> 
   965 00000BA0 C3                  <1>          ret
   966                              <1> 
   967                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   968                              <1> get_cpu_number:                        	;返回当前处理器的编号
   969                              <1>                                         	;返回：RAX=处理器编号
   970 00000BA1 9C                  <1>          pushfq
   971 00000BA2 FA                  <1>          cli
   972 00000BA3 0F01F8              <1>          swapgs
   973 00000BA6 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   974 00000BAF 0F01F8              <1>          swapgs
   975 00000BB2 9D                  <1>          popfq
   976 00000BB3 C3                  <1>          ret
   977                              <1> 
   978                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   979                              <1> memory_allocate:                       	;用户空间的内存分配
   980                              <1>                                          	;进入：RDX=期望分配的字节数
   981                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   982 00000BB4 51                  <1>          push rcx
   983 00000BB5 4153                <1>          push r11
   984 00000BB7 4156                <1>          push r14
   985                              <1> 
   986 00000BB9 9C                  <1>          pushfq
   987 00000BBA FA                  <1>          cli
   988 00000BBB 0F01F8              <1>          swapgs
   989 00000BBE 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
   990 00000BC7 0F01F8              <1>          swapgs
   991 00000BCA 9D                  <1>          popfq
   992                              <1> 
   993 00000BCB 4889D1              <1>          mov rcx, rdx
   994 00000BCE E829FEFFFF          <1>          call user_memory_allocate
   995                              <1> 
   996 00000BD3 415E                <1>          pop r14
   997 00000BD5 415B                <1>          pop r11
   998 00000BD7 59                  <1>          pop rcx
   999                              <1> 
  1000 00000BD8 C3                  <1>          ret
  1001                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    46                                  %include "..\common\user_static64.lib"
    47                              <1> ;user_static64.lib:用户程序使用的例程库，用来模拟高级语言的静态库。有些功能直接在本文件
    48                              <1> ;中实现，但有些功能需要通过syscall指令使用内核提供的系统调用。
    49                              <1> ;创建时间：2022-01-30 18:30，李忠
    50                              <1> ;此文件需要用预处理指令%include引入用户程序。
    51                              <1> 
    52                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    53                              <1>          bits 64
    54                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    55                              <1> bin64_to_dec:                                     ;将二进制数转换为十进制字符串。
    56                              <1>                                                   ;输入：R8=64位二进制数
    57                              <1>                                                   ;      RBX=目标缓冲区线性地址
    58 00000BD9 50                  <1>          push rax
    59 00000BDA 53                  <1>          push rbx
    60 00000BDB 51                  <1>          push rcx
    61 00000BDC 52                  <1>          push rdx
    62 00000BDD 4150                <1>          push r8
    63                              <1> 
    64 00000BDF 490FBAE03F          <1>          bt r8, 63
    65 00000BE4 7309                <1>          jnc .begin
    66 00000BE6 C6032D              <1>          mov byte [rbx], '-'
    67 00000BE9 49F7D8              <1>          neg r8
    68 00000BEC 48FFC3              <1>          inc rbx
    69                              <1>   .begin:
    70 00000BEF 4C89C0              <1>          mov rax, r8                              ;!!
    71 00000BF2 41B80A000000        <1>          mov r8, 10
    72 00000BF8 4831C9              <1>          xor rcx, rcx
    73                              <1> 
    74                              <1>   .next_div:
    75 00000BFB 4831D2              <1>          xor rdx, rdx
    76 00000BFE 49F7F0              <1>          div r8
    77 00000C01 52                  <1>          push rdx                                 ;保存分解的数位
    78 00000C02 48FFC1              <1>          inc rcx                                  ;递增压栈的次数
    79 00000C05 4809C0              <1>          or rax, rax                              ;商为0？
    80 00000C08 7402                <1>          jz .rotate
    81 00000C0A EBEF                <1>          jmp .next_div
    82                              <1> 
    83                              <1>   .rotate:
    84 00000C0C 5A                  <1>          pop rdx
    85 00000C0D 80C230              <1>          add dl, 0x30                             ;数位转换成ASCII编码
    86 00000C10 8813                <1>          mov [rbx], dl
    87 00000C12 48FFC3              <1>          inc rbx
    88 00000C15 E2F5                <1>          loop .rotate
    89                              <1> 
    90 00000C17 C60300              <1>          mov byte [rbx], 0
    91                              <1> 
    92 00000C1A 4158                <1>          pop r8
    93 00000C1C 5A                  <1>          pop rdx
    94 00000C1D 59                  <1>          pop rcx
    95 00000C1E 5B                  <1>          pop rbx
    96 00000C1F 58                  <1>          pop rax
    97                              <1> 
    98 00000C20 C3                  <1>          ret                                      ;段内返回
    99                              <1> 
   100                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   101                              <1> string_concatenates:                              ;将源字符串连接到目的字符串的尾部
   102                              <1>                                                   ;输入：RSI=源字符串的线性地址
   103                              <1>                                                   ;      RDI=目的字符串的线性地址
   104 00000C21 50                  <1>          push rax
   105 00000C22 56                  <1>          push rsi
   106 00000C23 57                  <1>          push rdi
   107                              <1> 
   108                              <1>   .r0:
   109 00000C24 803F00              <1>          cmp byte [rdi], 0
   110 00000C27 7405                <1>          jz .r1
   111 00000C29 48FFC7              <1>          inc rdi
   112 00000C2C EBF6                <1>          jmp .r0
   113                              <1> 
   114                              <1>   .r1:
   115 00000C2E 8A06                <1>          mov al, [rsi]
   116 00000C30 8807                <1>          mov [rdi], al
   117 00000C32 3C00                <1>          cmp al, 0
   118 00000C34 7408                <1>          jz .r2
   119 00000C36 48FFC6              <1>          inc rsi
   120 00000C39 48FFC7              <1>          inc rdi
   121 00000C3C EBF0                <1>          jmp .r1
   122                              <1> 
   123                              <1>   .r2:
   124 00000C3E 5F                  <1>          pop rdi
   125 00000C3F 5E                  <1>          pop rsi
   126 00000C40 58                  <1>          pop rax
   127                              <1> 
   128 00000C41 C3                  <1>          ret
   129                              <1> 
   130                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   131                              <1> 
    47                                  
    48                                           bits 64
    49                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    50 00000C42 F900                      _ap_string      db 249, 0
    51                                  
    52                                  ap_to_core_entry:                                 ;应用处理器（AP）进入内核的入口点
    53                                           ;启用GDT的高端线性地址并加载IDTR
    54 00000C44 48B8007E00000080FF-              mov rax, UPPER_SDA_LINEAR
    54 00000C4D FF                 
    55 00000C4E 0F015002                         lgdt [rax + 2]                           ;只有在64位模式下才能加载64位线性地址部分
    56 00000C52 0F01580C                         lidt [rax + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
    57                                  
    58                                           ;为当前处理器创建64位模式下的专属栈
    59 00000C56 B900100000                       mov rcx, 4096
    60 00000C5B E81BFDFFFF                       call core_memory_allocate
    61 00000C60 4C89F4                           mov rsp, r14
    62                                  
    63                                           ;创建当前处理器的专属存储区（含TSS），并安装TSS描述符到GDT
    64 00000C63 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
    65 00000C68 E80EFDFFFF                       call core_memory_allocate
    66 00000C6D 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
    67 00000C74 E86BF5FFFF                       call make_tss_descriptor
    68                                  
    69 00000C79 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区的高端线性地址（低端亦可）
    69 00000C82 FF                 
    70                                  
    71 00000C83 4D8B4704                         mov r8, [r15 + 4]                        ;R8=GDT的线性地址
    72 00000C87 490FB74F02                       movzx rcx, word [r15 + 2]                ;RCX=GDT的界限值
    73 00000C8C 4989740801                       mov [r8 + rcx + 1], rsi                  ;TSS描述符的低64位
    74 00000C91 49897C0809                       mov [r8 + rcx + 9], rdi                  ;TSS描述符的高64位
    75                                  
    76 00000C96 664183470210                     add word [r15 + 2], 16
    77 00000C9C 410F015702                       lgdt [r15 + 2]                           ;重新加载GDTR
    78                                  
    79 00000CA1 66C1E903                         shr cx, 3                                ;除以8（消除余数），得到索引号
    80 00000CA5 66FFC1                           inc cx                                   ;索引号递增
    81 00000CA8 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
    82                                  
    83 00000CAC 0F00D9                           ltr cx                                   ;为当前处理器加载任务寄存器TR
    84                                  
    85                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
    86 00000CAF B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
    87 00000CB4 4C89E8                           mov rax, r13                             ;只用EAX
    88 00000CB7 4C89EA                           mov rdx, r13
    89 00000CBA 48C1EA20                         shr rdx, 32                              ;只用EDX
    90 00000CBE 0F30                             wrmsr
    91                                  
    92                                           ;为快速系统调用SYSCALL和SYSRET准备参数
    93 00000CC0 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
    94 00000CC5 0F32                             rdmsr
    95 00000CC7 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
    96 00000CCB 0F30                             wrmsr
    97                                  
    98 00000CCD B9810000C0                       mov ecx, 0xc0000081                      ;STAR
    99 00000CD2 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   100 00000CD7 31C0                             xor eax, eax
   101 00000CD9 0F30                             wrmsr
   102                                  
   103 00000CDB B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   104 00000CE0 488B05(08000000)                 mov rax, [rel position]
   105 00000CE7 488D80[F9110000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   106 00000CEE 4889C2                           mov rdx, rax
   107 00000CF1 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   108 00000CF5 0F30                             wrmsr
   109                                  
   110 00000CF7 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   111 00000CFC 31D2                             xor edx, edx
   112 00000CFE B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   113 00000D03 0F30                             wrmsr
   114                                  
   115 00000D05 4C8B3D(08000000)                 mov r15, [rel position]
   116 00000D0C 498D9F[420C0000]                 lea rbx, [r15 + _ap_string]
   117 00000D13 E8F0F2FFFF                       call put_string64                        ;位于core_utils64.wid
   118                                  
   119 00000D18 0F01F8                           swapgs                                   ;准备用GS操作当前处理器的专属数据
   120 00000D1B 6548C7042508000000-              mov qword [gs:8], 0                      ;没有正在执行的任务
   120 00000D24 00000000           
   121 00000D28 4831C0                           xor rax, rax
   122 00000D2B 8A05(31010000)                   mov al, byte [rel ack_cpus]
   123 00000D31 654889042510000000               mov [gs:16], rax                         ;设置当前处理器的编号
   124 00000D3A 654889242518000000               mov [gs:24], rsp                         ;保存当前处理器的固有栈指针
   125 00000D43 0F01F8                           swapgs
   126                                  
   127 00000D46 FE05(31010000)                   inc byte [rel ack_cpus]                  ;递增应答计数值
   128                                  
   129 00000D4C C60425[82F00000]00               mov byte [AP_START_UP_ADDR + lock_var], 0;释放自旋锁
   130                                  
   131 00000D54 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   131 00000D5D FF                 
   132 00000D5E 0FBAAEF000000008                 bts dword [rsi + 0xf0], 8                ;设置SVR寄存器，允许LAPIC
   133                                  
   134 00000D66 FB                               sti                                      ;开放中断
   135                                  
   136                                    .do_idle:
   137 00000D67 F4                               hlt
   138 00000D68 EBFD                             jmp .do_idle
   139                                  
   140                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   141                                  general_interrupt_handler:                        ;通用中断处理过程
   142 00000D6A 48CF                             iretq
   143                                  
   144                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   145                                  general_exception_handler:                        ;通用异常处理过程
   146                                                                                    ;在24行0列显示红底白字的错误信息
   147 00000D6C 4C8B3D(08000000)                 mov r15, [rel position]
   148 00000D73 498D9F[880D0000]                 lea rbx, [r15 + exceptm]
   149 00000D7A B618                             mov dh, 24
   150 00000D7C B200                             mov dl, 0
   151 00000D7E 41B14F                           mov r9b, 0x4f
   152 00000D81 E893F3FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
   153                                  
   154 00000D86 FA                               cli
   155 00000D87 F4                               hlt                                      ;停机且不接受外部硬件中断
   156                                  
   157 00000D88 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
   157 00000D91 6F6E20726169736564-
   157 00000D9A 2C68616C742E00     
   158                                  
   159                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   160                                  search_for_a_ready_task:                          ;查找一个就绪的任务并将其置为忙
   161                                                                                    ;返回：R11=就绪任务的PCB线性地址
   162                                           ;此例程通常是在中断处理过程内调用，默认中断是关闭状态。
   163 00000DA1 50                               push rax
   164 00000DA2 53                               push rbx
   165 00000DA3 51                               push rcx
   166                                  
   167 00000DA4 B901000000                       mov rcx, 1                               ;RCX=任务的“忙”状态
   168                                  
   169 00000DA9 0F01F8                           swapgs
   170 00000DAC 65488B1C2508000000               mov rbx, [gs:8]                          ;取得当前任务的PCB线性地址
   171 00000DB5 0F01F8                           swapgs
   172 00000DB8 4989DB                           mov r11, rbx
   173 00000DBB 4883FB00                         cmp rbx, 0                               ;处理器当前未在执行任务？
   174 00000DBF 750A                             jne .again
   175 00000DC1 488B1D(A1020000)                 mov rbx, [rel pcb_ptr]                   ;是的。从链表首节点开始搜索。
   176 00000DC8 4989DB                           mov r11, rbx
   177                                    .again:
   178 00000DCB 4D8B9B18010000                   mov r11, [r11 + 280]                     ;取得下一个节点
   179 00000DD2 4831C0                           xor rax, rax
   180 00000DD5 F0490FB14B10                     lock cmpxchg [r11 + 16], rcx             ;开发无锁算法的挑战并不是完全
   181                                           ;消除竞争，它可以归结为将代码的关键部分减少到由CPU本身提供的单个原子操作。
   182 00000DDB 740A                             jz .retrn
   183 00000DDD 4939DB                           cmp r11, rbx                             ;是否转一圈回到当前节点？
   184 00000DE0 7402                             je .fmiss                                ;是。未找到就绪任务（节点）
   185 00000DE2 EBE7                             jmp .again
   186                                  
   187                                    .fmiss:
   188 00000DE4 4D31DB                           xor r11, r11
   189                                    .retrn:
   190 00000DE7 59                               pop rcx
   191 00000DE8 5B                               pop rbx
   192 00000DE9 58                               pop rax
   193 00000DEA C3                               ret
   194                                  
   195                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   196                                  resume_execute_a_task:                            ;恢复执行一个任务
   197                                                                                    ;传入：R11=指定任务的PCB线性地址
   198                                           ;此例程在中断处理过程内调用，默认中断是关闭状态。
   199 00000DEB 8B05(32010000)                   mov eax, [rel clocks_1ms]                ;以下计算新任务运行时间
   200 00000DF1 418B9BF0000000                   mov ebx, [r11 + 240]                     ;为任务指定的时间片
   201 00000DF8 F7E3                             mul ebx
   202                                  
   203 00000DFA 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   203 00000E03 FF                 
   204 00000E04 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频
   204 00000E0D 00                 
   205 00000E0E C78620030000FD0000-              mov dword [rsi + 0x320], 0xfd            ;单次击发模式，Fixed，中断号0xfd
   205 00000E17 00                 
   206                                  
   207 00000E18 498B5B38                         mov rbx, [r11 + 56]
   208 00000E1C 0F22DB                           mov cr3, rbx                             ;切换地址空间
   209                                  
   210 00000E1F 0F01F8                           swapgs
   211 00000E22 654C891C2508000000               mov [gs:8], r11                          ;将新任务设置为当前任务
   212                                           ;mov qword [r11 + 16], 1                  ;置任务状态为忙
   213 00000E2B 498B5B20                         mov rbx, [r11 + 32]                      ;取PCB中的RSP0
   214 00000E2F 6548891C2584000000               mov [gs:128 + 4], rbx                    ;置TSS的RSP0
   215 00000E38 0F01F8                           swapgs
   216                                  
   217 00000E3B 498B4B50                         mov rcx, [r11 + 80]
   218 00000E3F 498B5358                         mov rdx, [r11 + 88]
   219 00000E43 498B7B68                         mov rdi, [r11 + 104]
   220 00000E47 498B6B70                         mov rbp, [r11 + 112]
   221 00000E4B 498B6378                         mov rsp, [r11 + 120]
   222 00000E4F 4D8B8380000000                   mov r8, [r11 + 128]
   223 00000E56 4D8B8B88000000                   mov r9, [r11 + 136]
   224 00000E5D 4D8B9390000000                   mov r10, [r11 + 144]
   225 00000E64 4D8BA3A0000000                   mov r12, [r11 + 160]
   226 00000E6B 4D8BABA8000000                   mov r13, [r11 + 168]
   227 00000E72 4D8BB3B0000000                   mov r14, [r11 + 176]
   228 00000E79 4D8BBBB8000000                   mov r15, [r11 + 184]
   229 00000E80 41FFB3D0000000                   push qword [r11 + 208]                   ;SS
   230 00000E87 41FF7378                         push qword [r11 + 120]                   ;RSP
   231 00000E8B 41FFB3E8000000                   push qword [r11 + 232]                   ;RFLAGS
   232 00000E92 41FFB3C8000000                   push qword [r11 + 200]                   ;CS
   233 00000E99 41FFB3C0000000                   push qword [r11 + 192]                   ;RIP
   234                                  
   235 00000EA0 898680030000                     mov dword [rsi + 0x380], eax             ;开始计时
   236                                  
   237 00000EA6 498B4340                         mov rax, [r11 + 64]
   238 00000EAA 498B5B48                         mov rbx, [r11 + 72]
   239 00000EAE 498B7360                         mov rsi, [r11 + 96]
   240 00000EB2 4D8B9B98000000                   mov r11, [r11 + 152]
   241                                  
   242 00000EB9 48CF                             iretq                                    ;转入新任务的空间执行
   243                                  
   244                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   245                                  time_slice_out_handler:                           ;时间片到期中断的处理过程
   246 00000EBB 50                               push rax
   247 00000EBC 53                               push rbx
   248 00000EBD 4153                             push r11
   249                                  
   250 00000EBF 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   250 00000EC8 FF                 
   251 00000EC9 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   251 00000ED2 0000               
   252                                  
   253 00000ED4 E8C8FEFFFF                       call search_for_a_ready_task
   254 00000ED9 4D09DB                           or r11, r11
   255 00000EDC 0F8494000000                     jz .return                               ;未找到就绪的任务
   256                                  
   257 00000EE2 0F01F8                           swapgs
   258 00000EE5 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   259 00000EEE 0F01F8                           swapgs
   260                                  
   261                                           ;保存当前任务的状态以便将来恢复执行。
   262 00000EF1 0F20DB                           mov rbx, cr3                             ;保存原任务的分页系统
   263 00000EF4 48895838                         mov qword [rax + 56], rbx
   264                                           ;mov [rax + 64], rax                      ;不需设置，将来恢复执行时从栈中弹出
   265                                           ;mov [rax + 72], rbx                      ;不需设置，将来恢复执行时从栈中弹出
   266 00000EF8 48894850                         mov [rax + 80], rcx
   267 00000EFC 48895058                         mov [rax + 88], rdx
   268 00000F00 48897060                         mov [rax + 96], rsi
   269 00000F04 48897868                         mov [rax + 104], rdi
   270 00000F08 48896870                         mov [rax + 112], rbp
   271 00000F0C 48896078                         mov [rax + 120], rsp
   272 00000F10 4C898080000000                   mov [rax + 128], r8
   273 00000F17 4C898888000000                   mov [rax + 136], r9
   274 00000F1E 4C899090000000                   mov [rax + 144], r10
   275                                           ;mov [rax + 152], r11                     ;不需设置，将来恢复执行时从栈中弹出
   276 00000F25 4C89A0A0000000                   mov [rax + 160], r12
   277 00000F2C 4C89A8A8000000                   mov [rax + 168], r13
   278 00000F33 4C89B0B0000000                   mov [rax + 176], r14
   279 00000F3A 4C89B8B8000000                   mov [rax + 184], r15
   280 00000F41 488B1D(08000000)                 mov rbx, [rel position]
   281 00000F48 488D9B[760F0000]                 lea rbx, [rbx + .return]                 ;将来恢复执行时，是从中断返回也～
   282 00000F4F 488998C0000000                   mov [rax + 192], rbx                     ;RIP域为中断返回点
   283 00000F56 8C88C8000000                     mov [rax + 200], cs
   284 00000F5C 8C90D0000000                     mov [rax + 208], ss
   285 00000F62 9C                               pushfq
   286 00000F63 8F80E8000000                     pop qword [rax + 232]
   287                                  
   288 00000F69 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
   289                                  
   290 00000F71 E975FEFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   291                                  
   292                                    .return:
   293 00000F76 415B                             pop r11
   294 00000F78 5B                               pop rbx
   295 00000F79 58                               pop rax
   296 00000F7A 48CF                             iretq
   297                                  
   298                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   299                                  ;新任务创建后，将广播新任务创建消息给所有处理器，所有处理器执行此中断服务例程。
   300                                  new_task_notify_handler:                          ;任务认领中断的处理过程
   301 00000F7C 56                               push rsi
   302 00000F7D 4153                             push r11
   303                                  
   304 00000F7F 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   304 00000F88 FF                 
   305 00000F89 C786B0000000000000-              mov dword [rsi + 0xb0], 0                ;发送EOI
   305 00000F92 00                 
   306                                  
   307 00000F93 0F01F8                           swapgs
   308 00000F96 6548833C2508000000-              cmp qword [gs:8], 0                      ;当前处理器没有任务执行吗？
   308 00000F9F 00                 
   309 00000FA0 0F01F8                           swapgs
   310 00000FA3 7522                             jne .return                              ;是的（忙）。不打扰了 :)
   311                                  
   312 00000FA5 E8F7FDFFFF                       call search_for_a_ready_task
   313 00000FAA 4D09DB                           or r11, r11
   314 00000FAD 7418                             jz .return                               ;未找到就绪的任务
   315                                  
   316 00000FAF 0F01F8                           swapgs
   317 00000FB2 4883C410                         add rsp, 16                              ;去掉进入例程时压入的两个参数
   318 00000FB6 654889242518000000               mov qword [gs:24], rsp                   ;保存固有栈当前指针以便将来返回
   319 00000FBF 0F01F8                           swapgs
   320                                  
   321 00000FC2 E924FEFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   322                                  
   323                                    .return:
   324 00000FC7 415B                             pop r11
   325 00000FC9 5E                               pop rsi
   326                                  
   327 00000FCA 48CF                             iretq
   328                                  
   329                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   330 00000FCC 0000000000000000          _append_lock  dq 0
   331                                  
   332                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   333                                                                                    ;输入：R11=PCB线性基地址
   334 00000FD4 50                               push rax
   335 00000FD5 53                               push rbx
   336                                  
   337 00000FD6 9C                               pushfq                                   ;-->A
   338 00000FD7 FA                               cli
   339                                           SET_SPIN_LOCK rax, qword [rel _append_lock]
    64                              <1>  %%spin_lock:
    65 00000FD8 48833DECFFFFFF00    <1>  cmp %2, 0
    66 00000FE0 7404                <1>  je %%get_lock
    67 00000FE2 F390                <1>  pause
    68 00000FE4 EBF2                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00000FE6 B801000000          <1>  mov %1, 1
    71 00000FEB 488705DAFFFFFF      <1>  xchg %1, %2
    72 00000FF2 4883F800            <1>  cmp %1, 0
    73 00000FF6 75E0                <1>  jne %%spin_lock
   340                                  
   341 00000FF8 488B1D(A1020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   342 00000FFF 4809DB                           or rbx, rbx
   343 00001002 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   344 00001004 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   345 00001007 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   346 0000100E 4C891D(A1020000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   347 00001015 EB17                             jmp .return
   348                                  
   349                                    .not_empty:
   350 00001017 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   351                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   352 0000101A 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   353 00001021 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   354 00001028 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   355 0000102B 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   356                                  
   357                                    .return:
   358 0000102E 48C70593FFFFFF0000-              mov qword [rel _append_lock], 0          ;释放锁
   358 00001037 0000               
   359 00001039 9D                               popfq                                    ;A
   360                                  
   361 0000103A 5B                               pop rbx
   362 0000103B 58                               pop rax
   363                                  
   364 0000103C C3                               ret
   365                                  
   366                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   367                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   368 0000103D 9C                               pushfq
   369 0000103E FA                               cli
   370 0000103F 0F01F8                           swapgs
   371 00001042 65488B042508000000               mov rax, [gs:8]
   372 0000104B 488B4008                         mov rax, [rax + 8]
   373 0000104F 0F01F8                           swapgs
   374 00001052 9D                               popfq
   375                                  
   376 00001053 C3                               ret
   377                                  
   378                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   379                                  terminate_process:                                ;终止当前任务
   380 00001054 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   380 0000105D FF                 
   381 0000105E C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   381 00001067 00                 
   382                                  
   383 00001068 FA                               cli
   384                                  
   385 00001069 0F01F8                           swapgs
   386 0000106C 65488B042508000000               mov rax, [gs:8]                          ;定位到当前任务的PCB节点
   387 00001075 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   388 0000107D 6548C7042500000000-              mov qword [gs:0], 0
   388 00001086 00000000           
   389 0000108A 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   390 00001093 0F01F8                           swapgs
   391                                  
   392 00001096 E806FDFFFF                       call search_for_a_ready_task
   393 0000109B 4D09DB                           or r11, r11
   394 0000109E 7405                             jz .sleep                                ;未找到就绪的任务
   395                                  
   396 000010A0 E946FDFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   397                                  
   398                                    .sleep:
   399 000010A5 48CF                             iretq                                    ;回到不执行任务的日子:)
   400                                  
   401                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   402                                  create_process:                                   ;创建新的任务
   403                                                                                    ;输入：R8=程序的起始逻辑扇区号
   404 000010A7 50                               push rax
   405 000010A8 53                               push rbx
   406 000010A9 51                               push rcx
   407 000010AA 52                               push rdx
   408 000010AB 56                               push rsi
   409 000010AC 57                               push rdi
   410 000010AD 55                               push rbp
   411 000010AE 4150                             push r8
   412 000010B0 4151                             push r9
   413 000010B2 4152                             push r10
   414 000010B4 4153                             push r11
   415 000010B6 4154                             push r12
   416 000010B8 4155                             push r13
   417 000010BA 4156                             push r14
   418 000010BC 4157                             push r15
   419                                  
   420                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   421 000010BE B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   422 000010C3 E8B3F8FFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   423                                  
   424 000010C8 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   425                                  
   426 000010CB 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   427                                  
   428                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   429 000010D3 E878F9FFFF                       call copy_current_pml4
   430 000010D8 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   431                                  
   432                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   433                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   434                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈是位于地址空间高端的栈。
   435                                  
   436 000010DC 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   437 000010E0 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   438                                  
   439                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   440 000010E3 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   441 000010EA B900010000                       mov rcx, 256
   442                                    .clsp:
   443 000010EF 48C70000000000                   mov qword [rax], 0
   444 000010F6 4883C008                         add rax, 8
   445 000010FA E2F3                             loop .clsp
   446                                  
   447 000010FC 0F20D8                           mov rax, cr3                             ;刷新TLB
   448 000010FF 0F22D8                           mov cr3, rax
   449                                  
   450 00001102 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   451 00001107 E86FF8FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   452 0000110C 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   453                                  
   454 00001110 B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   455 00001115 E8E2F8FFFF                       call user_memory_allocate
   456 0000111A 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   457                                  
   458 0000111E 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   459                                  
   460                                           ;以下开始加载用户程序
   461 00001126 B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   462 0000112B E8CCF8FFFF                       call user_memory_allocate
   463 00001130 4C89EB                           mov rbx, r13
   464 00001133 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   465 00001136 E81DF1FFFF                       call read_hard_disk_0
   466                                  
   467 0000113B 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   468 0000113F 4D89EE                           mov r14, r13
   469 00001142 4D037508                         add r14, [r13 + 8]
   470 00001146 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   471                                  
   472                                           ;以下判断整个程序有多大
   473 0000114D 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   474 00001151 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   475 00001158 740F                             jz .y512
   476 0000115A 48C1E909                         shr rcx, 9                               ;不能？凑整。
   477 0000115E 48C1E109                         shl rcx, 9
   478 00001162 4881C100020000                   add rcx, 512
   479                                    .y512:
   480 00001169 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   481 00001170 7416                             jz .rdok
   482 00001172 E885F8FFFF                       call user_memory_allocate
   483                                           ;mov rbx, r13
   484 00001177 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   485 0000117B 48FFC0                           inc rax                                  ;起始扇区号
   486                                    .b1:
   487 0000117E E8D5F0FFFF                       call read_hard_disk_0
   488 00001183 48FFC0                           inc rax
   489 00001186 E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   490                                  
   491                                    .rdok:
   492 00001188 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   492 00001191 0000               
   493 00001193 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   493 0000119C 0000               
   494                                  
   495 0000119E 9C                               pushfq
   496 0000119F 418F83E8000000                   pop qword [r11 + 232]
   497                                  
   498 000011A6 49C783F00000003700-              mov qword [r11 + 240], SUGG_PREEM_SLICE  ;推荐的任务执行时间片，来自global_defs.wid
   498 000011AF 0000               
   499                                  
   500 000011B1 E8B9F9FFFF                       call generate_process_id
   501 000011B6 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   502                                  
   503 000011BA E815FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   504                                  
   505 000011BF 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   506                                  
   507 000011C3 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   507 000011CC FF                 
   508 000011CD C78610030000000000-              mov dword [rsi + 0x310], 0
   508 000011D6 00                 
   509 000011D7 C78600030000FE4008-              mov dword [rsi + 0x300], 0x000840fe      ;向所有处理器发送任务认领中断
   509 000011E0 00                 
   510                                  
   511 000011E1 415F                             pop r15
   512 000011E3 415E                             pop r14
   513 000011E5 415D                             pop r13
   514 000011E7 415C                             pop r12
   515 000011E9 415B                             pop r11
   516 000011EB 415A                             pop r10
   517 000011ED 4159                             pop r9
   518 000011EF 4158                             pop r8
   519 000011F1 5D                               pop rbp
   520 000011F2 5F                               pop rdi
   521 000011F3 5E                               pop rsi
   522 000011F4 5A                               pop rdx
   523 000011F5 59                               pop rcx
   524 000011F6 5B                               pop rbx
   525 000011F7 58                               pop rax
   526                                  
   527 000011F8 C3                               ret
   528                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   529                                  syscall_procedure:                                ;系统调用的处理过程
   530                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；进入时中断是禁止状态
   531 000011F9 0F01F8                           swapgs                                   ;切换GS到当前处理器的数据区
   532 000011FC 654889242500000000               mov [gs:0], rsp                          ;临时保存当前的3特权级栈指针
   533 00001205 65488B242584000000               mov rsp, [gs:128+4]                      ;使用TSS的RSP0作为安全栈指针
   534 0000120E 65FF342500000000                 push qword [gs:0]
   535 00001216 0F01F8                           swapgs
   536 00001219 FB                               sti                                      ;准备工作全部完成，中断和任务切换无虞
   537                                  
   538 0000121A 4157                             push r15
   539 0000121C 4C8B3D(08000000)                 mov r15, [rel position]
   540 00001223 4D03BCC7[69020000]               add r15, [r15 + rax * 8 + sys_entry]     ;得到指定的那个系统调用功能的线性地址
   541 0000122B 41FFD7                           call r15
   542 0000122E 415F                             pop r15
   543                                  
   544 00001230 FA                               cli
   545 00001231 5C                               pop rsp                                  ;恢复原先的3特权级栈指针
   546 00001232 480F07                           o64 sysret
   547                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   548                                  init:    ;初始化内核的工作环境
   549                                  
   550                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   551                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   552 00001235 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   552 0000123E FF                 
   553 0000123F 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   554                                  
   555 00001247 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   556                                  
   557                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   558                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   559 0000124F 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   559 00001258 FF                 
   560 00001259 4801C4                           add rsp, rax                             ;栈指针必须转换为高端地址且必须是扩高地址
   561                                  
   562                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   563 0000125C 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   563 00001265 FF                 
   564 00001266 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   565                                  
   566                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   567 0000126D 488B05(08000000)                 mov rax, [rel position]
   568 00001274 4805[7C120000]                   add rax, .to_upper
   569 0000127A FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   570                                  
   571                                    .to_upper:
   572                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   573                                  
   574                                           ;为32个异常创建通用处理过程的中断门
   575 0000127C 4C8B0D(08000000)                 mov r9, [rel position]
   576 00001283 498D81[6C0D0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   577 0000128A E81DEFFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   578                                  
   579 0000128F 4D31C0                           xor r8, r8
   580                                    .idt0:
   581 00001292 E876EFFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   582 00001297 49FFC0                           inc r8
   583 0000129A 4983F81F                         cmp r8, 31
   584 0000129E 7EF2                             jle .idt0
   585                                  
   586                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   587 000012A0 498D81[6A0D0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   588 000012A7 E800EFFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   589                                  
   590 000012AC 41B820000000                     mov r8, 32
   591                                    .idt1:
   592 000012B2 E856EFFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   593 000012B7 49FFC0                           inc r8
   594 000012BA 4981F8FF000000                   cmp r8, 255
   595 000012C1 7EEF                             jle .idt1
   596                                  
   597 000012C3 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   597 000012CC FF                 
   598 000012CD 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   598 000012D6 FF                 
   599 000012D7 4889430E                         mov qword [rbx + 0x0e], rax
   600 000012DB 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   601                                  
   602 000012E1 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   603                                  
   604 000012E5 B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   605 000012E7 E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   606                                  
   607                                           ;在64位模式下显示的第一条信息!
   608 000012E9 4C8B3D(08000000)                 mov r15, [rel position]
   609 000012F0 498D9F[36010000]                 lea rbx, [r15 + welcome]
   610 000012F7 E80CEDFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   611                                  
   612                                           ;安装系统服务（SYSCALL/SYSRET）所需要的代码段和栈段描述符
   613 000012FC 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区SDA的线性地址
   613 00001305 FF                 
   614 00001306 4831DB                           xor rbx, rbx
   615 00001309 66418B5F02                       mov bx, [r15 + 2]                        ;BX=GDT的界限值
   616 0000130E 66FFC3                           inc bx                                   ;BX=GDT的长度
   617 00001311 49035F04                         add rbx, [r15 + 4]                       ;RBX=新描述符的追加位置
   618                                  
   619 00001315 C703FFFF0000                     mov dword [rbx], 0x0000ffff              ;64位模式下不支持64位立即数传送
   620 0000131B C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   621 00001322 C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   622 00001329 C7430C00000000                   mov dword [rbx + 12], 0
   623 00001330 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   624 00001337 C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   625 0000133E C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   626 00001345 C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   627                                  
   628                                           ;我们为每个逻辑处理器都准备一个专属数据区，它是由每个处理器的GS所指向的。
   629                                           ;为当前处理器（BSP）准备专属数据区，设置GS并安装任务状态段TSS的描述符
   630 0000134C B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
   631 00001351 E825F6FFFF                       call core_memory_allocate
   632 00001356 49C7450800000000                 mov qword [r13 + 8], 0                   ;提前将“当前任务的PCB指针域”清零
   633 0000135E 49C7451000000000                 mov qword [r13 + 16], 0                  ;将当前处理器的编号设置为#0
   634 00001366 49896518                         mov [r13 + 24], rsp                      ;设置当前处理器的专属栈
   635 0000136A 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
   636 00001371 E86EEEFFFF                       call make_tss_descriptor
   637 00001376 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   638 0000137A 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   639                                  
   640 0000137E 664183470230                     add word [r15 + 2], 48                   ;4个段描述符和1个TSS描述符的总字节数
   641 00001384 410F015702                       lgdt [r15 + 2]
   642                                  
   643 00001389 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   644 0000138D 0F00D9                           ltr cx
   645                                  
   646                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
   647 00001390 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
   648 00001395 4C89E8                           mov rax, r13                             ;只用EAX
   649 00001398 4C89EA                           mov rdx, r13
   650 0000139B 48C1EA20                         shr rdx, 32                              ;只用EDX
   651 0000139F 0F30                             wrmsr
   652                                  
   653                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   654 000013A1 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   655 000013A6 0F32                             rdmsr
   656 000013A8 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   657 000013AC 0F30                             wrmsr
   658                                  
   659 000013AE B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   660 000013B3 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   661 000013B8 31C0                             xor eax, eax
   662 000013BA 0F30                             wrmsr
   663                                  
   664 000013BC B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   665 000013C1 488B05(08000000)                 mov rax, [rel position]
   666 000013C8 488D80[F9110000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   667 000013CF 4889C2                           mov rdx, rax
   668 000013D2 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   669 000013D6 0F30                             wrmsr
   670                                  
   671 000013D8 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   672 000013DD 31D2                             xor edx, edx
   673 000013DF B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   674 000013E4 0F30                             wrmsr
   675                                  
   676                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   677                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   678                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   679                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   680                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   681                                  
   682                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   683                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   684 000013E6 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   685 000013EF 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   686 000013F1 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   687                                    .looking:
   688 000013F6 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   689 000013FA 741B                             jz .looked
   690 000013FC 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   691 00001400 E2F4                             loop .looking
   692                                  
   693                                    .acpi_err:
   694 00001402 4C8B3D(08000000)                 mov r15, [rel position]
   695 00001409 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   696 00001410 E8F3EBFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   697 00001415 FA                               cli
   698 00001416 F4                               hlt
   699                                  
   700                                    .looked:
   701 00001417 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   702 0000141A 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   703 0000141E 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   704 00001421 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   705                                    .maping:
   706 00001428 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   707 0000142B 4889D8                           mov rax, rbx
   708 0000142E 4821D0                           and rax, rdx
   709 00001431 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   710 00001435 E846F4FFFF                       call mapping_laddr_to_page
   711 0000143A 4881C300100000                   add rbx, 0x1000
   712 00001441 4839CB                           cmp rbx, rcx
   713 00001444 7EE2                             jle .maping
   714                                  
   715                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   716 00001446 BB00000600                       mov rbx, 0x60000
   717 0000144B 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   717 00001454 20                 
   718                                    .searc:
   719 00001455 48390B                           cmp qword [rbx], rcx
   720 00001458 740F                             je .finda
   721 0000145A 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   722 0000145E 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   723 00001465 7CEE                             jl .searc
   724 00001467 EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   725                                  
   726                                    .finda:
   727                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   728                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   729 00001469 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   730 0000146D 752B                             jne .vcpi_1
   731 0000146F 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   732                                  
   733                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   734 00001473 4831FF                           xor rdi, rdi
   735 00001476 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   736 00001479 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   737 0000147C 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   738                                    .madt0:
   739 00001480 4C8B1B                           mov r11, [rbx]
   740 00001483 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   741 0000148A 7436                             je .findm
   742 0000148C 4883C308                         add rbx, 8                               ;下一个元素
   743 00001490 4839FB                           cmp rbx, rdi
   744 00001493 7CEB                             jl .madt0
   745 00001495 E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   746                                  
   747                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   748                                    .vcpi_1:
   749 0000149A 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   750                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   751 0000149D 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   752 000014A1 01DF                             add edi, ebx                             ;计算RSDT上边界的物理位置
   753 000014A3 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   754 000014A6 4D31DB                           xor r11, r11
   755                                    .madt1:
   756 000014A9 67448B1B                         mov r11d, [ebx]
   757 000014AD 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   758 000014B4 740C                             je .findm
   759 000014B6 83C304                           add ebx, 4                               ;下一个元素
   760 000014B9 39FB                             cmp ebx, edi
   761 000014BB 7CEC                             jl .madt1
   762 000014BD E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   763                                  
   764                                    .findm:
   765                                           ;此时，R11是MADT的物理地址
   766 000014C2 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   767 000014C6 8915(28010000)                   mov [rel lapic_addr], edx
   768                                  
   769                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   770 000014CC 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   771 000014D3 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   772                                  
   773 000014DA 4831FF                           xor rdi, rdi
   774 000014DD 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   775 000014E1 4C01DF                           add rdi, r11                             ;RDI:MADT上部边界的物理地址
   776 000014E4 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   777                                    .enumd:
   778 000014E8 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   779 000014EC 7408                             je .l_apic
   780 000014EE 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   781 000014F2 741B                             je .ioapic
   782 000014F4 EB2D                             jmp .m_end
   783                                    .l_apic:
   784 000014F6 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   785 000014FB 7426                             jz .m_end
   786 000014FD 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   787 00001501 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   788 00001504 49FFC7                           inc r15
   789 00001507 FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   790 0000150D EB14                             jmp .m_end
   791                                    .ioapic:
   792 0000150F 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   793 00001513 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   794 00001519 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   795 0000151D 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   796                                     .m_end:
   797 00001523 4831C0                           xor rax, rax
   798 00001526 418A4301                         mov al, [r11 + 1]
   799 0000152A 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   800 0000152D 4939FB                           cmp r11, rdi
   801 00001530 7CB6                             jl .enumd
   802                                  
   803                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   804 00001532 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   804 0000153B FF                 
   805 0000153C 4831C0                           xor rax, rax
   806 0000153F 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   807 00001545 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   808 00001548 E833F3FFFF                       call mapping_laddr_to_page
   809                                  
   810                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   811 0000154D 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   811 00001556 FF                 
   812 00001557 4831C0                           xor rax, rax
   813 0000155A 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   814 00001560 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   815 00001563 E818F3FFFF                       call mapping_laddr_to_page
   816                                  
   817                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   818 00001568 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   818 00001571 FF                 
   819                                  
   820 00001572 C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。
   820 0000157B 00                 
   821                                                                                    ;单次击发（one shot）模式
   822 0000157C C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   822 00001585 00                 
   823                                  
   824 00001586 B00B                             mov al, 0x0b                             ;RTC寄存器B
   825 00001588 0C80                             or al, 0x80                              ;阻断NMI
   826 0000158A E670                             out 0x70, al
   827 0000158C B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   828 0000158E E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   829                                  
   830 00001590 B08A                             mov al, 0x8a                             ;CMOS寄存器A
   831 00001592 E670                             out 0x70, al
   832                                           ;in al, 0x71
   833 00001594 B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   834 00001596 E671                             out 0x71, al                             ;写回CMOS寄存器A
   835                                  
   836 00001598 B08C                             mov al, 0x8c
   837 0000159A E670                             out 0x70, al
   838 0000159C E471                             in al, 0x71                              ;读寄存器C
   839                                    .w0:
   840 0000159E E471                             in al, 0x71                              ;读寄存器C
   841 000015A0 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   842 000015A5 73F7                             jnc .w0
   843 000015A7 C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   843 000015B0 FF                 
   844                                    .w1:
   845 000015B1 E471                             in al, 0x71                              ;读寄存器C
   846 000015B3 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   847 000015B8 73F7                             jnc .w1
   848 000015BA 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
   849                                  
   850 000015C0 B8FFFFFFFF                       mov eax, 0xffff_ffff
   851 000015C5 29D0                             sub eax, edx
   852 000015C7 31D2                             xor edx, edx
   853 000015C9 BB7D000000                       mov ebx, 125                             ;125毫秒
   854 000015CE F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
   855                                  
   856 000015D0 8905(32010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
   857                                  
   858 000015D6 B00B                             mov al, 0x0b                             ;RTC寄存器B
   859 000015D8 0C80                             or al, 0x80                              ;阻断NMI
   860 000015DA E670                             out 0x70, al
   861 000015DC B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
   862 000015DE E671                             out 0x71, al
   863                                  
   864                                           ;以下安装新任务认领中断的处理过程
   865 000015E0 4C8B0D(08000000)                 mov r9, [rel position]
   866 000015E7 498D81[7C0F0000]                 lea rax, [r9 + new_task_notify_handler]  ;得到中断处理过程的线性地址
   867 000015EE E8B9EBFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   868                                  
   869 000015F3 FA                               cli
   870 000015F4 41B8FE000000                     mov r8, 0xfe
   871 000015FA E80EECFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   872 000015FF FB                               sti
   873                                  
   874                                           ;以下安装时间片到期中断的处理过程
   875 00001600 4C8B0D(08000000)                 mov r9, [rel position]
   876 00001607 498D81[BB0E0000]                 lea rax, [r9 + time_slice_out_handler]   ;得到中断处理过程的线性地址
   877 0000160E E899EBFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   878                                  
   879 00001613 FA                               cli
   880 00001614 41B8FD000000                     mov r8, 0xfd
   881 0000161A E8EEEBFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   882 0000161F FB                               sti
   883                                  
   884                                           ;以下开始初始化应用处理器AP。先将初始化代码复制到物理内存最低端的选定位置
   885 00001620 488B35(08000000)                 mov rsi, [rel position]
   886 00001627 488DB6[00000000]                 lea rsi, [rsi + section.ap_init_block.start]
   887 0000162E BF00F00000                       mov rdi, AP_START_UP_ADDR
   888 00001633 B983000000                       mov rcx, ap_init_tail - ap_init
   889 00001638 FC                               cld
   890 00001639 F3A4                             repe movsb
   891                                  
   892                                           ;所有处理器都应当在初始化期间递增应答计数值
   893 0000163B FE05(31010000)                   inc byte [rel ack_cpus]                  ;BSP自己的应答计数值
   894                                  
   895                                           ;给其它处理器发送INIT IPI和SIPI，命令它们初始化自己
   896 00001641 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   896 0000164A FF                 
   897 0000164B C78610030000000000-              mov dword [rsi + 0x310], 0
   897 00001654 00                 
   898 00001655 C7860003000000450C-              mov dword [rsi + 0x300], 0x000c4500      ;先发送INIT IPI
   898 0000165E 00                 
   899 0000165F C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
   899 00001668 00                 
   900 00001669 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
   900 00001672 00                 
   901                                  
   902 00001673 8A05(27000000)                   mov al, [rel num_cpus]
   903                                    .wcpus:
   904 00001679 3A05(31010000)                   cmp al, [rel ack_cpus]
   905 0000167F 75F8                             jne .wcpus                               ;等待所有应用处理器的应答
   906                                  
   907                                           ;显示已应答的处理器的数量信息
   908 00001681 4C8B3D(08000000)                 mov r15, [rel position]
   909                                  
   910 00001688 4D31C0                           xor r8, r8
   911 0000168B 448A05(31010000)                 mov r8b, [rel ack_cpus]
   912 00001692 498D9F[69010000]                 lea rbx, [r15 + buffer]
   913 00001699 E83BF5FFFF                       call bin64_to_dec
   914 0000169E E865E9FFFF                       call put_string64
   915                                  
   916 000016A3 498D9F[58010000]                 lea rbx, [r15 + cpu_init_ok]
   917 000016AA E859E9FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   918                                  
   919                                           ;以下开始创建系统外壳任务（进程）
   920 000016AF 41B832000000                     mov r8, 50
   921 000016B5 E8EDF9FFFF                       call create_process
   922                                  
   923 000016BA E9A8F6FFFF                       jmp ap_to_core_entry.do_idle             ;去处理器集结休息区 :)
   924                                  
   925                                  ;===============================================================================
   926                                  section ap_init_block vstart=0
   927                                  
   928                                           bits 16                                  ;应用处理器AP从实模式开始执行
   929                                  
   930                                  ap_init:                                          ;应用处理器AP的初始化代码
   931 00000000 B8000F                           mov ax, AP_START_UP_ADDR >> 4
   932 00000003 8ED8                             mov ds, ax
   933                                  
   934                                           SET_SPIN_LOCK al, byte [lock_var]        ;自旋直至获得锁
    64                              <1>  %%spin_lock:
    65 00000005 803E[8200]00        <1>  cmp %2, 0
    66 0000000A 7404                <1>  je %%get_lock
    67 0000000C F390                <1>  pause
    68 0000000E EBF5                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00000010 B001                <1>  mov %1, 1
    71 00000012 8606[8200]          <1>  xchg %1, %2
    72 00000016 3C00                <1>  cmp %1, 0
    73 00000018 75EB                <1>  jne %%spin_lock
   935                                  
   936 0000001A B8E007                           mov ax, SDA_PHY_ADDR >> 4                ;切换到系统数据区
   937 0000001D 8ED8                             mov ds, ax
   938                                  
   939                                           ;加载描述符表寄存器GDTR
   940 0000001F 0F01160200                       lgdt [2]                                 ;实模式下只加载6个字节的内容
   941                                  
   942 00000024 E492                             in al, 0x92                              ;南桥芯片内的端口
   943 00000026 0C02                             or al, 0000_0010B
   944 00000028 E692                             out 0x92, al                             ;打开A20
   945                                  
   946 0000002A FA                               cli                                      ;中断机制尚未工作
   947                                  
   948 0000002B 0F20C0                           mov eax, cr0
   949 0000002E 6683C801                         or eax, 1
   950 00000032 0F22C0                           mov cr0, eax                             ;设置PE位
   951                                  
   952                                           ;以下进入保护模式... ...
   953 00000035 EA[3AF0]0800                     jmp 0x0008: AP_START_UP_ADDR + .flush    ;清流水线并串行化处理器
   954                                  
   955                                           [bits 32]
   956                                    .flush:
   957 0000003A B810000000                       mov eax, 0x0010                          ;加载数据段(4GB)选择子
   958 0000003F 8ED0                             mov ss, eax                              ;加载堆栈段(4GB)选择子
   959 00000041 BC007E0000                       mov esp, 0x7e00                          ;堆栈指针
   960                                  
   961                                           ;令CR3寄存器指向4级头表（保护模式下的32位CR3）
   962 00000046 B800A00000                       mov eax, PML4_PHY_ADDR                   ;PCD=PWT=0
   963 0000004B 0F22D8                           mov cr3, eax
   964                                  
   965                                           ;开启物理地址扩展PAE
   966 0000004E 0F20E0                           mov eax, cr4
   967 00000051 0FBAE805                         bts eax, 5
   968 00000055 0F22E0                           mov cr4, eax
   969                                  
   970                                           ;设置型号专属寄存器IA32_EFER.LME，允许IA_32e模式
   971 00000058 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   972 0000005D 0F32                             rdmsr
   973 0000005F 0FBAE808                         bts eax, 8                               ;设置LME位
   974 00000063 0F30                             wrmsr
   975                                  
   976                                           ;开启分页功能
   977 00000065 0F20C0                           mov eax, cr0
   978 00000068 0FBAE81F                         bts eax, 31                              ;置位CR0.PG
   979 0000006C 0F22C0                           mov cr0, eax
   980                                  
   981                                           ;进入64位模式
   982 0000006F EA[76F00000]1800                 jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
   983                                    .to64:
   984                                  
   985                                           bits 64
   986                                  
   987                                           ;转入内核中继续初始化（使用高端线性地址）
   988 00000076 48BB-                            mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
   988 00000078 [440C02000080FFFF] 
   989 00000080 FFE3                             jmp rbx
   990                                  
   991 00000082 00                        lock_var  db 0
   992                                  
   993                                  ap_init_tail:
   994                                  
   995                                  ;===============================================================================
   996                                  section core_tail
   997                                  core_end:
