     1                                  ;c05_core.asm:支持多处理器和高级可编程中断控制器的内核
     2                                  ;李忠，2020-7-6
     3                                  
     4                                  %include "..\common\global_defs.wid"
     5                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     6                              <1> 
     7                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     8                              <1> 
     9                              <1> %ifndef _GLOBAL_DEFS_
    10                              <1>    %define _GLOBAL_DEFS_
    11                              <1> 
    12                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    13                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    14                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    15                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    16                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    17                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    18                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    19                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    20                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    21                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    22                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    23                              <1> 	                                        ;页目录指针表
    24                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    25                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    26                              <1> 
    27                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    28                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    29                              <1> 
    30                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    31                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    32                              <1> 	                                                                ;端起始线性地址
    33                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    34                              <1> 	                                                                ;性地址
    35                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    36                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    37                              <1> 
    38                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    39                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    40                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    41                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    42                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    43                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    44                              <1> 
    45                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    46                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    47                              <1> 			;时的起始地址
    48                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    49                              <1> 			;时的起始地址
    50                              <1> 
    51                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    52                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    53                              <1> 
    54                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    55                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    56                              <1> 
    57                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    58                              <1> 
    59                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    60                              <1> 
    61                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    62                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    63                              <1>             %%spin_lock:
    64                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    65                              <1>                        je %%get_lock      	;获取锁
    66                              <1>                        pause
    67                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    68                              <1>             %%get_lock:
    69                              <1>                        mov %1, 1
    70                              <1>                        xchg %1, %2
    71                              <1>                        cmp %1, 0          	;交换前为零？
    72                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    73                              <1>    %endmacro
    74                              <1> 
    75                              <1> %endif
    76                              <1> 
     5                                  
     6                                  ;===============================================================================
     7                                  section core_header                               ;内核程序头部
     8 00000000 [20120000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     9 00000004 [B10D0000]                init_entry   dd init                            ;#4：内核入口点
    10 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    11                                  
    12                                  ;===============================================================================
    13                                  section core_data                                 ;内核数据段
    14 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    14 00000009 6F7420737570706F72-
    14 00000012 746564206F72206461-
    14 0000001B 7461206572726F722E-
    14 00000024 0D0A00             
    15                                  
    16 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    17 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    18 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    19                                  
    20 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    21 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    22                                  
    23 00000131 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    24                                  
    25 00000135 457865637574696E67-       welcome      db "Executing in 64-bit mode.", 0x0d, 0x0a, 0
    25 0000013E 20696E2036342D6269-
    25 00000147 74206D6F64652E0D0A-
    25 00000150 00                 
    26 00000151 0000000000000000          tss_ptr      dq 0                               ;任务状态段TSS从此处开始
    27                                  
    28 00000159 [FA09000000000000]        sys_entry    dq get_screen_row
    29 00000161 [5F09000000000000]                     dq get_cmos_time
    30 00000169 [DE00000000000000]                     dq put_cstringxy64
    31 00000171 [600C000000000000]                     dq create_process
    32 00000179 [3F0C000000000000]                     dq get_current_pid
    33 00000181 [4B0C000000000000]                     dq terminate_process
    34                                  
    35 00000189 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    36 00000191 0000000000000000          cur_pcb      dq 0                               ;当前任务的PCB线性地址
    37                                  
    38                                  ;===============================================================================
    39                                  section core_code                                 ;内核代码段
    40                                  
    41                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    42                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    43                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    44                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    45                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    46                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    47                              <1> 
    48                              <1> %include "..\common\global_defs.wid"
    49                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    50                              <2> 
    51                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    52                              <2> 
    53                              <2> %ifndef _GLOBAL_DEFS_
    54                              <2>    %define _GLOBAL_DEFS_
    55                              <2> 
    56                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    57                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    58                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    59                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    60                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    61                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    62                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    63                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    64                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    65                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    66                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    67                              <2> 	                                        ;页目录指针表
    68                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    69                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    70                              <2> 
    71                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    72                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    73                              <2> 
    74                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    75                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    76                              <2> 	                                                                ;端起始线性地址
    77                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    78                              <2> 	                                                                ;性地址
    79                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    80                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    81                              <2> 
    82                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    83                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    84                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    85                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    86                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    87                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    88                              <2> 
    89                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    90                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    91                              <2> 			;时的起始地址
    92                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    93                              <2> 			;时的起始地址
    94                              <2> 
    95                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    96                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    97                              <2> 
    98                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    99                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
   100                              <2> 
   101                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
   102                              <2> 
   103                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
   104                              <2> 
   105                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   106                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
   107                              <2>             %%spin_lock:
   108                              <2>                        cmp %2, 0           	;锁是释放状态吗？
   109                              <2>                        je %%get_lock      	;获取锁
   110                              <2>                        pause
   111                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
   112                              <2>             %%get_lock:
   113                              <2>                        mov %1, 1
   114                              <2>                        xchg %1, %2
   115                              <2>                        cmp %1, 0          	;交换前为零？
   116                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
   117                              <2>    %endmacro
   118                              <2> 
   119                              <2> %endif
   120                              <2> 
    49                              <1> 
    50                              <1>          bits 64
    51                              <1> 
    52                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    53                              <1> %ifdef __MP__
    54                              <1> _prn_str_locker dq 0                  	;打印锁
    55                              <1> %endif
    56                              <1> 
    57                              <1> put_string64:       	;显示0终止的字符串并移动光标
    58                              <1>                      	;输入：RBX=字符串的线性地址
    59 00000000 53                  <1>          push rbx
    60 00000001 51                  <1>          push rcx
    61                              <1> 
    62 00000002 9C                  <1>          pushfq     	;-->A
    63 00000003 FA                  <1>          cli
    64                              <1> %ifdef __MP__
    65                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    66                              <1> %endif
    67                              <1> 
    68                              <1>   .getc:
    69 00000004 8A0B                <1>          mov cl, [rbx]
    70 00000006 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    71 00000008 740A                <1>          jz .exit                 	;显示完毕，返回
    72 0000000A E809000000          <1>          call put_char
    73 0000000F 48FFC3              <1>          inc rbx
    74 00000012 EBF0                <1>          jmp .getc
    75                              <1> 
    76                              <1>   .exit:
    77                              <1> %ifdef __MP__
    78                              <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    79                              <1> %endif
    80 00000014 9D                  <1>          popfq                               	;A
    81                              <1> 
    82 00000015 59                  <1>          pop rcx
    83 00000016 5B                  <1>          pop rbx
    84                              <1> 
    85 00000017 C3                  <1>          ret                                	;段内返回
    86                              <1> 
    87                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    88                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
    89                              <1> 	;进光标。
    90                              <1>                                            	;输入：CL=字符ASCII码
    91 00000018 50                  <1>          push rax
    92 00000019 53                  <1>          push rbx
    93 0000001A 51                  <1>          push rcx
    94 0000001B 52                  <1>          push rdx
    95 0000001C 56                  <1>          push rsi
    96 0000001D 57                  <1>          push rdi
    97                              <1> 
    98                              <1>          ;以下取当前光标位置
    99 0000001E 66BAD403            <1>          mov dx, 0x3d4
   100 00000022 B00E                <1>          mov al, 0x0e
   101 00000024 EE                  <1>          out dx, al
   102 00000025 66FFC2              <1>          inc dx                        	;0x3d5
   103 00000028 EC                  <1>          in al, dx                     	;高字
   104 00000029 88C4                <1>          mov ah, al
   105                              <1> 
   106 0000002B 66FFCA              <1>          dec dx                        	;0x3d4
   107 0000002E B00F                <1>          mov al, 0x0f
   108 00000030 EE                  <1>          out dx, al
   109 00000031 66FFC2              <1>          inc dx                        	;0x3d5
   110 00000034 EC                  <1>          in al, dx                     	;低字
   111 00000035 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
   112 00000038 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
   113                              <1> 
   114 0000003F 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
   115 00000042 750E                <1>          jnz .put_0a
   116 00000044 6689D8              <1>          mov ax, bx
   117 00000047 B350                <1>          mov bl, 80
   118 00000049 F6F3                <1>          div bl
   119 0000004B F6E3                <1>          mul bl
   120 0000004D 6689C3              <1>          mov bx, ax
   121 00000050 EB6C                <1>          jmp .set_cursor
   122                              <1> 
   123                              <1>   .put_0a:
   124 00000052 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   125 00000055 7506                <1>          jnz .put_other
   126 00000057 6683C350            <1>          add bx, 80
   127 0000005B EB16                <1>          jmp .roll_screen
   128                              <1> 
   129                              <1>   .put_other:                              	;正常显示字符
   130 0000005D 66D1E3              <1>          shl bx, 1
   131 00000060 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   131 00000069 FF                  <1>
   132 0000006A 880C18              <1>          mov [rax + rbx], cl
   133                              <1> 
   134                              <1>          ;以下将光标位置推进一个字符
   135 0000006D 66D1EB              <1>          shr bx, 1
   136 00000070 66FFC3              <1>          inc bx
   137                              <1> 
   138                              <1>   .roll_screen:
   139 00000073 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   140 00000078 7C44                <1>          jl .set_cursor
   141                              <1> 
   142 0000007A 6653                <1>          push bx
   143                              <1> 
   144 0000007C FC                  <1>          cld
   145 0000007D 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   145 00000086 FF                  <1>
   146 00000087 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   146 00000090 FF                  <1>
   147 00000091 B9E0010000          <1>          mov rcx, 480
   148 00000096 F348A5              <1>          rep movsq
   149 00000099 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   150 0000009D B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   151                              <1>   .cls:
   152 000000A2 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   152 000000AB FF                  <1>
   153 000000AC 66C704182007        <1>          mov word[rax + rbx], 0x0720
   154 000000B2 6683C302            <1>          add bx, 2
   155 000000B6 E2EA                <1>          loop .cls
   156                              <1> 
   157 000000B8 665B                <1>          pop bx
   158 000000BA 6683EB50            <1>          sub bx, 80
   159                              <1> 
   160                              <1>   .set_cursor:
   161 000000BE 66BAD403            <1>          mov dx, 0x3d4
   162 000000C2 B00E                <1>          mov al, 0x0e
   163 000000C4 EE                  <1>          out dx, al
   164 000000C5 66FFC2              <1>          inc dx                         	;0x3d5
   165 000000C8 88F8                <1>          mov al, bh
   166 000000CA EE                  <1>          out dx, al
   167 000000CB 66FFCA              <1>          dec dx       	;0x3d4
   168 000000CE B00F                <1>          mov al, 0x0f
   169 000000D0 EE                  <1>          out dx, al
   170 000000D1 66FFC2              <1>          inc dx       	;0x3d5
   171 000000D4 88D8                <1>          mov al, bl
   172 000000D6 EE                  <1>          out dx, al
   173                              <1> 
   174 000000D7 5F                  <1>          pop rdi
   175 000000D8 5E                  <1>          pop rsi
   176 000000D9 5A                  <1>          pop rdx
   177 000000DA 59                  <1>          pop rcx
   178 000000DB 5B                  <1>          pop rbx
   179 000000DC 58                  <1>          pop rax
   180                              <1> 
   181 000000DD C3                  <1>          ret
   182                              <1> 
   183                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   184                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   185                              <1> ;不同，互不干扰，不需要加锁和互斥。
   186                              <1> %ifdef __MP__
   187                              <1> _prnxy_locker dq 0
   188                              <1> %endif
   189                              <1> 
   190                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   191                              <1>                                           	;DH=行，DL=列
   192                              <1>                                           	;R9B=颜色属性
   193 000000DE 50                  <1>          push rax
   194 000000DF 53                  <1>          push rbx
   195 000000E0 51                  <1>          push rcx
   196 000000E1 52                  <1>          push rdx
   197 000000E2 4150                <1>          push r8
   198                              <1> 
   199                              <1>          ;指定坐标位置在显存内的偏移量
   200 000000E4 88F0                <1>          mov al, dh
   201 000000E6 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   202 000000E8 F6E5                <1>          mul ch
   203 000000EA D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   204 000000EC 6681E2FF00          <1>          and dx, 0x00ff
   205 000000F1 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   206 000000F4 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   207                              <1> 
   208 000000FA 9C                  <1>          pushfq                        	;-->A
   209 000000FB FA                  <1>          cli
   210                              <1> %ifdef __MP__
   211                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   212                              <1> %endif
   213                              <1> 
   214 000000FC 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   214 00000105 FF                  <1>
   215                              <1>   .nextc:
   216 00000106 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   217 00000108 08D2                <1>          or dl, dl
   218 0000010A 7412                <1>          jz .exit
   219 0000010C 41881400            <1>          mov byte [r8 + rax], dl
   220 00000110 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   221 00000115 48FFC3              <1>          inc rbx
   222 00000118 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   223 0000011C EBE8                <1>          jmp .nextc
   224                              <1>   .exit:
   225 0000011E 4D31C0              <1>          xor r8, r8
   226                              <1> %ifdef __MP__
   227                              <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   228                              <1> %endif
   229 00000121 9D                  <1>          popfq                              	;A
   230                              <1> 
   231 00000122 4158                <1>          pop r8
   232 00000124 5A                  <1>          pop rdx
   233 00000125 59                  <1>          pop rcx
   234 00000126 5B                  <1>          pop rbx
   235 00000127 58                  <1>          pop rax
   236                              <1> 
   237 00000128 C3                  <1>          ret
   238                              <1> 
   239                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   240                              <1> make_call_gate:                          	;创建64位的调用门
   241                              <1>                                           	;输入：RAX=例程的线性地址
   242                              <1>                                           	;输出：RDI:RSI=调用门
   243 00000129 4889C7              <1>          mov rdi, rax
   244 0000012C 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   245                              <1> 
   246 00000130 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   247 00000131 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   248 00000138 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   249 0000013C 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   250 00000143 5E                  <1>          pop rsi
   251                              <1> 
   252 00000144 C3                  <1>          ret
   253                              <1> 
   254                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   255                              <1> make_interrupt_gate:                      	;创建64位的中断门
   256                              <1>                                             	;输入：RAX=例程的线性地址
   257                              <1>                                             	;输出：RDI:RSI=中断门
   258 00000145 4889C7              <1>          mov rdi, rax
   259 00000148 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   260                              <1> 
   261 0000014C 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   262 0000014D 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   263 00000154 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   264 00000158 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   265 0000015F 5E                  <1>          pop rsi
   266                              <1> 
   267 00000160 C3                  <1>          ret
   268                              <1> 
   269                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   270                              <1> make_trap_gate:                             	;创建64位的陷阱门
   271                              <1>                                              	;输入：RAX=例程的线性地址
   272                              <1>                                              	;输出：RDI:RSI=陷阱门
   273 00000161 4889C7              <1>          mov rdi, rax
   274 00000164 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   275                              <1> 
   276 00000168 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   277 00000169 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   278 00000170 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   279 00000174 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   280 0000017B 5E                  <1>          pop rsi
   281                              <1> 
   282 0000017C C3                  <1>          ret
   283                              <1> 
   284                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   285                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   286                              <1>                                           	;输入：RAX=TSS的线性地址
   287                              <1>                                           	;输出：RDI:RSI=TSS描述符
   288 0000017D 50                  <1>          push rax
   289                              <1> 
   290 0000017E 4889C7              <1>          mov rdi, rax
   291 00000181 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   292                              <1> 
   293 00000185 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   294 00000186 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   295 0000018B 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   296 00000191 8A442405            <1>          mov al, [rsp + 5]
   297 00000195 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   298 00000199 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   299 0000019E C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   300 000001A3 5E                  <1>          pop rsi                       	;门的低64位
   301                              <1> 
   302 000001A4 58                  <1>          pop rax
   303                              <1> 
   304 000001A5 C3                  <1>          ret
   305                              <1> 
   306                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   307                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   308                              <1>                                        	;R8=中断向量
   309                              <1>                                        	;RDI:RSI=门描述符
   310 000001A6 4150                <1>          push r8
   311 000001A8 4151                <1>          push r9
   312                              <1> 
   313 000001AA 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   314 000001AE 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   314 000001B7 FF                  <1>
   315 000001B8 4B893401            <1>          mov [r9 + r8], rsi
   316 000001BC 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   317                              <1> 
   318 000001C1 4159                <1>          pop r9
   319 000001C3 4158                <1>          pop r8
   320                              <1> 
   321 000001C5 C3                  <1>          ret
   322                              <1> 
   323                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   324                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   325 000001C6 50                  <1>          push rax
   326                              <1> 
   327 000001C7 B011                <1>          mov al, 0x11
   328 000001C9 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   329 000001CB B020                <1>          mov al, 0x20
   330 000001CD E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   331 000001CF B004                <1>          mov al, 0x04
   332 000001D1 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   333 000001D3 B001                <1>          mov al, 0x01
   334 000001D5 E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   335                              <1> 
   336 000001D7 B011                <1>          mov al, 0x11
   337 000001D9 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   338 000001DB B028                <1>          mov al, 0x28
   339 000001DD E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   340 000001DF B002                <1>          mov al, 0x02
   341 000001E1 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   342 000001E3 B001                <1>          mov al, 0x01
   343 000001E5 E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   344                              <1> 
   345 000001E7 58                  <1>          pop rax
   346 000001E8 C3                  <1>          ret
   347                              <1> 
   348                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   349                              <1> %ifdef __MP__
   350                              <1> _read_hdd_locker dq 0                 	;读硬盘锁
   351                              <1> %endif
   352                              <1> 
   353                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   354                              <1>                                         	;RAX=逻辑扇区号
   355                              <1>                                         	;RBX=目标缓冲区线性地址
   356                              <1>                                         	;返回：RBX=RBX+512
   357 000001E9 50                  <1>          push rax
   358 000001EA 51                  <1>          push rcx
   359 000001EB 52                  <1>          push rdx
   360                              <1> 
   361 000001EC 9C                  <1>          pushfq                     	;-->A
   362 000001ED FA                  <1>          cli
   363                              <1> %ifdef __MP__
   364                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   365                              <1> %endif
   366                              <1> 
   367 000001EE 50                  <1>          push rax
   368                              <1> 
   369 000001EF 66BAF201            <1>          mov dx, 0x1f2
   370 000001F3 B001                <1>          mov al, 1
   371 000001F5 EE                  <1>          out dx, al                	;读取的扇区数
   372                              <1> 
   373 000001F6 66FFC2              <1>          inc dx                    	;0x1f3
   374 000001F9 58                  <1>          pop rax
   375 000001FA EE                  <1>          out dx, al               	;LBA地址7~0
   376                              <1> 
   377 000001FB 66FFC2              <1>          inc dx                   	;0x1f4
   378 000001FE B108                <1>          mov cl, 8
   379 00000200 48D3E8              <1>          shr rax, cl
   380 00000203 EE                  <1>          out dx, al   	;LBA地址15~8
   381                              <1> 
   382 00000204 66FFC2              <1>          inc dx       	;0x1f5
   383 00000207 48D3E8              <1>          shr rax, cl
   384 0000020A EE                  <1>          out dx, al  	;LBA地址23~16
   385                              <1> 
   386 0000020B 66FFC2              <1>          inc dx       	;0x1f6
   387 0000020E 48D3E8              <1>          shr rax, cl
   388 00000211 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   389 00000213 EE                  <1>          out dx, al
   390                              <1> 
   391 00000214 66FFC2              <1>          inc dx       	;0x1f7
   392 00000217 B020                <1>          mov al, 0x20 	;读命令
   393 00000219 EE                  <1>          out dx, al
   394                              <1> 
   395                              <1>   .waits:
   396 0000021A EC                  <1>          in al, dx
   397                              <1>          ;and al, 0x88
   398                              <1>          ;cmp al, 0x08
   399 0000021B A808                <1>          test al, 8
   400 0000021D 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   401                              <1> 
   402 0000021F B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   403 00000224 66BAF001            <1>          mov dx, 0x1f0
   404                              <1>   .readw:
   405 00000228 66ED                <1>          in ax, dx
   406 0000022A 668903              <1>          mov [rbx], ax
   407 0000022D 4883C302            <1>          add rbx, 2
   408 00000231 E2F5                <1>          loop .readw
   409                              <1> 
   410                              <1> %ifdef __MP__
   411                              <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   412                              <1> %endif
   413 00000233 9D                  <1>          popfq                              			;A
   414                              <1> 
   415 00000234 5A                  <1>          pop rdx
   416 00000235 59                  <1>          pop rcx
   417 00000236 58                  <1>          pop rax
   418                              <1> 
   419 00000237 C3                  <1>          ret
   420                              <1> 
   421                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   422 00000238 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   423 00000278 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   424                              <1>   _page_map_len  equ $ - _page_bit_map
   425                              <1> 
   426                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   427                              <1>                                             			;输入：无
   428                              <1>                                             			;输出：RAX=页的物理地址
   429 00000638 4831C0              <1>          xor rax, rax
   430                              <1>   .b1:
   431 0000063B F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   432 00000644 730B                <1>          jnc .b2
   433 00000646 48FFC0              <1>          inc rax
   434 00000649 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   435 0000064F 7CEA                <1>          jl .b1
   436                              <1> 
   437                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   438                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   439                              <1>          ;面的换入和换出。
   440                              <1> 
   441                              <1>   .b2:
   442 00000651 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   443                              <1> 
   444 00000655 C3                  <1>          ret
   445                              <1> 
   446                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   447                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   448                              <1>                                      	;输入：R13=线性地址
   449                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   450 00000656 4155                <1>          push r13
   451                              <1> 
   452 00000658 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   452 00000661 00                  <1>
   453 00000662 4D21F5              <1>          and r13, r14
   454 00000665 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   455                              <1> 
   456 00000669 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   457 00000670 4D01EE              <1>          add r14, r13
   458                              <1> 
   459 00000673 415D                <1>          pop r13
   460                              <1> 
   461 00000675 C3                  <1>          ret
   462                              <1> 
   463                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   464                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   465                              <1>                                     	;输入：R13=线性地址
   466                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   467 00000676 4155                <1>          push r13
   468                              <1> 
   469 00000678 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   469 00000681 00                  <1>
   470 00000682 4D21F5              <1>          and r13, r14
   471 00000685 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   472                              <1> 
   473 00000689 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   474 00000690 4D01EE              <1>          add r14, r13
   475                              <1> 
   476 00000693 415D                <1>          pop r13
   477                              <1> 
   478 00000695 C3                  <1>          ret
   479                              <1> 
   480                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   481                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   482                              <1>                                      	;输入：R13=线性地址
   483                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   484 00000696 4155                <1>          push r13
   485                              <1> 
   486 00000698 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   486 000006A1 00                  <1>
   487                              <1> 	                                ;索引部分
   488 000006A2 4D21F5              <1>          and r13, r14
   489 000006A5 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   490                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   491 000006A9 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   492 000006B0 4D01EE              <1>          add r14, r13
   493 000006B3 415D                <1>          pop r13
   494                              <1> 
   495 000006B5 C3                  <1>          ret
   496                              <1> 
   497                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   498                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   499                              <1>                                    	;输入：R13=线性地址
   500                              <1>                                    	;输出：R14=对应的页表项的线性地址
   501 000006B6 4155                <1>          push r13
   502                              <1> 
   503 000006B8 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   503 000006C1 00                  <1>
   504                              <1> 	                                ;索引部分
   505 000006C2 4D21F5              <1>          and r13, r14
   506 000006C5 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   507                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   508 000006C9 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   508 000006D2 FF                  <1>
   509 000006D3 4D01EE              <1>          add r14, r13
   510                              <1> 
   511 000006D6 415D                <1>          pop r13
   512 000006D8 C3                  <1>          ret
   513                              <1> 
   514                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   515                              <1> %ifdef __MP__
   516                              <1> _spaging_locker dq 0
   517                              <1> %endif
   518                              <1> 
   519                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   520                              <1>                                    	;输入：R13=线性地址
   521 000006D9 51                  <1>          push rcx
   522 000006DA 50                  <1>          push rax
   523 000006DB 4156                <1>          push r14
   524                              <1> 
   525 000006DD 9C                  <1>          pushfq                   	;-->A
   526 000006DE FA                  <1>          cli
   527                              <1> %ifdef __MP__
   528                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   529                              <1> %endif
   530                              <1> 
   531                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   532                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   533 000006DF E872FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   534 000006E4 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   535 000006EB 752B                <1>          jnz .b0
   536                              <1> 
   537                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   538 000006ED E846FFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   539 000006F2 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   540 000006F6 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   541                              <1> 
   542                              <1>          ;清空刚分配的页目录指针表
   543 000006F9 E878FFFFFF          <1>          call lin_to_lin_of_pdpte
   544 000006FE 49C1EE0C            <1>          shr r14, 12
   545 00000702 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   546 00000706 B900020000          <1>          mov rcx, 512
   547                              <1>   .cls0:
   548 0000070B 49C70600000000      <1>          mov qword [r14], 0
   549 00000712 4983C608            <1>          add r14, 8
   550 00000716 E2F3                <1>          loop .cls0
   551                              <1> ;-------------------------------------------------
   552                              <1>   .b0:
   553                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   554 00000718 E859FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   555 0000071D 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   556 00000724 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   557                              <1> 
   558                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   559 00000726 E80DFFFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   560 0000072B 4883C807            <1>          or rax, 0x07                  	;添加属性位
   561 0000072F 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   562                              <1> 
   563                              <1>          ;清空刚分配的页目录表
   564 00000732 E85FFFFFFF          <1>          call lin_to_lin_of_pdte
   565 00000737 49C1EE0C            <1>          shr r14, 12
   566 0000073B 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   567 0000073F B900020000          <1>          mov rcx, 512
   568                              <1>   .cls1:
   569 00000744 49C70600000000      <1>          mov qword [r14], 0
   570 0000074B 4983C608            <1>          add r14, 8
   571 0000074F E2F3                <1>          loop .cls1
   572                              <1> ;-------------------------------------------------
   573                              <1>   .b1:
   574                              <1>          ;检查该线性地址所对应的页目录项是否存在
   575 00000751 E840FFFFFF          <1>          call lin_to_lin_of_pdte
   576 00000756 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   577 0000075D 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   578                              <1> 
   579                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   580 0000075F E8D4FEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   581 00000764 4883C807            <1>          or rax, 0x07                      	;添加属性位
   582 00000768 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   583                              <1> 
   584                              <1>          ;清空刚分配的页表
   585 0000076B E846FFFFFF          <1>          call lin_to_lin_of_pte
   586 00000770 49C1EE0C            <1>          shr r14, 12
   587 00000774 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   588 00000778 B900020000          <1>          mov rcx, 512
   589                              <1>   .cls2:
   590 0000077D 49C70600000000      <1>          mov qword [r14], 0
   591 00000784 4983C608            <1>          add r14, 8
   592 00000788 E2F3                <1>          loop .cls2
   593                              <1> ;-------------------------------------------------
   594                              <1>   .b2:
   595                              <1>          ;检查该线性地址所对应的页表项是否存在
   596 0000078A E827FFFFFF          <1>          call lin_to_lin_of_pte
   597 0000078F 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   598 00000796 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   599                              <1> 
   600                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   601 00000798 E89BFEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   602 0000079D 4883C807            <1>          or rax, 0x07                     	;添加属性位
   603 000007A1 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   604                              <1> 
   605                              <1>   .b3:
   606                              <1> %ifdef __MP__
   607                              <1>          mov qword [rel _spaging_locker], 0
   608                              <1> %endif
   609 000007A4 9D                  <1>          popfq                      	;A
   610                              <1> 
   611 000007A5 415E                <1>          pop r14
   612 000007A7 58                  <1>          pop rax
   613 000007A8 59                  <1>          pop rcx
   614                              <1> 
   615 000007A9 C3                  <1>          ret
   616                              <1> 
   617                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   618                              <1> %ifdef __MP__
   619                              <1> _mapping_locker dq 0
   620                              <1> %endif
   621                              <1> 
   622                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   623                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   624                              <1>                                    	;输入：R13=线性地址
   625                              <1>                                                    ;RAX=页的物理地址（含属性）
   626 000007AA 51                  <1>          push rcx
   627 000007AB 4156                <1>          push r14
   628                              <1> 
   629 000007AD 9C                  <1>          pushfq
   630 000007AE FA                  <1>          cli
   631                              <1> %ifdef __MP__
   632                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   633                              <1> %endif
   634                              <1> 
   635 000007AF 50                  <1>          push rax
   636                              <1> 
   637                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   638                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   639 000007B0 E8A1FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   640 000007B5 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   641 000007BC 752B                <1>          jnz .b0
   642                              <1> 
   643                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   644 000007BE E875FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   645 000007C3 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   646 000007C7 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   647                              <1> 
   648                              <1>          ;清空刚分配的页目录指针表
   649 000007CA E8A7FEFFFF          <1>          call lin_to_lin_of_pdpte
   650 000007CF 49C1EE0C            <1>          shr r14, 12
   651 000007D3 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   652 000007D7 B900020000          <1>          mov rcx, 512
   653                              <1>   .cls0:
   654 000007DC 49C70600000000      <1>          mov qword [r14], 0
   655 000007E3 4983C608            <1>          add r14, 8
   656 000007E7 E2F3                <1>          loop .cls0
   657                              <1> ;-------------------------------------------------
   658                              <1>   .b0:
   659                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   660 000007E9 E888FEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   661 000007EE 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   662 000007F5 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   663                              <1> 
   664                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   665 000007F7 E83CFEFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   666 000007FC 4883C807            <1>          or rax, 0x07              	;添加属性位
   667 00000800 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   668                              <1> 
   669                              <1>          ;清空刚分配的页目录表
   670 00000803 E88EFEFFFF          <1>          call lin_to_lin_of_pdte
   671 00000808 49C1EE0C            <1>          shr r14, 12
   672 0000080C 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   673 00000810 B900020000          <1>          mov rcx, 512
   674                              <1>   .cls1:
   675 00000815 49C70600000000      <1>          mov qword [r14], 0
   676 0000081C 4983C608            <1>          add r14, 8
   677 00000820 E2F3                <1>          loop .cls1
   678                              <1> ;-------------------------------------------------
   679                              <1>   .b1:
   680                              <1>          ;检查该线性地址所对应的页目录项是否存在
   681 00000822 E86FFEFFFF          <1>          call lin_to_lin_of_pdte
   682 00000827 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   683 0000082E 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   684                              <1> 
   685                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   686 00000830 E803FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   687 00000835 4883C807            <1>          or rax, 0x07                  	;添加属性位
   688 00000839 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   689                              <1> 
   690                              <1>          ;清空刚分配的页表
   691 0000083C E875FEFFFF          <1>          call lin_to_lin_of_pte
   692 00000841 49C1EE0C            <1>          shr r14, 12
   693 00000845 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   694 00000849 B900020000          <1>          mov rcx, 512
   695                              <1>   .cls2:
   696 0000084E 49C70600000000      <1>          mov qword [r14], 0
   697 00000855 4983C608            <1>          add r14, 8
   698 00000859 E2F3                <1>          loop .cls2
   699                              <1> ;-------------------------------------------------
   700                              <1>   .b2:
   701 0000085B E856FEFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   702 00000860 58                  <1>          pop rax
   703 00000861 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   704                              <1> 
   705                              <1> %ifdef __MP__
   706                              <1>          mov qword [rel _mapping_locker], 0
   707                              <1> %endif
   708 00000864 9D                  <1>          popfq
   709                              <1> 
   710 00000865 415E                <1>          pop r14
   711 00000867 59                  <1>          pop rcx
   712                              <1> 
   713 00000868 C3                  <1>          ret
   714                              <1> 
   715                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   716 00000869 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   717                              <1> 
   718                              <1> %ifdef __MP__
   719                              <1>   _core_alloc_locker dq 0
   720                              <1> %endif
   721                              <1> 
   722                              <1> core_memory_allocate:                 	        ;在虚拟地址空间的高端（内核）分配内存
   723                              <1>                                         	;输入：RCX=请求分配的字节数
   724                              <1>                                         	;输出：R13=本次分配的起始线性地址
   725                              <1>                                         	;      R14=下次分配的起始线性地址
   726 00000871 9C                  <1>          pushfq                        	        ;A-->
   727 00000872 FA                  <1>          cli
   728                              <1> %ifdef __MP__
   729                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   730                              <1> %endif
   731                              <1> 
   732 00000873 4C8B2DEFFFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   733 0000087A 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   734                              <1> 
   735 0000087F 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   736 00000886 740C                <1>          jz .algn
   737 00000888 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   738 0000088C 49C1EE03            <1>          shr r14, 3
   739 00000890 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   740                              <1> 
   741                              <1>   .algn:
   742 00000894 4C8935CEFFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   743                              <1> 
   744                              <1> %ifdef __MP__
   745                              <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   746                              <1> %endif
   747 0000089B 9D                  <1>          popfq                             	;A
   748                              <1> 
   749 0000089C 4155                <1>          push r13
   750 0000089E 4156                <1>          push r14
   751                              <1> 
   752                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   753 000008A0 49C1ED0C            <1>          shr r13, 12
   754 000008A4 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   755 000008A8 49C1EE0C            <1>          shr r14, 12
   756 000008AC 49C1E60C            <1>          shl r14, 12                    	;too
   757                              <1>   .next:
   758 000008B0 E824FEFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   759 000008B5 4981C500100000      <1>          add r13, 0x1000               	;+4096
   760 000008BC 4D39F5              <1>          cmp r13, r14
   761 000008BF 7EEF                <1>          jle .next
   762                              <1> 
   763 000008C1 415E                <1>          pop r14
   764 000008C3 415D                <1>          pop r13
   765                              <1> 
   766 000008C5 C3                  <1>          ret
   767                              <1> 
   768                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   769                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   770                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   771                              <1>                                    	;      RCX=希望分配的字节数
   772                              <1>                                    	;输出：R13=本次分配的起始线性地址
   773                              <1>                                    	;      R14=下次分配的起始线性地址
   774                              <1>          ;获得本次内存分配的起始线性地址
   775 000008C6 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   776 000008CA 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   777                              <1> 
   778 000008CF 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   779 000008D6 740C                <1>          jz .algn
   780 000008D8 49C1EE03            <1>          shr r14, 3
   781 000008DC 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   782 000008E0 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   783                              <1> 
   784                              <1>   .algn:
   785 000008E4 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   786                              <1> 
   787 000008E8 4155                <1>          push r13
   788 000008EA 4156                <1>          push r14
   789                              <1> 
   790                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   791 000008EC 49C1ED0C            <1>          shr r13, 12
   792 000008F0 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   793 000008F4 49C1EE0C            <1>          shr r14, 12
   794 000008F8 49C1E60C            <1>          shl r14, 12                 	;too
   795                              <1>   .next:
   796 000008FC E8D8FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   797 00000901 4981C500100000      <1>          add r13, 0x1000                ;+4096
   798 00000908 4D39F5              <1>          cmp r13, r14
   799 0000090B 7EEF                <1>          jle .next
   800                              <1> 
   801 0000090D 415E                <1>          pop r14
   802 0000090F 415D                <1>          pop r13
   803                              <1> 
   804 00000911 C3                  <1>          ret
   805                              <1> 
   806                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   807                              <1> %ifdef __MP__
   808                              <1> _copy_locker dq 0
   809                              <1> %endif
   810                              <1> 
   811                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   812                              <1>                                         	;输入：无
   813                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   814 00000912 56                  <1>          push rsi
   815 00000913 57                  <1>          push rdi
   816 00000914 4155                <1>          push r13
   817 00000916 51                  <1>          push rcx
   818                              <1> 
   819 00000917 9C                  <1>          pushfq                                   	;-->A
   820 00000918 FA                  <1>          cli
   821                              <1> %ifdef __MP__
   822                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   823                              <1> %endif
   824                              <1> 
   825 00000919 E81AFDFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   826 0000091E 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   827 00000922 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   827 0000092B FF                  <1>
   828 0000092C E879FEFFFF          <1>          call mapping_laddr_to_page
   829                              <1> 
   830                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   831 00000931 410F017D00          <1>          invlpg [r13]
   832                              <1> 
   833 00000936 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   834 0000093D 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   835 00000940 B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   836 00000945 FC                  <1>          cld
   837 00000946 F348A5              <1>          repe movsq
   838                              <1> 
   839 00000949 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   840 00000950 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   841                              <1> 
   842                              <1> %ifdef __MP__
   843                              <1>          mov qword [rel _copy_locker], 0
   844                              <1> %endif
   845 00000958 9D                  <1>          popfq                    	;A
   846                              <1> 
   847 00000959 59                  <1>          pop rcx
   848 0000095A 415D                <1>          pop r13
   849 0000095C 5F                  <1>          pop rdi
   850 0000095D 5E                  <1>          pop rsi
   851                              <1> 
   852 0000095E C3                  <1>          ret
   853                              <1> 
   854                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   855                              <1> %ifdef __MP__
   856                              <1> _cmos_locker dq 0
   857                              <1> %endif
   858                              <1> 
   859                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   860                              <1>                                        	;输入：RBX=缓冲区线性地址
   861 0000095F 50                  <1>          push rax
   862                              <1> 
   863 00000960 9C                  <1>          pushfq                       	;-->A
   864 00000961 FA                  <1>          cli
   865                              <1> %ifdef __MP__
   866                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   867                              <1> %endif
   868                              <1> 
   869                              <1>   .w0:
   870 00000962 B08A                <1>          mov al, 0x8a
   871 00000964 E670                <1>          out 0x70, al
   872 00000966 E471                <1>          in al, 0x71                 	;读寄存器A
   873 00000968 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   874 0000096A 75F6                <1>          jnz .w0
   875                              <1> 
   876 0000096C B084                <1>          mov al, 0x84
   877 0000096E E670                <1>          out 0x70, al
   878 00000970 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   879 00000972 88C4                <1>          mov ah, al
   880                              <1> 
   881 00000974 C0EC04              <1>          shr ah, 4
   882 00000977 80E40F              <1>          and ah, 0x0f
   883 0000097A 80C430              <1>          add ah, 0x30
   884 0000097D 8823                <1>          mov [rbx], ah
   885                              <1> 
   886 0000097F 240F                <1>          and al, 0x0f
   887 00000981 0430                <1>          add al, 0x30
   888 00000983 884301              <1>          mov [rbx + 1], al
   889                              <1> 
   890 00000986 C643023A            <1>          mov byte [rbx + 2], ':'
   891                              <1> 
   892 0000098A B082                <1>          mov al, 0x82
   893 0000098C E670                <1>          out 0x70, al
   894 0000098E E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   895 00000990 88C4                <1>          mov ah, al
   896                              <1> 
   897 00000992 C0EC04              <1>          shr ah, 4
   898 00000995 80E40F              <1>          and ah, 0x0f
   899 00000998 80C430              <1>          add ah, 0x30
   900 0000099B 886303              <1>          mov [rbx + 3], ah
   901                              <1> 
   902 0000099E 240F                <1>          and al, 0x0f
   903 000009A0 0430                <1>          add al, 0x30
   904 000009A2 884304              <1>          mov [rbx + 4], al
   905                              <1> 
   906 000009A5 C643053A            <1>          mov byte [rbx + 5], ':'
   907                              <1> 
   908 000009A9 B080                <1>          mov al, 0x80
   909 000009AB E670                <1>          out 0x70, al
   910 000009AD E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   911 000009AF 88C4                <1>          mov ah, al              	;分拆成两个数字
   912                              <1> 
   913 000009B1 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   914 000009B4 80E40F              <1>          and ah, 0x0f
   915 000009B7 80C430              <1>          add ah, 0x30
   916 000009BA 886306              <1>          mov [rbx + 6], ah
   917                              <1> 
   918 000009BD 240F                <1>          and al, 0x0f               	;仅保留低4位
   919 000009BF 0430                <1>          add al, 0x30               	;转换成ASCII
   920 000009C1 884307              <1>          mov [rbx + 7], al
   921                              <1> 
   922 000009C4 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   923                              <1> 
   924                              <1> %ifdef __MP__
   925                              <1>          mov qword [rel _cmos_locker], 0
   926                              <1> %endif
   927 000009C8 9D                  <1>          popfq                	;A
   928                              <1> 
   929 000009C9 58                  <1>          pop rax
   930                              <1> 
   931 000009CA C3                  <1>          ret
   932                              <1> 
   933                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   934 000009CB 0000000000000000    <1>   _process_id        dq 0
   935                              <1> 
   936                              <1> generate_process_id:                  	;生成唯一的进程标识
   937                              <1>                                         	;返回：RAX=进程标识
   938 000009D3 B801000000          <1>          mov rax, 1
   939 000009D8 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   940                              <1> 
   941 000009E1 C3                  <1>          ret
   942                              <1> 
   943                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   944 000009E2 0000000000000000    <1>   _thread_id dq 0
   945                              <1> 
   946                              <1> generate_thread_id:                 	;生成唯一的线程标识
   947                              <1>                                       	;返回：RAX=线程标识
   948 000009EA B801000000          <1>          mov rax, 1
   949 000009EF F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   950                              <1> 
   951 000009F8 C3                  <1>          ret
   952                              <1> 
   953                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   954 000009F9 08                  <1>   _screen_row        db 8
   955                              <1> 
   956                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   957                              <1>                                      	;返回：DH=行号
   958 000009FA B601                <1>          mov dh, 1
   959 000009FC F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   960                              <1> 
   961 00000A04 C3                  <1>          ret
   962                              <1> 
   963                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   964                              <1> get_cpu_number:                        	;返回当前处理器的编号
   965                              <1>                                         	;返回：RAX=处理器编号
   966 00000A05 9C                  <1>          pushfq
   967 00000A06 FA                  <1>          cli
   968 00000A07 0F01F8              <1>          swapgs
   969 00000A0A 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   970 00000A13 0F01F8              <1>          swapgs
   971 00000A16 9D                  <1>          popfq
   972 00000A17 C3                  <1>          ret
   973                              <1> 
   974                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   975                              <1> memory_allocate:                       	;用户空间的内存分配
   976                              <1>                                          	;进入：RDX=期望分配的字节数
   977                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   978 00000A18 51                  <1>          push rcx
   979 00000A19 4153                <1>          push r11
   980 00000A1B 4156                <1>          push r14
   981                              <1> 
   982 00000A1D 9C                  <1>          pushfq
   983 00000A1E FA                  <1>          cli
   984 00000A1F 0F01F8              <1>          swapgs
   985 00000A22 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
   986 00000A2B 0F01F8              <1>          swapgs
   987 00000A2E 9D                  <1>          popfq
   988                              <1> 
   989 00000A2F 4889D1              <1>          mov rcx, rdx
   990 00000A32 E88FFEFFFF          <1>          call user_memory_allocate
   991                              <1> 
   992 00000A37 415E                <1>          pop r14
   993 00000A39 415B                <1>          pop r11
   994 00000A3B 59                  <1>          pop rcx
   995                              <1> 
   996 00000A3C C3                  <1>          ret
   997                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    42                                  
    43                                           bits 64
    44                                  
    45                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    46                                  general_interrupt_handler:                        ;通用中断处理过程
    47 00000A3D 48CF                             iretq
    48                                  
    49                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    50                                  general_exception_handler:                        ;通用异常处理过程
    51                                                                                    ;在24行0列显示红底白字的错误信息
    52 00000A3F 4C8B3D(08000000)                 mov r15, [rel position]
    53 00000A46 498D9F[5B0A0000]                 lea rbx, [r15 + exceptm]
    54 00000A4D B618                             mov dh, 24
    55 00000A4F B200                             mov dl, 0
    56 00000A51 41B14F                           mov r9b, 0x4f
    57 00000A54 E885F6FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
    58                                  
    59 00000A59 FA                               cli
    60 00000A5A F4                               hlt                                      ;停机且不接受外部硬件中断
    61                                  
    62 00000A5B 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
    62 00000A64 6F6E20726169736564-
    62 00000A6D 2C68616C742E00     
    63                                  
    64                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    65                                  general_8259ints_handler:                         ;通用的8259中断处理过程
    66 00000A74 50                               push rax
    67                                  
    68 00000A75 B020                             mov al, 0x20                             ;中断结束命令EOI
    69 00000A77 E6A0                             out 0xa0, al                             ;向从片发送
    70 00000A79 E620                             out 0x20, al                             ;向主片发送
    71                                  
    72 00000A7B 58                               pop rax
    73                                  
    74 00000A7C 48CF                             iretq
    75                                  
    76                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    77                                  rtm_interrupt_handle:                             ;实时时钟中断处理过程（任务切换）
    78 00000A7E 4150                             push r8
    79 00000A80 50                               push rax
    80 00000A81 53                               push rbx
    81                                  
    82                                           ;mov al, 0x20                             ;中断结束命令EOI
    83                                           ;out 0xa0, al                             ;向8259A从片发送
    84                                           ;out 0x20, al                             ;向8259A主片发送
    85                                  
    86 00000A82 B00C                             mov al, 0x0c                             ;寄存器C的索引。且开放NMI
    87 00000A84 E670                             out 0x70, al
    88 00000A86 E471                             in al, 0x71                              ;读一下RTC的寄存器C，否则只发生一次中断
    89                                                                                    ;此处不考虑闹钟和周期性中断的情况
    90                                  
    91                                           ;除非是NMI、SMI、INIT、ExtINT、SIPI或者INIT-Deassert引发的中断，中断处理过程必须
    92                                           ;包含一条写EOI寄存器的指令
    93 00000A88 49B800E0FFFF7FFFFF-              mov r8, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
    93 00000A91 FF                 
    94 00000A92 41C780B00000000000-              mov dword [r8 + 0xb0], 0
    94 00000A9B 0000               
    95                                  
    96                                           ;以下开始执行任务切换
    97                                           ;任务切换的原理是，它发生在所有任务的全局空间。在任务A的全局空间执行任务
    98                                           ;切换，切换到任务B，实际上也是从任务B的全局空间返回任务B的私有空间。
    99                                  
   100                                           ;从PCB链表中寻找就绪的任务。
   101 00000A9D 4C8B05(91010000)                 mov r8, [rel cur_pcb]                    ;定位到当前任务的PCB节点
   102 00000AA4 4983F800                         cmp r8, 0                                ;系统中尚未确立当前任务？
   103 00000AA8 0F844E010000                     jz .return                               ;是。未找到就绪任务（节点），返回
   104                                    .again:
   105 00000AAE 4D8B8018010000                   mov r8, [r8 + 280]                       ;取得下一个节点
   106 00000AB5 4C3B05(91010000)                 cmp r8, [rel cur_pcb]                    ;是否转一圈回到当前节点？
   107 00000ABC 0F843A010000                     jz .return                               ;是。未找到就绪任务（节点），返回
   108 00000AC2 4983781000                       cmp qword [r8 + 16], 0                   ;是就绪任务（节点）？
   109 00000AC7 7402                             jz .found                                ;是。转任务切换
   110 00000AC9 EBE3                             jmp .again
   111                                  
   112                                    .found:
   113 00000ACB 488B05(91010000)                 mov rax, [rel cur_pcb]                   ;取得当前任务的PCB（线性地址）
   114 00000AD2 4883781002                       cmp qword [rax + 16], 2                  ;当前任务有可能已经被标记为终止。
   115 00000AD7 0F8480000000                     jz .restore
   116                                  
   117                                           ;保存当前任务的状态以便将来恢复执行
   118 00000ADD 0F20DB                           mov rbx, cr3
   119 00000AE0 48895838                         mov [rax + 56], rbx
   120                                  
   121 00000AE4 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
   122                                           ;mov [rax + 64], rax                     ;不需设置，将来恢复执行时从栈中弹出
   123                                           ;mov [rax + 72], rbx                     ;不需设置，将来恢复执行时从栈中弹出
   124 00000AEC 48894850                         mov [rax + 80], rcx
   125 00000AF0 48895058                         mov [rax + 88], rdx
   126 00000AF4 48897060                         mov [rax + 96], rsi
   127 00000AF8 48897868                         mov [rax + 104], rdi
   128 00000AFC 48896870                         mov [rax + 112], rbp
   129 00000B00 48896078                         mov [rax + 120], rsp
   130                                           ;mov [rax + 128], r8                     ;不需设置，将来恢复执行时从栈中弹出
   131 00000B04 4C898888000000                   mov [rax + 136], r9
   132 00000B0B 4C899090000000                   mov [rax + 144], r10
   133 00000B12 4C899898000000                   mov [rax + 152], r11
   134 00000B19 4C89A0A0000000                   mov [rax + 160], r12
   135 00000B20 4C89A8A8000000                   mov [rax + 168], r13
   136 00000B27 4C89B0B0000000                   mov [rax + 176], r14
   137 00000B2E 4C89B8B8000000                   mov [rax + 184], r15
   138 00000B35 488B1D(08000000)                 mov rbx, [rel position]
   139 00000B3C 488D9B[FC0B0000]                 lea rbx, [rbx + .return]
   140 00000B43 488998C0000000                   mov [rax + 192], rbx                     ;RIP为中断返回点
   141 00000B4A 8C88C8000000                     mov [rax + 200], cs
   142 00000B50 8C90D0000000                     mov [rax + 208], ss
   143 00000B56 9C                               pushfq
   144 00000B57 8F80E8000000                     pop qword [rax + 232]
   145                                  
   146                                    .restore:
   147                                           ;恢复新任务的状态
   148 00000B5D 4C8905(91010000)                 mov [rel cur_pcb], r8                    ;将新任务设置为当前任务
   149 00000B64 49C7401001000000                 mov qword [r8 + 16], 1                   ;置任务状态为忙
   150                                  
   151 00000B6C 498B4020                         mov rax, [r8 + 32]                       ;取PCB中的RSP0
   152 00000B70 488B1D(51010000)                 mov rbx, [rel tss_ptr]
   153 00000B77 48894304                         mov [rbx + 4], rax                       ;置TSS的RSP0
   154                                  
   155 00000B7B 498B4038                         mov rax, [r8 + 56]
   156 00000B7F 0F22D8                           mov cr3, rax                             ;切换地址空间
   157                                  
   158 00000B82 498B4040                         mov rax, [r8 + 64]
   159 00000B86 498B5848                         mov rbx, [r8 + 72]
   160 00000B8A 498B4850                         mov rcx, [r8 + 80]
   161 00000B8E 498B5058                         mov rdx, [r8 + 88]
   162 00000B92 498B7060                         mov rsi, [r8 + 96]
   163 00000B96 498B7868                         mov rdi, [r8 + 104]
   164 00000B9A 498B6870                         mov rbp, [r8 + 112]
   165 00000B9E 498B6078                         mov rsp, [r8 + 120]
   166 00000BA2 4D8B8888000000                   mov r9, [r8 + 136]
   167 00000BA9 4D8B9090000000                   mov r10, [r8 + 144]
   168 00000BB0 4D8B9898000000                   mov r11, [r8 + 152]
   169 00000BB7 4D8BA0A0000000                   mov r12, [r8 + 160]
   170 00000BBE 4D8BA8A8000000                   mov r13, [r8 + 168]
   171 00000BC5 4D8BB0B0000000                   mov r14, [r8 + 176]
   172 00000BCC 4D8BB8B8000000                   mov r15, [r8 + 184]
   173 00000BD3 41FFB0D0000000                   push qword [r8 + 208]                    ;SS
   174 00000BDA 41FF7078                         push qword [r8 + 120]                    ;RSP
   175 00000BDE 41FFB0E8000000                   push qword [r8 + 232]                    ;RFLAGS
   176 00000BE5 41FFB0C8000000                   push qword [r8 + 200]                    ;CS
   177 00000BEC 41FFB0C0000000                   push qword [r8 + 192]                    ;RIP
   178                                  
   179 00000BF3 4D8B8080000000                   mov r8, [r8 + 128]                       ;恢复R8的值
   180                                  
   181 00000BFA 48CF                             iretq                                    ;转入新任务局部空间执行
   182                                  
   183                                    .return:
   184 00000BFC 5B                               pop rbx
   185 00000BFD 58                               pop rax
   186 00000BFE 4158                             pop r8
   187                                  
   188 00000C00 48CF                             iretq
   189                                  
   190                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   191                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   192                                                                                    ;输入：R11=PCB线性基地址
   193 00000C02 50                               push rax
   194 00000C03 53                               push rbx
   195                                  
   196 00000C04 FA                               cli
   197                                  
   198 00000C05 488B1D(89010000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   199 00000C0C 4809DB                           or rbx, rbx
   200 00000C0F 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   201 00000C11 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   202 00000C14 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   203 00000C1B 4C891D(89010000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   204 00000C22 EB17                             jmp .return
   205                                  
   206                                    .not_empty:
   207 00000C24 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   208                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   209 00000C27 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   210 00000C2E 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   211 00000C35 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   212 00000C38 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   213                                  
   214                                    .return:
   215 00000C3B FB                               sti
   216                                  
   217 00000C3C 5B                               pop rbx
   218 00000C3D 58                               pop rax
   219                                  
   220 00000C3E C3                               ret
   221                                  
   222                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   223                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   224 00000C3F 488B05(91010000)                 mov rax, [rel cur_pcb]
   225 00000C46 488B4008                         mov rax, [rax + 8]
   226                                  
   227 00000C4A C3                               ret
   228                                  
   229                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   230                                  terminate_process:                                ;终止当前任务
   231 00000C4B FA                               cli                                      ;执行流改变期间禁止时钟中断引发的任务切换
   232                                  
   233 00000C4C 488B05(91010000)                 mov rax, [rel cur_pcb]                   ;定位到当前任务的PCB节点
   234 00000C53 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   235                                  
   236 00000C5B E91EFEFFFF                       jmp rtm_interrupt_handle                 ;强制任务调度，交还处理器控制权
   237                                  
   238                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   239                                  create_process:                                   ;创建新的任务
   240                                                                                    ;输入：R8=程序的起始逻辑扇区号
   241 00000C60 50                               push rax
   242 00000C61 53                               push rbx
   243 00000C62 51                               push rcx
   244 00000C63 52                               push rdx
   245 00000C64 56                               push rsi
   246 00000C65 57                               push rdi
   247 00000C66 55                               push rbp
   248 00000C67 4150                             push r8
   249 00000C69 4151                             push r9
   250 00000C6B 4152                             push r10
   251 00000C6D 4153                             push r11
   252 00000C6F 4154                             push r12
   253 00000C71 4155                             push r13
   254 00000C73 4156                             push r14
   255 00000C75 4157                             push r15
   256                                  
   257                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   258 00000C77 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   259 00000C7C E8F0FBFFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   260                                  
   261 00000C81 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   262                                  
   263 00000C84 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   264                                  
   265                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   266 00000C8C E881FCFFFF                       call copy_current_pml4
   267 00000C91 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   268                                  
   269                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   270                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   271                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈位于地址空间高端的栈。
   272 00000C95 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   273 00000C99 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   274                                  
   275                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   276 00000C9C 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   277 00000CA3 B900010000                       mov rcx, 256
   278                                    .clsp:
   279 00000CA8 48C70000000000                   mov qword [rax], 0
   280 00000CAF 4883C008                         add rax, 8
   281 00000CB3 E2F3                             loop .clsp
   282                                  
   283 00000CB5 0F20D8                           mov rax, cr3                             ;刷新TLB
   284 00000CB8 0F22D8                           mov cr3, rax
   285                                  
   286 00000CBB B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   287 00000CC0 E8ACFBFFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   288 00000CC5 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   289                                  
   290 00000CC9 B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   291 00000CCE E8F3FBFFFF                       call user_memory_allocate
   292 00000CD3 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   293                                  
   294 00000CD7 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   295                                  
   296                                           ;以下开始加载用户程序
   297 00000CDF B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   298 00000CE4 E8DDFBFFFF                       call user_memory_allocate
   299 00000CE9 4C89EB                           mov rbx, r13
   300 00000CEC 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   301 00000CEF E8F5F4FFFF                       call read_hard_disk_0
   302                                  
   303 00000CF4 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   304 00000CF8 4D89EE                           mov r14, r13
   305 00000CFB 4D037508                         add r14, [r13 + 8]
   306 00000CFF 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   307                                  
   308                                           ;以下判断整个程序有多大
   309 00000D06 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   310 00000D0A 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   311 00000D11 740F                             jz .y512
   312 00000D13 48C1E909                         shr rcx, 9                               ;不能？凑整。
   313 00000D17 48C1E109                         shl rcx, 9
   314 00000D1B 4881C100020000                   add rcx, 512
   315                                    .y512:
   316 00000D22 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   317 00000D29 7416                             jz .rdok
   318 00000D2B E896FBFFFF                       call user_memory_allocate
   319                                           ;mov rbx, r13
   320 00000D30 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   321 00000D34 48FFC0                           inc rax                                  ;起始扇区号
   322                                    .b1:
   323 00000D37 E8ADF4FFFF                       call read_hard_disk_0
   324 00000D3C 48FFC0                           inc rax
   325 00000D3F E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   326                                  
   327                                    .rdok:
   328 00000D41 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   328 00000D4A 0000               
   329 00000D4C 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   329 00000D55 0000               
   330                                  
   331 00000D57 9C                               pushfq
   332 00000D58 418F83E8000000                   pop qword [r11 + 232]
   333                                  
   334 00000D5F E86FFCFFFF                       call generate_process_id
   335 00000D64 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   336                                  
   337 00000D68 E895FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   338                                  
   339 00000D6D 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   340                                  
   341 00000D71 415F                             pop r15
   342 00000D73 415E                             pop r14
   343 00000D75 415D                             pop r13
   344 00000D77 415C                             pop r12
   345 00000D79 415B                             pop r11
   346 00000D7B 415A                             pop r10
   347 00000D7D 4159                             pop r9
   348 00000D7F 4158                             pop r8
   349 00000D81 5D                               pop rbp
   350 00000D82 5F                               pop rdi
   351 00000D83 5E                               pop rsi
   352 00000D84 5A                               pop rdx
   353 00000D85 59                               pop rcx
   354 00000D86 5B                               pop rbx
   355 00000D87 58                               pop rax
   356                                  
   357 00000D88 C3                               ret
   358                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   359                                  syscall_procedure:                                ;系统调用的处理过程
   360                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；RBP和R15由此例程占用。如
   361                                           ;有必要，请用户程序在调用syscall前保存它们，在系统调用返回后自行恢复。
   362 00000D89 4889E5                           mov rbp, rsp
   363 00000D8C 4C8B3D(51010000)                 mov r15, [rel tss_ptr]
   364 00000D93 498B6704                         mov rsp, [r15 + 4]                       ;使用TSS的RSP0作为安全栈
   365                                  
   366 00000D97 FB                               sti
   367                                  
   368 00000D98 4C8B3D(08000000)                 mov r15, [rel position]
   369 00000D9F 4D03BCC7[59010000]               add r15, [r15 + rax * 8 + sys_entry]
   370 00000DA7 41FFD7                           call r15
   371                                  
   372 00000DAA FA                               cli
   373 00000DAB 4889EC                           mov rsp, rbp                             ;还原到用户程序的栈
   374 00000DAE 480F07                           o64 sysret
   375                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   376                                  init:    ;初始化内核的工作环境
   377                                  
   378                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   379                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   380 00000DB1 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   380 00000DBA FF                 
   381 00000DBB 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   382                                  
   383 00000DC3 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   384                                  
   385                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   386                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   387 00000DCB 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   387 00000DD4 FF                 
   388 00000DD5 4801C4                           add rsp,rax                              ;栈指针必须转换为高端地址且必须是扩高地址
   389                                  
   390                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   391 00000DD8 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   391 00000DE1 FF                 
   392 00000DE2 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   393                                  
   394                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   395 00000DE9 488B05(08000000)                 mov rax, [rel position]
   396 00000DF0 4805[F80D0000]                   add rax, .to_upper
   397 00000DF6 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   398                                  
   399                                    .to_upper:
   400                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   401                                  
   402                                           ;为32个异常创建通用处理过程的中断门
   403 00000DF8 4C8B0D(08000000)                 mov r9, [rel position]
   404 00000DFF 498D81[3F0A0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   405 00000E06 E83AF3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   406                                  
   407 00000E0B 4D31C0                           xor r8, r8
   408                                    .idt0:
   409 00000E0E E893F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   410 00000E13 49FFC0                           inc r8
   411 00000E16 4983F81F                         cmp r8, 31
   412 00000E1A 7EF2                             jle .idt0
   413                                  
   414                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   415 00000E1C 498D81[3D0A0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   416 00000E23 E81DF3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   417                                  
   418 00000E28 41B820000000                     mov r8, 32
   419                                    .idt1:
   420 00000E2E E873F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   421 00000E33 49FFC0                           inc r8
   422 00000E36 4981F8FF000000                   cmp r8, 255
   423 00000E3D 7EEF                             jle .idt1
   424                                  
   425 00000E3F 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   425 00000E48 FF                 
   426 00000E49 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   426 00000E52 FF                 
   427 00000E53 4889430E                         mov qword [rbx + 0x0e], rax
   428 00000E57 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   429                                  
   430 00000E5D 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   431                                  
   432                                           ;初始化8259中断控制器，包括重新设置中断向量号
   433 00000E61 E860F3FFFF                       call init_8259
   434                                  
   435                                           ;创建并安装16个8259中断处理过程的中断门，向量0x20--0x2f
   436 00000E66 498D81[740A0000]                 lea rax, [r9 + general_8259ints_handler] ;得到通用8259中断处理过程的线性地址
   437 00000E6D E8D3F2FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   438                                  
   439 00000E72 41B820000000                     mov r8, 0x20
   440                                    .8259:
   441 00000E78 E829F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   442 00000E7D 49FFC0                           inc r8
   443 00000E80 4983F82F                         cmp r8, 0x2f
   444 00000E84 7EF2                             jle .8259
   445                                  
   446 00000E86 FB                               sti                                      ;开放硬件中断
   447                                  
   448                                           ;在64位模式下显示的第一条信息!
   449 00000E87 4C8B3D(08000000)                 mov r15, [rel position]
   450 00000E8E 498D9F[35010000]                 lea rbx, [r15 + welcome]
   451 00000E95 E866F1FFFF                       call put_string64                        ;位于core_utils64.wid
   452                                           ;----------------------------------------------------------------------
   453                                           ;安装系统服务所需要的代码段和栈段描述符
   454 00000E9A 4883EC10                         sub rsp, 16                              ;开辟16字节的空间操作GDT和GDTR
   455 00000E9E 0F010424                         sgdt [rsp]
   456 00000EA2 4831DB                           xor rbx, rbx
   457 00000EA5 668B1C24                         mov bx, [rsp]                            ;得到GDT的界限值
   458 00000EA9 66FFC3                           inc bx                                   ;得到GDT的长度（字节数）
   459 00000EAC 48035C2402                       add rbx, [rsp + 2]
   460                                           ;以下，处理器不支持从64位立即数到内存之间的传送!!!
   461 00000EB1 C703FFFF0000                     mov dword [rbx], 0x0000ffff
   462 00000EB7 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   463 00000EBE C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   464 00000EC5 C7430C00000000                   mov dword [rbx + 12], 0
   465 00000ECC C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   466 00000ED3 C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   467 00000EDA C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   468 00000EE1 C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   469                                  
   470                                           ;安装任务状态段TSS的描述符
   471 00000EE8 B968000000                       mov rcx, 104                             ;TSS的标准长度
   472 00000EED E87FF9FFFF                       call core_memory_allocate
   473 00000EF2 4C892D(51010000)                 mov [rel tss_ptr], r13
   474 00000EF9 4C89E8                           mov rax, r13
   475 00000EFC E87CF2FFFF                       call make_tss_descriptor
   476 00000F01 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   477 00000F05 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   478                                  
   479 00000F09 6683042430                       add word [rsp], 48                       ;4个段描述符和1个TSS描述符的总字节数
   480 00000F0E 0F011424                         lgdt [rsp]
   481 00000F12 4883C410                         add rsp, 16                              ;恢复栈平衡
   482                                  
   483 00000F16 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   484 00000F1A 0F00D9                           ltr cx
   485                                  
   486                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   487 00000F1D B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   488 00000F22 0F32                             rdmsr
   489 00000F24 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   490 00000F28 0F30                             wrmsr
   491                                  
   492 00000F2A B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   493 00000F2F BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   494 00000F34 31C0                             xor eax, eax
   495 00000F36 0F30                             wrmsr
   496                                  
   497 00000F38 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   498 00000F3D 488B05(08000000)                 mov rax, [rel position]
   499 00000F44 488D80[890D0000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   500 00000F4B 4889C2                           mov rdx, rax
   501 00000F4E 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   502 00000F52 0F30                             wrmsr
   503                                  
   504 00000F54 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   505 00000F59 31D2                             xor edx, edx
   506 00000F5B B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   507 00000F60 0F30                             wrmsr
   508                                  
   509                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   510                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   511                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   512                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   513                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   514                                  
   515                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   516                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   517 00000F62 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   518 00000F6B 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   519 00000F6D BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   520                                    .looking:
   521 00000F72 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   522 00000F76 741B                             jz .looked
   523 00000F78 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   524 00000F7C E2F4                             loop .looking
   525                                  
   526                                    .acpi_err:
   527 00000F7E 4C8B3D(08000000)                 mov r15, [rel position]
   528 00000F85 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   529 00000F8C E86FF0FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   530 00000F91 FA                               cli
   531 00000F92 F4                               hlt
   532                                  
   533                                    .looked:
   534 00000F93 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   535 00000F96 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   536 00000F9A 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   537 00000F9D 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   538                                    .maping:
   539 00000FA4 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   540 00000FA7 4889D8                           mov rax, rbx
   541 00000FAA 4821D0                           and rax, rdx
   542 00000FAD 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   543 00000FB1 E8F4F7FFFF                       call mapping_laddr_to_page
   544 00000FB6 4881C300100000                   add rbx, 0x1000
   545 00000FBD 4839CB                           cmp rbx, rcx
   546 00000FC0 7EE2                             jle .maping
   547                                  
   548                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   549 00000FC2 BB00000600                       mov rbx, 0x60000
   550 00000FC7 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   550 00000FD0 20                 
   551                                    .searc:
   552 00000FD1 48390B                           cmp qword [rbx], rcx
   553 00000FD4 740F                             je .finda
   554 00000FD6 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   555 00000FDA 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   556 00000FE1 7CEE                             jl .searc
   557 00000FE3 EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   558                                  
   559                                    .finda:
   560                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   561                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   562 00000FE5 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   563 00000FE9 752B                             jne .acpi_1
   564 00000FEB 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   565                                  
   566                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   567 00000FEF 4831FF                           xor rdi, rdi
   568 00000FF2 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   569 00000FF5 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   570 00000FF8 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   571                                    .madt0:
   572 00000FFC 4C8B1B                           mov r11, [rbx]
   573 00000FFF 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   574 00001006 7436                             je .findm
   575 00001008 4883C308                         add rbx, 8                               ;下一个元素
   576 0000100C 4839FB                           cmp rbx, rdi
   577 0000100F 7CEB                             jl .madt0
   578 00001011 E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   579                                  
   580                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   581                                    .acpi_1:
   582 00001016 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   583                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   584 00001019 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   585 0000101D 01DF                             add edi, ebx                             ;计算RSDT末端的物理位置
   586 0000101F 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   587 00001022 4D31DB                           xor r11, r11
   588                                    .madt1:
   589 00001025 67448B1B                         mov r11d, [ebx]
   590 00001029 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   591 00001030 740C                             je .findm
   592 00001032 83C304                           add ebx, 4                               ;下一个元素
   593 00001035 39FB                             cmp ebx, edi
   594 00001037 7CEC                             jl .madt1
   595 00001039 E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   596                                  
   597                                    .findm:
   598                                           ;此时，R11是MADT的物理地址
   599 0000103E 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   600 00001042 8915(28010000)                   mov [rel lapic_addr], edx
   601                                  
   602                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   603 00001048 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   604 0000104F 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   605                                  
   606 00001056 4831FF                           xor rdi, rdi
   607 00001059 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   608 0000105D 4C01DF                           add rdi, r11                             ;RDI:MADT尾部边界的物理地址
   609 00001060 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   610                                    .enumd:
   611 00001064 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   612 00001068 7408                             je .l_apic
   613 0000106A 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   614 0000106E 741B                             je .ioapic
   615 00001070 EB2D                             jmp .m_end
   616                                    .l_apic:
   617 00001072 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   618 00001077 7426                             jz .m_end
   619 00001079 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   620 0000107D 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   621 00001080 49FFC7                           inc r15
   622 00001083 FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   623 00001089 EB14                             jmp .m_end
   624                                    .ioapic:
   625 0000108B 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   626 0000108F 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   627 00001095 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   628 00001099 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   629                                     .m_end:
   630 0000109F 4831C0                           xor rax, rax
   631 000010A2 418A4301                         mov al, [r11 + 1]
   632 000010A6 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   633 000010A9 4939FB                           cmp r11, rdi
   634 000010AC 7CB6                             jl .enumd
   635                                  
   636                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   637 000010AE 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   637 000010B7 FF                 
   638 000010B8 4831C0                           xor rax, rax
   639 000010BB 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   640 000010C1 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   641 000010C4 E8E1F6FFFF                       call mapping_laddr_to_page
   642                                  
   643                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   644 000010C9 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   644 000010D2 FF                 
   645 000010D3 4831C0                           xor rax, rax
   646 000010D6 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   647 000010DC 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   648 000010DF E8C6F6FFFF                       call mapping_laddr_to_page
   649                                  
   650                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   651 000010E4 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   651 000010ED FF                 
   652                                  
   653 000010EE C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发模式
   653 000010F7 00                 
   654 000010F8 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   654 00001101 00                 
   655                                  
   656 00001102 B00B                             mov al, 0x0b                             ;RTC寄存器B
   657 00001104 0C80                             or al, 0x80                              ;阻断NMI
   658 00001106 E670                             out 0x70, al
   659 00001108 B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   660 0000110A E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   661                                  
   662 0000110C B08A                             mov al, 0x8a                             ;CMOS寄存器A
   663 0000110E E670                             out 0x70, al
   664                                           ;in al, 0x71
   665 00001110 B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   666 00001112 E671                             out 0x71, al                             ;写回CMOS寄存器A
   667                                  
   668 00001114 B08C                             mov al, 0x8c
   669 00001116 E670                             out 0x70, al
   670 00001118 E471                             in al, 0x71                              ;读寄存器C
   671                                    .w0:
   672 0000111A E471                             in al, 0x71                              ;读寄存器C
   673 0000111C 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   674 00001121 73F7                             jnc .w0
   675 00001123 C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   675 0000112C FF                 
   676                                    .w1:
   677 0000112D E471                             in al, 0x71                              ;读寄存器C
   678 0000112F 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   679 00001134 73F7                             jnc .w1
   680 00001136 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
   681                                  
   682 0000113C B8FFFFFFFF                       mov eax, 0xffff_ffff
   683 00001141 29D0                             sub eax, edx
   684 00001143 31D2                             xor edx, edx
   685 00001145 BB7D000000                       mov ebx, 125                             ;125毫秒
   686 0000114A F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
   687                                  
   688 0000114C 8905(31010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
   689                                  
   690 00001152 B00B                             mov al, 0x0b                             ;RTC寄存器B
   691 00001154 0C80                             or al, 0x80                              ;阻断NMI
   692 00001156 E670                             out 0x70, al
   693 00001158 B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
   694 0000115A E671                             out 0x71, al
   695                                  
   696                                           ;以下安装用于任务切换的中断处理过程
   697 0000115C 4C8B0D(08000000)                 mov r9, [rel position]
   698 00001163 498D81[7E0A0000]                 lea rax, [r9 + rtm_interrupt_handle]     ;得到中断处理过程的线性地址
   699 0000116A E8D6EFFFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   700                                  
   701 0000116F FA                               cli
   702                                  
   703 00001170 41B828000000                     mov r8, 0x28                             ;任务切换使用的中断向量
   704 00001176 E82BF0FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   705                                  
   706                                           ;设置和时钟中断相关的硬件
   707 0000117B B00B                             mov al, 0x0b                             ;RTC寄存器B
   708 0000117D 0C80                             or al, 0x80                              ;阻断NMI
   709 0000117F E670                             out 0x70, al
   710 00001181 B012                             mov al, 0x12                             ;设置寄存器B，禁止周期性中断，开放更
   711 00001183 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   712                                  
   713 00001185 E4A1                             in al, 0xa1                              ;读8259从片的IMR寄存器
   714 00001187 24FE                             and al, 0xfe                             ;清除bit 0(此位连接RTC)
   715 00001189 E6A1                             out 0xa1, al                             ;写回此寄存器
   716                                  
   717 0000118B FB                               sti
   718                                  
   719 0000118C B00C                             mov al, 0x0c
   720 0000118E E670                             out 0x70, al
   721 00001190 E471                             in al, 0x71                              ;读RTC寄存器C，复位未决的中断状态
   722                                  
   723                                           ;计算机启动后，默认使用经由LINT0的虚拟线模式。
   724                                           ;LVT LINT0寄存器的默认值：0x700，不屏蔽LINT0，ExtINT投递模式
   725                                           ;LVT LINT1寄存器的默认值：0x400，不屏蔽LINT1，NMI投递模式
   726                                  
   727                                  
   728                                           ;如果不使用8259A PIC，直接使用I/O APIC，则应当屏蔽LVT LINT0或者8259A PIC的输入。
   729                                           ;以下两种方式可以选择一种即可。建议选择第二种，即，屏蔽8259A的全部中断输入。
   730                                           ;mov rsi, LAPIC_START_ADDR
   731                                           ;mov dword [rsi + 0x350], 0x10000         ;屏蔽LINT0的中断信号
   732                                  
   733 00001192 B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   734 00001194 E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   735                                  
   736                                  
   737 00001196 48BF00D0FFFF7FFFFF-              mov rdi, IOAPIC_START_ADDR               ;I/O APIC的线性地址
   737 0000119F FF                 
   738                                  
   739                                           ;根据图纸可知，若选择RTC定时器，需要设置I/O APIC的I/O重定向表寄存器8（IOREDTBL8）
   740                                           ;mov dword [rdi], 0x20                    ;对应RTC。
   741                                           ;mov dword [rdi + 0x10], 0x00000028       ;不屏蔽；物理模式；固定模式；向量0x28
   742                                           ;mov dword [rdi], 0x21
   743                                           ;mov dword [rdi + 0x10], 0x00000000       ;Local APIC ID：0
   744                                  
   745                                           ;如果想加快任务切换速度，可选择8254定时器。对应I/O APIC的IOREDTBL2
   746                                           ;mov dword [rdi], 0x14                    ;对应8254定时器。
   747                                           ;mov dword [rdi + 0x10], 0x00000028       ;不屏蔽；物理模式；固定模式；向量0x28
   748                                           ;mov dword [rdi], 0x15
   749                                           ;mov dword [rdi + 0x10], 0x00000000       ;Local APIC ID：0
   750                                  
   751                                  
   752                                           ;也可以使用Local APIC内部的定时器，更加灵活。
   753 000011A0 8B05(31010000)                   mov eax, [rel clocks_1ms]
   754 000011A6 BB37000000                       mov ebx, 55
   755 000011AB F7E3                             mul ebx
   756 000011AD 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   756 000011B6 FF                 
   757 000011B7 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频（不分频）
   757 000011C0 00                 
   758 000011C1 C78620030000280002-              mov dword [rsi + 0x320], 0x20028         ;周期性模式；固定模式；中断向量：0x28
   758 000011CA 00                 
   759 000011CB 898680030000                     mov dword [rsi + 0x380], eax             ;初始计数值
   760                                  
   761                                           ;以下开始创建系统外壳任务（进程）
   762 000011D1 41B832000000                     mov r8, 50
   763 000011D7 E884FAFFFF                       call create_process
   764                                  
   765 000011DC 488B1D(89010000)                 mov rbx, [rel pcb_ptr]                   ;得到外壳任务PCB的线性地址
   766 000011E3 488B4338                         mov rax, [rbx + 56]                      ;从PCB中取出CR3
   767 000011E7 0F22D8                           mov cr3, rax                             ;切换到新进程的地址空间
   768                                  
   769 000011EA 48891D(91010000)                 mov [rel cur_pcb], rbx                   ;设置当前任务的PCB。
   770 000011F1 48C7431001000000                 mov qword [rbx + 16], 1                  ;设置任务状态为“忙”。
   771                                  
   772 000011F9 488B4320                         mov rax, [rbx + 32]                      ;从PCB中取出RSP0
   773 000011FD 488B15(51010000)                 mov rdx, [rel tss_ptr]                   ;得到TSS的线性地址
   774 00001204 48894204                         mov [rdx + 4], rax                       ;在TSS中填写RSP0
   775                                  
   776 00001208 FFB3D0000000                     push qword [rbx + 208]                   ;用户程序的SS
   777 0000120E FF7378                           push qword [rbx + 120]                   ;用户程序的RSP
   778 00001211 9C                               pushfq
   779 00001212 FFB3C8000000                     push qword [rbx + 200]                   ;用户程序的CS
   780 00001218 FFB3C0000000                     push qword [rbx + 192]                   ;用户程序的RIP
   781                                  
   782 0000121E 48CF                             iretq                                    ;返回当前任务的私有空间执行
   783                                  
   784                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   785                                  core_end:
