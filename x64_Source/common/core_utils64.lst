     1                                  ;文件core_utils64.wid是供64位内核使用的例程集合，支持单处理器和多处理器环境。
     2                                  ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成，李忠
     3                                  ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
     4                                  ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
     5                                  ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
     6                                  
     7                                  %include "..\common\global_defs.wid"
     8                              <1> ;系统全局使用的常量定义，2021-09-05
     9                              <1> 
    10                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    11                              <1> 
    12                              <1> %ifndef _GLOBAL_DEFS_
    13                              <1>    %define _GLOBAL_DEFS_
    14                              <1> 
    15                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    16                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    17                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    18                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    19                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    20                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    21                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    22                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    23                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    24                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    25                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    26                              <1> 
    27                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    28                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    29                              <1> 
    30                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    31                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    32                              <1> 
    33                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    34                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    35                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    36                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    37                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    38                              <1> 
    39                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    40                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    41                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    42                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    43                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    44                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    45                              <1> 
    46                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    47                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    48                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    49                              <1> 
    50                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    51                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    52                              <1> 
    53                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    54                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    55                              <1> 
    56                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    57                              <1> 
    58                              <1>    SUGG_PREEM_SLICE    equ     55                      ;推荐的任务/线程抢占时间片长度（毫秒）
    59                              <1> 
    60                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    61                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    62                              <1>             %%spin_lock:
    63                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    64                              <1>                        je %%get_lock                   ;获取锁
    65                              <1>                        pause
    66                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    67                              <1>             %%get_lock:
    68                              <1>                        mov %1, 1
    69                              <1>                        xchg %1, %2
    70                              <1>                        cmp %1, 0                       ;交换前为零？
    71                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    72                              <1>    %endmacro
    73                              <1> 
    74                              <1> %endif
     8                                  
     9                                           bits 64
    10                                  
    11                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    12                                  %ifdef __MP__
    13                                  _prn_str_locker dq 0                              ;打印锁
    14                                  %endif
    15                                  
    16                                  put_string64:                                     ;显示0终止的字符串并移动光标
    17                                                                                    ;输入：RBX=字符串的线性地址
    18 00000000 53                               push rbx
    19 00000001 51                               push rcx
    20                                  
    21 00000002 9C                               pushfq                                   ;-->A
    22 00000003 FA                               cli
    23                                  %ifdef __MP__
    24                                           SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    25                                  %endif
    26                                  
    27                                    .getc:
    28 00000004 8A0B                             mov cl, [rbx]
    29 00000006 08C9                             or cl, cl                                ;检测串结束标志（0）
    30 00000008 740A                             jz .exit                                 ;显示完毕，返回
    31 0000000A E809000000                       call put_char
    32 0000000F 48FFC3                           inc rbx
    33 00000012 EBF0                             jmp .getc
    34                                  
    35                                    .exit:
    36                                  %ifdef __MP__
    37                                           mov qword [rel _prn_str_locker], 0       ;释放锁
    38                                  %endif
    39 00000014 9D                               popfq                                    ;A
    40                                  
    41 00000015 59                               pop rcx
    42 00000016 5B                               pop rbx
    43                                  
    44 00000017 C3                               ret                                      ;段内返回
    45                                  
    46                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    47                                  put_char:                                         ;在当前光标处显示一个字符,并推进
    48                                                                                    ;光标。
    49                                                                                    ;输入：CL=字符ASCII码
    50 00000018 50                               push rax
    51 00000019 53                               push rbx
    52 0000001A 51                               push rcx
    53 0000001B 52                               push rdx
    54 0000001C 56                               push rsi
    55 0000001D 57                               push rdi
    56                                  
    57                                           ;以下取当前光标位置
    58 0000001E 66BAD403                         mov dx, 0x3d4
    59 00000022 B00E                             mov al, 0x0e
    60 00000024 EE                               out dx, al
    61 00000025 66FFC2                           inc dx                                   ;0x3d5
    62 00000028 EC                               in al, dx                                ;高字
    63 00000029 88C4                             mov ah, al
    64                                  
    65 0000002B 66FFCA                           dec dx                                   ;0x3d4
    66 0000002E B00F                             mov al, 0x0f
    67 00000030 EE                               out dx, al
    68 00000031 66FFC2                           inc dx                                   ;0x3d5
    69 00000034 EC                               in al, dx                                ;低字
    70 00000035 6689C3                           mov bx, ax                               ;BX=代表光标位置的16位数
    71 00000038 4881E3FFFF0000                   and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
    72                                  
    73 0000003F 80F90D                           cmp cl, 0x0d                             ;回车符？
    74 00000042 750E                             jnz .put_0a
    75 00000044 6689D8                           mov ax, bx
    76 00000047 B350                             mov bl, 80
    77 00000049 F6F3                             div bl
    78 0000004B F6E3                             mul bl
    79 0000004D 6689C3                           mov bx, ax
    80 00000050 EB6C                             jmp .set_cursor
    81                                  
    82                                    .put_0a:
    83 00000052 80F90A                           cmp cl, 0x0a                             ;换行符？
    84 00000055 7506                             jnz .put_other
    85 00000057 6683C350                         add bx, 80
    86 0000005B EB16                             jmp .roll_screen
    87                                  
    88                                    .put_other:                                     ;正常显示字符
    89 0000005D 66D1E3                           shl bx, 1
    90 00000060 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
    90 00000069 FF                 
    91 0000006A 880C18                           mov [rax + rbx], cl
    92                                  
    93                                           ;以下将光标位置推进一个字符
    94 0000006D 66D1EB                           shr bx, 1
    95 00000070 66FFC3                           inc bx
    96                                  
    97                                    .roll_screen:
    98 00000073 6681FBD007                       cmp bx, 2000                             ;光标超出屏幕？滚屏
    99 00000078 7C44                             jl .set_cursor
   100                                  
   101 0000007A 6653                             push bx
   102                                  
   103 0000007C FC                               cld
   104 0000007D 48BEA0800B000080FF-              mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
   104 00000086 FF                 
   105 00000087 48BF00800B000080FF-              mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
   105 00000090 FF                 
   106 00000091 B9E0010000                       mov rcx, 480
   107 00000096 F348A5                           rep movsq
   108 00000099 66BB000F                         mov bx, 3840                             ;清除屏幕最底一行
   109 0000009D B950000000                       mov rcx, 80                              ;64位程序应该使用RCX
   110                                    .cls:
   111 000000A2 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO
   111 000000AB FF                 
   112 000000AC 66C704182007                     mov word[rax + rbx], 0x0720
   113 000000B2 6683C302                         add bx, 2
   114 000000B6 E2EA                             loop .cls
   115                                  
   116 000000B8 665B                             pop bx
   117 000000BA 6683EB50                         sub bx, 80
   118                                  
   119                                    .set_cursor:
   120 000000BE 66BAD403                         mov dx, 0x3d4
   121 000000C2 B00E                             mov al, 0x0e
   122 000000C4 EE                               out dx, al
   123 000000C5 66FFC2                           inc dx                                   ;0x3d5
   124 000000C8 88F8                             mov al, bh
   125 000000CA EE                               out dx, al
   126 000000CB 66FFCA                           dec dx                                   ;0x3d4
   127 000000CE B00F                             mov al, 0x0f
   128 000000D0 EE                               out dx, al
   129 000000D1 66FFC2                           inc dx                                   ;0x3d5
   130 000000D4 88D8                             mov al, bl
   131 000000D6 EE                               out dx, al
   132                                  
   133 000000D7 5F                               pop rdi
   134 000000D8 5E                               pop rsi
   135 000000D9 5A                               pop rdx
   136 000000DA 59                               pop rcx
   137 000000DB 5B                               pop rbx
   138 000000DC 58                               pop rax
   139                                  
   140 000000DD C3                               ret
   141                                  
   142                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   143                                  ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的
   144                                  ;坐标位置不同，互不干扰，不需要加锁和互斥。
   145                                  %ifdef __MP__
   146                                  _prnxy_locker dq 0
   147                                  %endif
   148                                  
   149                                  put_cstringxy64:                                  ;输入：RBX=字符串首地址
   150                                                                                    ;DH=行，DL=列
   151                                                                                    ;R9B=颜色属性
   152 000000DE 50                               push rax
   153 000000DF 53                               push rbx
   154 000000E0 51                               push rcx
   155 000000E1 52                               push rdx
   156 000000E2 4150                             push r8
   157                                  
   158                                           ;指定坐标位置在显存内的偏移量
   159 000000E4 88F0                             mov al, dh
   160 000000E6 B5A0                             mov ch, 160                              ;每一行80个字符，占用160个字节
   161 000000E8 F6E5                             mul ch
   162 000000EA D0E2                             shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   163 000000EC 6681E2FF00                       and dx, 0x00ff
   164 000000F1 6601D0                           add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   165 000000F4 4825FFFF0000                     and rax, 0x000000000000ffff
   166                                  
   167 000000FA 9C                               pushfq                                   ;-->A
   168 000000FB FA                               cli
   169                                  %ifdef __MP__
   170                                           SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
   171                                  %endif
   172                                  
   173 000000FC 49B800800B000080FF-              mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   173 00000105 FF                 
   174                                    .nextc:
   175 00000106 8A13                             mov dl, [rbx]                            ;取得将要显示的字符
   176 00000108 08D2                             or dl, dl
   177 0000010A 7412                             jz .exit
   178 0000010C 41881400                         mov byte [r8 + rax], dl
   179 00000110 45884C0001                       mov byte [r8 + rax + 1], r9b             ;字符颜色
   180 00000115 48FFC3                           inc rbx
   181 00000118 4883C002                         add rax, 2                               ;增加一个字符的位置（2个字节）
   182 0000011C EBE8                             jmp .nextc
   183                                    .exit:
   184 0000011E 4D31C0                           xor r8, r8
   185                                  %ifdef __MP__
   186                                           mov qword [rel _prnxy_locker], 0         ;释放锁
   187                                  %endif
   188 00000121 9D                               popfq                                    ;A
   189                                  
   190 00000122 4158                             pop r8
   191 00000124 5A                               pop rdx
   192 00000125 59                               pop rcx
   193 00000126 5B                               pop rbx
   194 00000127 58                               pop rax
   195                                  
   196 00000128 C3                               ret
   197                                  
   198                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   199                                  make_call_gate:                                   ;创建64位的调用门
   200                                                                                    ;输入：RAX=例程的线性地址
   201                                                                                    ;输出：RDI:RSI=调用门
   202 00000129 4889C7                           mov rdi, rax
   203 0000012C 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   204                                  
   205 00000130 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   206 00000131 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   207 00000138 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   208 0000013C 66C7442404008C                   mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   209 00000143 5E                               pop rsi
   210                                  
   211 00000144 C3                               ret
   212                                  
   213                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   214                                  make_interrupt_gate:                              ;创建64位的中断门
   215                                                                                    ;输入：RAX=例程的线性地址
   216                                                                                    ;输出：RDI:RSI=中断门
   217 00000145 4889C7                           mov rdi, rax
   218 00000148 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   219                                  
   220 0000014C 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   221 0000014D 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   222 00000154 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   223 00000158 66C7442404008E                   mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   224 0000015F 5E                               pop rsi
   225                                  
   226 00000160 C3                               ret
   227                                  
   228                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   229                                  make_trap_gate:                                   ;创建64位的陷阱门
   230                                                                                    ;输入：RAX=例程的线性地址
   231                                                                                    ;输出：RDI:RSI=陷阱门
   232 00000161 4889C7                           mov rdi, rax
   233 00000164 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   234                                  
   235 00000168 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   236 00000169 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   237 00000170 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   238 00000174 66C7442404008F                   mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   239 0000017B 5E                               pop rsi
   240                                  
   241 0000017C C3                               ret
   242                                  
   243                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   244                                  make_tss_descriptor:                              ;创建64位的TSS描述符
   245                                                                                    ;输入：RAX=TSS的线性地址
   246                                                                                    ;输出：RDI:RSI=TSS描述符
   247 0000017D 50                               push rax
   248                                  
   249 0000017E 4889C7                           mov rdi, rax
   250 00000181 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   251                                  
   252 00000185 50                               push rax                                 ;先将部分线性地址移到适当位置
   253 00000186 48C1242410                       shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   254 0000018B 66C704246800                     mov word [rsp], 104                      ;段界限的标准长度
   255 00000191 8A442405                         mov al, [rsp + 5]
   256 00000195 88442407                         mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   257 00000199 C644240589                       mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   258 0000019E C644240600                       mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   259 000001A3 5E                               pop rsi                                  ;门的低64位
   260                                  
   261 000001A4 58                               pop rax
   262                                  
   263 000001A5 C3                               ret
   264                                  
   265                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   266                                  mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   267                                                                                    ;R8=中断向量
   268                                                                                    ;RDI:RSI=门描述符
   269 000001A6 4150                             push r8
   270 000001A8 4151                             push r9
   271                                  
   272 000001AA 49C1E004                         shl r8, 4                                ;中断号乘以16，得到表内偏移
   273 000001AE 49B900E000000080FF-              mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   273 000001B7 FF                 
   274 000001B8 4B893401                         mov [r9 + r8], rsi
   275 000001BC 4B897C0108                       mov [r9 + r8 + 8], rdi
   276                                  
   277 000001C1 4159                             pop r9
   278 000001C3 4158                             pop r8
   279                                  
   280 000001C5 C3                               ret
   281                                  
   282                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   283                                  init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   284 000001C6 50                               push rax
   285                                  
   286 000001C7 B011                             mov al, 0x11
   287 000001C9 E620                             out 0x20, al                             ;ICW1：边沿触发/级联方式
   288 000001CB B020                             mov al, 0x20
   289 000001CD E621                             out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   290 000001CF B004                             mov al, 0x04
   291 000001D1 E621                             out 0x21, al                             ;ICW3:从片级联到IR2
   292 000001D3 B001                             mov al, 0x01
   293 000001D5 E621                             out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   294                                  
   295 000001D7 B011                             mov al, 0x11
   296 000001D9 E6A0                             out 0xa0, al                             ;ICW1：边沿触发/级联方式
   297 000001DB B028                             mov al, 0x28
   298 000001DD E6A1                             out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   299 000001DF B002                             mov al, 0x02
   300 000001E1 E6A1                             out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   301 000001E3 B001                             mov al, 0x01
   302 000001E5 E6A1                             out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   303                                  
   304 000001E7 58                               pop rax
   305 000001E8 C3                               ret
   306                                  
   307                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   308                                  %ifdef __MP__
   309                                  _read_hdd_locker dq 0                              ;读硬盘锁
   310                                  %endif
   311                                  
   312                                  read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   313                                                                                    ;RAX=逻辑扇区号
   314                                                                                    ;RBX=目标缓冲区线性地址
   315                                                                                    ;返回：RBX=RBX+512
   316 000001E9 50                               push rax
   317 000001EA 51                               push rcx
   318 000001EB 52                               push rdx
   319                                  
   320 000001EC 9C                               pushfq                                   ;-->A
   321 000001ED FA                               cli
   322                                  %ifdef __MP__
   323                                           SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
   324                                  %endif
   325                                  
   326 000001EE 50                               push rax
   327                                  
   328 000001EF 66BAF201                         mov dx, 0x1f2
   329 000001F3 B001                             mov al, 1
   330 000001F5 EE                               out dx, al                               ;读取的扇区数
   331                                  
   332 000001F6 66FFC2                           inc dx                                   ;0x1f3
   333 000001F9 58                               pop rax
   334 000001FA EE                               out dx, al                               ;LBA地址7~0
   335                                  
   336 000001FB 66FFC2                           inc dx                                   ;0x1f4
   337 000001FE B108                             mov cl, 8
   338 00000200 48D3E8                           shr rax, cl
   339 00000203 EE                               out dx, al                               ;LBA地址15~8
   340                                  
   341 00000204 66FFC2                           inc dx                                   ;0x1f5
   342 00000207 48D3E8                           shr rax, cl
   343 0000020A EE                               out dx, al                               ;LBA地址23~16
   344                                  
   345 0000020B 66FFC2                           inc dx                                   ;0x1f6
   346 0000020E 48D3E8                           shr rax, cl
   347 00000211 0CE0                             or al, 0xe0                              ;第一硬盘  LBA地址27~24
   348 00000213 EE                               out dx, al
   349                                  
   350 00000214 66FFC2                           inc dx                                   ;0x1f7
   351 00000217 B020                             mov al, 0x20                             ;读命令
   352 00000219 EE                               out dx, al
   353                                  
   354                                    .waits:
   355 0000021A EC                               in al, dx
   356                                           ;and al, 0x88
   357                                           ;cmp al, 0x08
   358 0000021B A808                             test al, 8
   359 0000021D 74FB                             jz .waits                               ;不忙，且硬盘已准备好数据传输
   360                                  
   361 0000021F B900010000                       mov rcx, 256                             ;总共要读取的字数
   362 00000224 66BAF001                         mov dx, 0x1f0
   363                                    .readw:
   364 00000228 66ED                             in ax, dx
   365 0000022A 668903                           mov [rbx], ax
   366 0000022D 4883C302                         add rbx, 2
   367 00000231 E2F5                             loop .readw
   368                                  
   369                                  %ifdef __MP__
   370                                           mov qword [rel _read_hdd_locker], 0      ;释放锁
   371                                  %endif
   372 00000233 9D                               popfq                                    ;A
   373                                  
   374 00000234 5A                               pop rdx
   375 00000235 59                               pop rcx
   376 00000236 58                               pop rax
   377                                  
   378 00000237 C3                               ret
   379                                  
   380                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   381 00000238 FF<rep 40h>               _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   382 00000278 00<rep 3C0h>                      times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   383                                    _page_map_len  equ $ - _page_bit_map
   384                                  
   385                                  allocate_a_4k_page:                               ;分配一个4KB的页
   386                                                                                    ;输入：无
   387                                                                                    ;输出：RAX=页的物理地址
   388 00000638 4831C0                           xor rax, rax
   389                                    .b1:
   390 0000063B F0480FAB05F4FBFFFF               lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   391 00000644 730B                             jnc .b2
   392 00000646 48FFC0                           inc rax
   393 00000649 483D00200000                     cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   394 0000064F 7CEA                             jl .b1
   395                                  
   396                                           ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   397                                           ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   398                                           ;销的页面，或者执行页面的换入和换出。
   399                                  
   400                                    .b2:
   401 00000651 48C1E00C                         shl rax, 12                              ;乘以4096（0x1000）
   402                                  
   403 00000655 C3                               ret
   404                                  
   405                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   406                                  lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   407                                                                                    ;输入：R13=线性地址
   408                                                                                    ;输出：R14=对应的4级头表项的线性地址
   409 00000656 4155                             push r13
   410                                  
   411 00000658 49BE0000000080FF00-              mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   411 00000661 00                 
   412 00000662 4D21F5                           and r13, r14
   413 00000665 49C1ED24                         shr r13, 36                              ;原4级头表索引变成页内偏移
   414                                  
   415 00000669 49C7C600F0FFFF                   mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   416 00000670 4D01EE                           add r14, r13
   417                                  
   418 00000673 415D                             pop r13
   419                                  
   420 00000675 C3                               ret
   421                                  
   422                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   423                                  lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   424                                                                                    ;输入：R13=线性地址
   425                                                                                    ;输出：R14=对应的页目录指针项的线性地址
   426 00000676 4155                             push r13
   427                                  
   428 00000678 49BE000000C0FFFF00-              mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   428 00000681 00                 
   429 00000682 4D21F5                           and r13, r14
   430 00000685 49C1ED1B                         shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   431                                  
   432 00000689 49C7C60000E0FF                   mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   433 00000690 4D01EE                           add r14, r13
   434                                  
   435 00000693 415D                             pop r13
   436                                  
   437 00000695 C3                               ret
   438                                  
   439                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   440                                  lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   441                                                                                    ;输入：R13=线性地址
   442                                                                                    ;输出：R14=对应的页目录项的线性地址
   443 00000696 4155                             push r13
   444                                  
   445 00000698 49BE0000E0FFFFFF00-              mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   445 000006A1 00                 
   446 000006A2 4D21F5                           and r13, r14
   447 000006A5 49C1ED12                         shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   448                                                                                    ;页表索引，原页目录表索引变页内偏移
   449 000006A9 49C7C6000000C0                   mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   450 000006B0 4D01EE                           add r14, r13
   451                                  
   452 000006B3 415D                             pop r13
   453                                  
   454 000006B5 C3                               ret
   455                                  
   456                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   457                                  lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   458                                                                                    ;输入：R13=线性地址
   459                                                                                    ;输出：R14=对应的页表项的线性地址
   460 000006B6 4155                             push r13
   461                                  
   462 000006B8 49BE00F0FFFFFFFF00-              mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   462 000006C1 00                 
   463 000006C2 4D21F5                           and r13, r14
   464 000006C5 49C1ED09                         shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   465                                                                                    ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   466 000006C9 49BE0000000080FFFF-              mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   466 000006D2 FF                 
   467 000006D3 4D01EE                           add r14, r13
   468                                  
   469 000006D6 415D                             pop r13
   470                                  
   471 000006D8 C3                               ret
   472                                  
   473                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   474                                  %ifdef __MP__
   475                                  _spaging_locker dq 0
   476                                  %endif
   477                                  
   478                                  setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   479                                                                                    ;输入：R13=线性地址
   480 000006D9 51                               push rcx
   481 000006DA 50                               push rax
   482 000006DB 4156                             push r14
   483                                  
   484 000006DD 9C                               pushfq                                   ;-->A
   485 000006DE FA                               cli
   486                                  %ifdef __MP__
   487                                           SET_SPIN_LOCK r14, qword [rel _spaging_locker]
   488                                  %endif
   489                                  
   490                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   491                                           ;检查该线性地址所对应的4级头表项是否存在
   492 000006DF E872FFFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   493 000006E4 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   494 000006EB 752B                             jnz .b0
   495                                  
   496                                           ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   497 000006ED E846FFFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   498 000006F2 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   499 000006F6 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   500                                  
   501                                           ;清空刚分配的页目录指针表
   502 000006F9 E878FFFFFF                       call lin_to_lin_of_pdpte
   503 000006FE 49C1EE0C                         shr r14, 12
   504 00000702 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   505 00000706 B900020000                       mov rcx, 512
   506                                    .cls0:
   507 0000070B 49C70600000000                   mov qword [r14], 0
   508 00000712 4983C608                         add r14, 8
   509 00000716 E2F3                             loop .cls0
   510                                  ;-------------------------------------------------
   511                                    .b0:
   512                                           ;检查该线性地址所对应的页目录指针项是否存在
   513 00000718 E859FFFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   514 0000071D 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   515 00000724 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   516                                  
   517                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   518 00000726 E80DFFFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   519 0000072B 4883C807                         or rax, 0x07                             ;添加属性位
   520 0000072F 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   521                                  
   522                                           ;清空刚分配的页目录表
   523 00000732 E85FFFFFFF                       call lin_to_lin_of_pdte
   524 00000737 49C1EE0C                         shr r14, 12
   525 0000073B 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   526 0000073F B900020000                       mov rcx, 512
   527                                    .cls1:
   528 00000744 49C70600000000                   mov qword [r14], 0
   529 0000074B 4983C608                         add r14, 8
   530 0000074F E2F3                             loop .cls1
   531                                  ;-------------------------------------------------
   532                                    .b1:
   533                                           ;检查该线性地址所对应的页目录项是否存在
   534 00000751 E840FFFFFF                       call lin_to_lin_of_pdte
   535 00000756 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   536 0000075D 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   537                                  
   538                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   539 0000075F E8D4FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   540 00000764 4883C807                         or rax, 0x07                             ;添加属性位
   541 00000768 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   542                                  
   543                                           ;清空刚分配的页表
   544 0000076B E846FFFFFF                       call lin_to_lin_of_pte
   545 00000770 49C1EE0C                         shr r14, 12
   546 00000774 49C1E60C                         shl r14, 12                             ;得到页表的线性地址
   547 00000778 B900020000                       mov rcx, 512
   548                                    .cls2:
   549 0000077D 49C70600000000                   mov qword [r14], 0
   550 00000784 4983C608                         add r14, 8
   551 00000788 E2F3                             loop .cls2
   552                                  ;-------------------------------------------------
   553                                    .b2:
   554                                           ;检查该线性地址所对应的页表项是否存在
   555 0000078A E827FFFFFF                       call lin_to_lin_of_pte
   556 0000078F 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   557 00000796 750C                             jnz .b3                                  ;页表项已经存在，转.b3
   558                                  
   559                                           ;创建并安装该线性地址所对应的页表项（分配最终的页）
   560 00000798 E89BFEFFFF                       call allocate_a_4k_page                  ;分配一个页
   561 0000079D 4883C807                         or rax, 0x07                             ;添加属性位
   562 000007A1 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   563                                  
   564                                    .b3:
   565                                  %ifdef __MP__
   566                                           mov qword [rel _spaging_locker], 0
   567                                  %endif
   568 000007A4 9D                               popfq                                    ;A
   569                                  
   570 000007A5 415E                             pop r14
   571 000007A7 58                               pop rax
   572 000007A8 59                               pop rcx
   573                                  
   574 000007A9 C3                               ret
   575                                  
   576                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   577                                  %ifdef __MP__
   578                                  _mapping_locker dq 0
   579                                  %endif
   580                                  
   581                                  mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   582                                                                                    ;即，为指定的线性地址安装指定的物理页
   583                                                                                    ;输入：R13=线性地址
   584                                                                                    ;      RAX=页的物理地址（含属性）
   585 000007AA 51                               push rcx
   586 000007AB 4156                             push r14
   587                                  
   588 000007AD 9C                               pushfq
   589 000007AE FA                               cli
   590                                  %ifdef __MP__
   591                                           SET_SPIN_LOCK r14, qword [rel _mapping_locker]
   592                                  %endif
   593                                  
   594 000007AF 50                               push rax
   595                                  
   596                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   597                                           ;检查该线性地址所对应的4级头表项是否存在
   598 000007B0 E8A1FEFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   599 000007B5 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   600 000007BC 752B                             jnz .b0
   601                                  
   602                                           ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   603 000007BE E875FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   604 000007C3 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   605 000007C7 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   606                                  
   607                                           ;清空刚分配的页目录指针表
   608 000007CA E8A7FEFFFF                       call lin_to_lin_of_pdpte
   609 000007CF 49C1EE0C                         shr r14, 12
   610 000007D3 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   611 000007D7 B900020000                       mov rcx, 512
   612                                    .cls0:
   613 000007DC 49C70600000000                   mov qword [r14], 0
   614 000007E3 4983C608                         add r14, 8
   615 000007E7 E2F3                             loop .cls0
   616                                  ;-------------------------------------------------
   617                                    .b0:
   618                                           ;检查该线性地址所对应的页目录指针项是否存在
   619 000007E9 E888FEFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   620 000007EE 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   621 000007F5 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   622                                  
   623                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   624 000007F7 E83CFEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   625 000007FC 4883C807                         or rax, 0x07                             ;添加属性位
   626 00000800 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   627                                  
   628                                           ;清空刚分配的页目录表
   629 00000803 E88EFEFFFF                       call lin_to_lin_of_pdte
   630 00000808 49C1EE0C                         shr r14, 12
   631 0000080C 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   632 00000810 B900020000                       mov rcx, 512
   633                                    .cls1:
   634 00000815 49C70600000000                   mov qword [r14], 0
   635 0000081C 4983C608                         add r14, 8
   636 00000820 E2F3                             loop .cls1
   637                                  ;-------------------------------------------------
   638                                    .b1:
   639                                           ;检查该线性地址所对应的页目录项是否存在
   640 00000822 E86FFEFFFF                       call lin_to_lin_of_pdte
   641 00000827 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   642 0000082E 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   643                                  
   644                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   645 00000830 E803FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   646 00000835 4883C807                         or rax, 0x07                             ;添加属性位
   647 00000839 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   648                                  
   649                                           ;清空刚分配的页表
   650 0000083C E875FEFFFF                       call lin_to_lin_of_pte
   651 00000841 49C1EE0C                         shr r14, 12
   652 00000845 49C1E60C                         shl r14, 12                              ;得到页表的线性地址
   653 00000849 B900020000                       mov rcx, 512
   654                                    .cls2:
   655 0000084E 49C70600000000                   mov qword [r14], 0
   656 00000855 4983C608                         add r14, 8
   657 00000859 E2F3                             loop .cls2
   658                                  ;-------------------------------------------------
   659                                    .b2:
   660 0000085B E856FEFFFF                       call lin_to_lin_of_pte                   ;得到页表项的线性地址
   661 00000860 58                               pop rax
   662 00000861 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   663                                  
   664                                  %ifdef __MP__
   665                                           mov qword [rel _mapping_locker], 0
   666                                  %endif
   667 00000864 9D                               popfq
   668                                  
   669 00000865 415E                             pop r14
   670 00000867 59                               pop rcx
   671                                  
   672 00000868 C3                               ret
   673                                  
   674                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   675 00000869 000020000080FFFF          _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   676                                  %ifdef __MP__
   677                                    _core_alloc_locker dq 0
   678                                  %endif
   679                                  
   680                                  core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   681                                                                                    ;输入：RCX=请求分配的字节数
   682                                                                                    ;输出：R13=本次分配的起始线性地址
   683                                                                                    ;      R14=下次分配的起始线性地址
   684 00000871 9C                               pushfq                                   ;A-->
   685 00000872 FA                               cli
   686                                  %ifdef __MP__
   687                                           SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
   688                                  %endif
   689                                  
   690 00000873 4C8B2DEFFFFFFF                   mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   691 0000087A 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   692                                  
   693 0000087F 49F7C607000000                   test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   694 00000886 740C                             jz .algn
   695 00000888 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   696 0000088C 49C1EE03                         shr r14, 3
   697 00000890 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   698                                  
   699                                    .algn:
   700 00000894 4C8935CEFFFFFF                   mov [rel _core_next_linear], r14         ;写回。
   701                                  
   702                                  %ifdef __MP__
   703                                           mov qword [rel _core_alloc_locker], 0    ;释放锁
   704                                  %endif
   705 0000089B 9D                               popfq                                    ;A
   706                                  
   707 0000089C 4155                             push r13
   708 0000089E 4156                             push r14
   709                                  
   710                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   711 000008A0 49C1ED0C                         shr r13, 12
   712 000008A4 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   713 000008A8 49C1EE0C                         shr r14, 12
   714 000008AC 49C1E60C                         shl r14, 12                              ;too
   715                                    .next:
   716 000008B0 E824FEFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   717 000008B5 4981C500100000                   add r13, 0x1000                          ;+4096
   718 000008BC 4D39F5                           cmp r13, r14
   719 000008BF 7EEF                             jle .next
   720                                  
   721 000008C1 415E                             pop r14
   722 000008C3 415D                             pop r13
   723                                  
   724 000008C5 C3                               ret
   725                                  
   726                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   727                                  user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   728                                                                                    ;输入：R11=任务控制块PCB的线性地址
   729                                                                                    ;      RCX=希望分配的字节数
   730                                                                                    ;输出：R13=本次分配的起始线性地址
   731                                                                                    ;      R14=下次分配的起始线性地址
   732                                           ;获得本次内存分配的起始线性地址
   733 000008C6 4D8B6B18                         mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   734 000008CA 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   735                                  
   736 000008CF 49F7C607000000                   test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   737 000008D6 740C                             jz .algn
   738 000008D8 49C1EE03                         shr r14, 3
   739 000008DC 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   740 000008E0 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   741                                  
   742                                    .algn:
   743 000008E4 4D897318                         mov [r11 + 24], r14                      ;写回PCB中。
   744                                  
   745 000008E8 4155                             push r13
   746 000008EA 4156                             push r14
   747                                  
   748                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   749 000008EC 49C1ED0C                         shr r13, 12
   750 000008F0 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   751 000008F4 49C1EE0C                         shr r14, 12
   752 000008F8 49C1E60C                         shl r14, 12                              ;too
   753                                    .next:
   754 000008FC E8D8FDFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   755 00000901 4981C500100000                   add r13, 0x1000                          ;+4096
   756 00000908 4D39F5                           cmp r13, r14
   757 0000090B 7EEF                             jle .next
   758                                  
   759 0000090D 415E                             pop r14
   760 0000090F 415D                             pop r13
   761                                  
   762 00000911 C3                               ret
   763                                  
   764                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   765                                  %ifdef __MP__
   766                                  _copy_locker dq 0
   767                                  %endif
   768                                  
   769                                  copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   770                                                                                    ;输入：无
   771                                                                                    ;输出：RAX=新4级头表的物理地址及属性
   772 00000912 56                               push rsi
   773 00000913 57                               push rdi
   774 00000914 4155                             push r13
   775 00000916 51                               push rcx
   776                                  
   777 00000917 9C                               pushfq                                   ;-->A
   778 00000918 FA                               cli
   779                                  %ifdef __MP__
   780                                           SET_SPIN_LOCK rcx, qword [rel _copy_locker]
   781                                  %endif
   782                                  
   783 00000919 E81AFDFFFF                       call allocate_a_4k_page                  ;分配一个物理页
   784 0000091E 4883C807                         or rax, 0x07                             ;立即数符号扩展到64位参与操作
   785 00000922 49BD00F0FFFF7FFFFF-              mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   785 0000092B FF                 
   786 0000092C E879FEFFFF                       call mapping_laddr_to_page
   787                                  
   788                                           ;相关表项在修改前存在遗留，本次修改必须刷新。
   789 00000931 410F017D00                       invlpg [r13]
   790                                  
   791 00000936 48C7C600F0FFFF                   mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   792 0000093D 4C89EF                           mov rdi, r13                             ;RDI->新4级头表的线性地址
   793 00000940 B900020000                       mov rcx, 512                             ;RCX=要复制的目录项数
   794 00000945 FC                               cld
   795 00000946 F348A5                           repe movsq
   796                                  
   797 00000949 498985F80F0000                   mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   798 00000950 410F01BDF80F0000                 invlpg [r13 + 0xff8]
   799                                  
   800                                  %ifdef __MP__
   801                                           mov qword [rel _copy_locker], 0
   802                                  %endif
   803 00000958 9D                               popfq                                    ;A
   804                                  
   805 00000959 59                               pop rcx
   806 0000095A 415D                             pop r13
   807 0000095C 5F                               pop rdi
   808 0000095D 5E                               pop rsi
   809                                  
   810 0000095E C3                               ret
   811                                  
   812                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   813                                  %ifdef __MP__
   814                                  _cmos_locker dq 0
   815                                  %endif
   816                                  
   817                                  get_cmos_time:                                    ;从CMOS中获取当前时间
   818                                                                                    ;输入：RBX=缓冲区线性地址
   819 0000095F 50                               push rax
   820                                  
   821 00000960 9C                               pushfq                                   ;-->A
   822 00000961 FA                               cli
   823                                  %ifdef __MP__
   824                                           SET_SPIN_LOCK rax, qword [rel _cmos_locker]
   825                                  %endif
   826                                  
   827                                    .w0:
   828 00000962 B08A                             mov al, 0x8a
   829 00000964 E670                             out 0x70, al
   830 00000966 E471                             in al, 0x71                              ;读寄存器A
   831 00000968 A880                             test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   832 0000096A 75F6                             jnz .w0
   833                                  
   834 0000096C B084                             mov al, 0x84
   835 0000096E E670                             out 0x70, al
   836 00000970 E471                             in al, 0x71                              ;读RTC当前时间(时)
   837 00000972 88C4                             mov ah, al
   838                                  
   839 00000974 C0EC04                           shr ah, 4
   840 00000977 80E40F                           and ah, 0x0f
   841 0000097A 80C430                           add ah, 0x30
   842 0000097D 8823                             mov [rbx], ah
   843                                  
   844 0000097F 240F                             and al, 0x0f
   845 00000981 0430                             add al, 0x30
   846 00000983 884301                           mov [rbx + 1], al
   847                                  
   848 00000986 C643023A                         mov byte [rbx + 2], ':'
   849                                  
   850 0000098A B082                             mov al, 0x82
   851 0000098C E670                             out 0x70, al
   852 0000098E E471                             in al, 0x71                              ;读RTC当前时间(分)
   853 00000990 88C4                             mov ah, al
   854                                  
   855 00000992 C0EC04                           shr ah, 4
   856 00000995 80E40F                           and ah, 0x0f
   857 00000998 80C430                           add ah, 0x30
   858 0000099B 886303                           mov [rbx + 3], ah
   859                                  
   860 0000099E 240F                             and al, 0x0f
   861 000009A0 0430                             add al, 0x30
   862 000009A2 884304                           mov [rbx + 4], al
   863                                  
   864 000009A5 C643053A                         mov byte [rbx + 5], ':'
   865                                  
   866 000009A9 B080                             mov al, 0x80
   867 000009AB E670                             out 0x70, al
   868 000009AD E471                             in al, 0x71                              ;读RTC当前时间(秒)
   869 000009AF 88C4                             mov ah, al                               ;分拆成两个数字
   870                                  
   871 000009B1 C0EC04                           shr ah, 4                                ;逻辑右移4位
   872 000009B4 80E40F                           and ah, 0x0f
   873 000009B7 80C430                           add ah, 0x30
   874 000009BA 886306                           mov [rbx + 6], ah
   875                                  
   876 000009BD 240F                             and al, 0x0f                             ;仅保留低4位
   877 000009BF 0430                             add al, 0x30                             ;转换成ASCII
   878 000009C1 884307                           mov [rbx + 7], al
   879                                  
   880 000009C4 C6430800                         mov byte [rbx + 8], 0                    ;空字符终止
   881                                  
   882                                  %ifdef __MP__
   883                                           mov qword [rel _cmos_locker], 0
   884                                  %endif
   885 000009C8 9D                               popfq                                    ;A
   886                                  
   887 000009C9 58                               pop rax
   888                                  
   889 000009CA C3                               ret
   890                                  
   891                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   892 000009CB 0000000000000000          _process_id        dq 0
   893                                  generate_process_id:                              ;生成唯一的进程标识
   894                                                                                    ;返回：RAX=进程标识
   895 000009D3 B801000000                       mov rax, 1
   896 000009D8 F0480FC105EAFFFFFF               lock xadd qword [rel _process_id], rax
   897                                  
   898 000009E1 C3                               ret
   899                                  
   900                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   901 000009E2 0000000000000000          _thread_id dq 0
   902                                  
   903                                  generate_thread_id:                               ;生成唯一的线程标识
   904                                                                                    ;返回：RAX=线程标识
   905 000009EA B801000000                       mov rax, 1
   906 000009EF F0480FC105EAFFFFFF               lock xadd qword [rel _thread_id], rax
   907                                  
   908 000009F8 C3                               ret
   909                                  
   910                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   911 000009F9 08                        _screen_row        db 8
   912                                  get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   913                                                                                    ;返回：DH=行号
   914 000009FA B601                             mov dh, 1
   915 000009FC F00FC035F5FFFFFF                 lock xadd byte [rel _screen_row], dh
   916                                  
   917 00000A04 C3                               ret
   918                                  
   919                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   920                                  get_cpu_number:                                   ;返回当前处理器的编号
   921                                                                                    ;返回：RAX=处理器编号
   922 00000A05 9C                               pushfq
   923 00000A06 FA                               cli
   924 00000A07 0F01F8                           swapgs
   925 00000A0A 65488B042510000000               mov rax, [gs:16]                         ;从处理器专属数据区取回
   926 00000A13 0F01F8                           swapgs
   927 00000A16 9D                               popfq
   928 00000A17 C3                               ret
   929                                  
   930                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   931                                  memory_allocate:                                  ;用户空间的内存分配
   932                                                                                    ;进入：RDX=期望分配的字节数
   933                                                                                    ;输出：R13=所分配内存的起始线性地址
   934 00000A18 51                               push rcx
   935 00000A19 4153                             push r11
   936 00000A1B 4156                             push r14
   937                                  
   938 00000A1D 9C                               pushfq
   939 00000A1E FA                               cli
   940 00000A1F 0F01F8                           swapgs
   941 00000A22 654C8B1C2508000000               mov r11, [gs:8]                          ;取得当前任务的PCB线性地址
   942 00000A2B 0F01F8                           swapgs
   943 00000A2E 9D                               popfq
   944                                  
   945 00000A2F 4889D1                           mov rcx, rdx
   946 00000A32 E88FFEFFFF                       call user_memory_allocate
   947                                  
   948 00000A37 415E                             pop r14
   949 00000A39 415B                             pop r11
   950 00000A3B 59                               pop rcx
   951                                  
   952 00000A3C C3                               ret
   953                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
