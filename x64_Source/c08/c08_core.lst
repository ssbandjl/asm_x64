     1                                  ;c08_core.asm：多处理器多线程内核，李忠，2022-11-27
     2                                  
     3                                  %define __MP__
     4                                  
     5                                  %include "..\common\global_defs.wid"
     6                              <1> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
     7                              <1> 
     8                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     9                              <1> 
    10                              <1> %ifndef _GLOBAL_DEFS_
    11                              <1>    %define _GLOBAL_DEFS_
    12                              <1> 
    13                              <1>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    14                              <1>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    15                              <1>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    16                              <1>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    17                              <1>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    18                              <1>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    19                              <1>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    20                              <1>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    21                              <1>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    22                              <1>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    23                              <1>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    24                              <1> 	                                        ;页目录指针表
    25                              <1>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    26                              <1>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    27                              <1> 
    28                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    29                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    30                              <1> 
    31                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    32                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    33                              <1> 	                                                                ;端起始线性地址
    34                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    35                              <1> 	                                                                ;性地址
    36                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    37                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    38                              <1> 
    39                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    40                              <1>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    41                              <1>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    42                              <1>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
    43                              <1>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
    44                              <1>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
    45                              <1> 
    46                              <1>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
    47                              <1>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
    48                              <1> 			;时的起始地址
    49                              <1>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
    50                              <1> 			;时的起始地址
    51                              <1> 
    52                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    53                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
    54                              <1> 
    55                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
    56                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
    57                              <1> 
    58                              <1>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
    59                              <1> 
    60                              <1>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
    61                              <1> 
    62                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    63                              <1>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
    64                              <1>             %%spin_lock:
    65                              <1>                        cmp %2, 0           	;锁是释放状态吗？
    66                              <1>                        je %%get_lock      	;获取锁
    67                              <1>                        pause
    68                              <1>                        jmp %%spin_lock    	;继续尝试获取锁
    69                              <1>             %%get_lock:
    70                              <1>                        mov %1, 1
    71                              <1>                        xchg %1, %2
    72                              <1>                        cmp %1, 0          	;交换前为零？
    73                              <1>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
    74                              <1>    %endmacro
    75                              <1> 
    76                              <1> %endif
    77                              <1> 
     6                                  
     7                                  ;===============================================================================
     8                                  section core_header                               ;内核程序头部
     9 00000000 [00000000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
    10 00000004 [6D190000]                init_entry   dd init                            ;#4：内核入口点
    11 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    12                                  
    13                                  ;===============================================================================
    14                                  section core_data                                 ;内核数据段
    15 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    15 00000009 6F7420737570706F72-
    15 00000012 746564206F72206461-
    15 0000001B 7461206572726F722E-
    15 00000024 0D0A00             
    16                                  
    17 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    18 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    19 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    20                                  
    21 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    22 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    23                                  
    24 00000131 00                        ack_cpus     db 0                               ;处理器初始化应答计数
    25                                  
    26 00000132 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    27                                  
    28 00000136 457865637574696E67-       welcome      db "Executing in 64-bit mode.Init MP", 249, 0
    28 0000013F 20696E2036342D6269-
    28 00000148 74206D6F64652E496E-
    28 00000151 6974204D50F900     
    29 00000158 204350552873292072-       cpu_init_ok  db " CPU(s) ready.", 0x0d, 0x0a, 0
    29 00000161 656164792E0D0A00   
    30                                  
    31 00000169 00<rep 100h>              buffer       times 256 db 0
    32                                  
    33 00000269 [960B000000000000]        sys_entry    dq get_screen_row                  ;#0  获取一个可用的屏幕行坐标
    34 00000271 [D00A000000000000]                     dq get_cmos_time                   ;#1  获取CMOS时间
    35 00000279 [1901000000000000]                     dq put_cstringxy64                 ;#2  在指定坐标打印字符串
    36 00000281 [AD17000000000000]                     dq create_process                  ;#3  创建任务
    37 00000289 [EE11000000000000]                     dq get_current_pid                 ;#4  获取当前任务的标识
    38 00000291 [1016000000000000]                     dq terminate_process               ;#5  终止当前任务
    39 00000299 [A10B000000000000]                     dq get_cpu_number                  ;#6  获取当前CPU的标识
    40 000002A1 [9B16000000000000]                     dq create_thread                   ;#7  创建线程
    41 000002A9 [D711000000000000]                     dq get_current_tid                 ;#8  获取当前线程的标识
    42 000002B1 [9F15000000000000]                     dq thread_exit                     ;#9  退出当前线程
    43 000002B9 [B40B000000000000]                     dq memory_allocate                 ;#10 用户空间内存分配
    44 000002C1 [3C12000000000000]                     dq waiting_for_a_thread            ;#11 等待指定的线程
    45 000002C9 [5113000000000000]                     dq init_mutex                      ;#12 初始化互斥锁
    46 000002D1 [7113000000000000]                     dq acquire_mutex                   ;#13 获取互斥锁
    47 000002D9 [8314000000000000]                     dq release_mutex                   ;#14 释放互斥锁
    48 000002E1 [8C14000000000000]                     dq thread_sleep                    ;#15 线程休眠
    49                                  
    50 000002E9 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    51                                  
    52                                  ;===============================================================================
    53                                  section core_code                                 ;内核代码段
    54                                  
    55                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    56                              <1> ;core_utils64.wid:供64位内核使用的例程集合，支持单处理器和多处理器环境。作者：李忠
    57                              <1> ;创建时间：2023-12-03由2021-11-7的单处理器版本和2022年的多处理器版本合并而成。
    58                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，方便内核代
    59                              <1> ;码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    60                              <1> ;在多处理器环境中使用时，需在内核程序中定义宏__MP__
    61                              <1> 
    62                              <1> %include "..\common\global_defs.wid"
    63                              <2> ;global_defs.wid:系统全局使用的常量定义。李忠，2021-09-05
    64                              <2> 
    65                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    66                              <2> 
    67                              <2> %ifndef _GLOBAL_DEFS_
    68                              <2>    %define _GLOBAL_DEFS_
    69                              <2> 
    70                              <2>    SDA_PHY_ADDR        equ     0x00007e00	;系统数据区的起始物理地址
    71                              <2>    PML5_PHY_ADDR       equ     0x00009000	;内核5级头表物理地址
    72                              <2>    PML4_PHY_ADDR       equ     0x0000a000	;内核4级头表物理地址
    73                              <2>    PDPT_PHY_ADDR       equ     0x0000b000	;对应于低端2MB的内核页目录指针表物理地址
    74                              <2>    PDT_PHY_ADDR        equ     0x0000c000	;对应于低端2MB的页目录表物理地址
    75                              <2>    PT_PHY_ADDR         equ     0x0000d000	;对应于低端2MB的内核页表的物理地址
    76                              <2>    IDT_PHY_ADDR        equ     0x0000e000	;中断描述符表的物理地址
    77                              <2>    LDR_PHY_ADDR        equ     0x0000f000	;用于安装内核加载器的起始物理地址
    78                              <2>    GDT_PHY_ADDR        equ     0x00010000	;全局描述符表GDT的物理地址
    79                              <2>    CORE_PHY_ADDR       equ     0x00020000	;内核的起始物理地址
    80                              <2>    COR_PDPT_ADDR       equ     0x00100000	;从这个物理地址开始的1MB是内核的254个
    81                              <2> 	                                        ;页目录指针表
    82                              <2>    LDR_START_SECTOR    equ     1      	        ;内核加载器在硬盘上的起始逻辑扇区号
    83                              <2>    COR_START_SECTOR    equ     9      	        ;内核程序在硬盘上的起始逻辑扇区号
    84                              <2> 
    85                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    86                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    87                              <2> 
    88                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR	;内核的高端线性地址
    89                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000	        ;文本显示缓冲区的高
    90                              <2> 	                                                                ;端起始线性地址
    91                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR	;系统数据区的高端线
    92                              <2> 	                                                                ;性地址
    93                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR	;GDT的高端线性地址
    94                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR	;IDT的高端线性地址
    95                              <2> 
    96                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    97                              <2>    CORE_CODE64_SEL     equ     0x0018	;内核代码段的描述符选择子（RPL=00）
    98                              <2>    CORE_STACK64_SEL    equ     0x0020	;内核栈段的描述符选择子（RPL=00）
    99                              <2>    RESVD_DESC_SEL      equ     0x002b	;保留的描述符选择子
   100                              <2>    USER_CODE64_SEL     equ     0x003b	;3特权级代码段的描述符选择子（RPL=11）
   101                              <2>    USER_STACK64_SEL    equ     0x0033	;3特权级栈段的描述符选择子（RPL=11）
   102                              <2> 
   103                              <2>    PHY_MEMORY_SIZE     equ     32    	;物理内存大小（MB），要求至少3MB
   104                              <2>    CORE_ALLOC_START    equ     0xffff800000200000	;在虚拟地址空间高端（内核）分配内存
   105                              <2> 			;时的起始地址
   106                              <2>    USER_ALLOC_START    equ     0x0000000000000000	;在每个任务虚拟地址空间低端分配内存
   107                              <2> 			;时的起始地址
   108                              <2> 
   109                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
   110                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000	;用来映射新任务4级头表的线性地址
   111                              <2> 
   112                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000	;LOCAL APIC寄存器的起始线性地址
   113                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000	;I/O APIC寄存器的起始线性地址
   114                              <2> 
   115                              <2>    AP_START_UP_ADDR    equ     0x0000f000 	;应用处理器（AP）启动代码的物理地址
   116                              <2> 
   117                              <2>    SUGG_PREEM_SLICE    equ     55          	;推荐的任务/线程抢占时间片长度（毫秒）
   118                              <2> 
   119                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   120                              <2>    %macro   SET_SPIN_LOCK 2               	;两个参数，分别是寄存器%1和锁变量%2
   121                              <2>             %%spin_lock:
   122                              <2>                        cmp %2, 0           	;锁是释放状态吗？
   123                              <2>                        je %%get_lock      	;获取锁
   124                              <2>                        pause
   125                              <2>                        jmp %%spin_lock    	;继续尝试获取锁
   126                              <2>             %%get_lock:
   127                              <2>                        mov %1, 1
   128                              <2>                        xchg %1, %2
   129                              <2>                        cmp %1, 0          	;交换前为零？
   130                              <2>                        jne %%spin_lock   	;已有程序抢先加锁，失败重来
   131                              <2>    %endmacro
   132                              <2> 
   133                              <2> %endif
   134                              <2> 
    63                              <1> 
    64                              <1>          bits 64
    65                              <1> 
    66                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    67                              <1> %ifdef __MP__
    68 00000000 0000000000000000    <1> _prn_str_locker dq 0                  	;打印锁
    69                              <1> %endif
    70                              <1> 
    71                              <1> put_string64:       	;显示0终止的字符串并移动光标
    72                              <1>                      	;输入：RBX=字符串的线性地址
    73 00000008 53                  <1>          push rbx
    74 00000009 51                  <1>          push rcx
    75                              <1> 
    76 0000000A 9C                  <1>          pushfq     	;-->A
    77 0000000B FA                  <1>          cli
    78                              <1> %ifdef __MP__
    79                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    64                              <2>  %%spin_lock:
    65 0000000C 48833DECFFFFFF00    <2>  cmp %2, 0
    66 00000014 7404                <2>  je %%get_lock
    67 00000016 F390                <2>  pause
    68 00000018 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000001A B901000000          <2>  mov %1, 1
    71 0000001F 48870DDAFFFFFF      <2>  xchg %1, %2
    72 00000026 4883F900            <2>  cmp %1, 0
    73 0000002A 75E0                <2>  jne %%spin_lock
    80                              <1> %endif
    81                              <1> 
    82                              <1>   .getc:
    83 0000002C 8A0B                <1>          mov cl, [rbx]
    84 0000002E 08C9                <1>          or cl, cl                	;检测串结束标志（0）
    85 00000030 740A                <1>          jz .exit                 	;显示完毕，返回
    86 00000032 E814000000          <1>          call put_char
    87 00000037 48FFC3              <1>          inc rbx
    88 0000003A EBF0                <1>          jmp .getc
    89                              <1> 
    90                              <1>   .exit:
    91                              <1> %ifdef __MP__
    92 0000003C 48C705B9FFFFFF0000- <1>          mov qword [rel _prn_str_locker], 0	;释放锁
    92 00000045 0000                <1>
    93                              <1> %endif
    94 00000047 9D                  <1>          popfq                               	;A
    95                              <1> 
    96 00000048 59                  <1>          pop rcx
    97 00000049 5B                  <1>          pop rbx
    98                              <1> 
    99 0000004A C3                  <1>          ret                                	;段内返回
   100                              <1> 
   101                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   102                              <1> put_char:                                 	;在屏幕上的当前光标处显示一个字符并推
   103                              <1> 	;进光标。
   104                              <1>                                            	;输入：CL=字符ASCII码
   105 0000004B 50                  <1>          push rax
   106 0000004C 53                  <1>          push rbx
   107 0000004D 51                  <1>          push rcx
   108 0000004E 52                  <1>          push rdx
   109 0000004F 56                  <1>          push rsi
   110 00000050 57                  <1>          push rdi
   111                              <1> 
   112                              <1>          ;以下取当前光标位置
   113 00000051 66BAD403            <1>          mov dx, 0x3d4
   114 00000055 B00E                <1>          mov al, 0x0e
   115 00000057 EE                  <1>          out dx, al
   116 00000058 66FFC2              <1>          inc dx                        	;0x3d5
   117 0000005B EC                  <1>          in al, dx                     	;高字
   118 0000005C 88C4                <1>          mov ah, al
   119                              <1> 
   120 0000005E 66FFCA              <1>          dec dx                        	;0x3d4
   121 00000061 B00F                <1>          mov al, 0x0f
   122 00000063 EE                  <1>          out dx, al
   123 00000064 66FFC2              <1>          inc dx                        	;0x3d5
   124 00000067 EC                  <1>          in al, dx                     	;低字
   125 00000068 6689C3              <1>          mov bx, ax                    	;BX=代表光标位置的16位数
   126 0000006B 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff 	;准备使用64位寻址方式访问显存
   127                              <1> 
   128 00000072 80F90D              <1>          cmp cl, 0x0d                  	;回车符？
   129 00000075 750E                <1>          jnz .put_0a
   130 00000077 6689D8              <1>          mov ax, bx
   131 0000007A B350                <1>          mov bl, 80
   132 0000007C F6F3                <1>          div bl
   133 0000007E F6E3                <1>          mul bl
   134 00000080 6689C3              <1>          mov bx, ax
   135 00000083 EB6C                <1>          jmp .set_cursor
   136                              <1> 
   137                              <1>   .put_0a:
   138 00000085 80F90A              <1>          cmp cl, 0x0a                 	;换行符？
   139 00000088 7506                <1>          jnz .put_other
   140 0000008A 6683C350            <1>          add bx, 80
   141 0000008E EB16                <1>          jmp .roll_screen
   142                              <1> 
   143                              <1>   .put_other:                              	;正常显示字符
   144 00000090 66D1E3              <1>          shl bx, 1
   145 00000093 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO       	;在global_defs.wid中定义
   145 0000009C FF                  <1>
   146 0000009D 880C18              <1>          mov [rax + rbx], cl
   147                              <1> 
   148                              <1>          ;以下将光标位置推进一个字符
   149 000000A0 66D1EB              <1>          shr bx, 1
   150 000000A3 66FFC3              <1>          inc bx
   151                              <1> 
   152                              <1>   .roll_screen:
   153 000000A6 6681FBD007          <1>          cmp bx, 2000                       	;光标超出屏幕？滚屏
   154 000000AB 7C44                <1>          jl .set_cursor
   155                              <1> 
   156 000000AD 6653                <1>          push bx
   157                              <1> 
   158 000000AF FC                  <1>          cld
   159 000000B0 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0   	;小心！64位模式下movsq
   159 000000B9 FF                  <1>
   160 000000BA 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO          	;使用的是rsi/rdi/rcx
   160 000000C3 FF                  <1>
   161 000000C4 B9E0010000          <1>          mov rcx, 480
   162 000000C9 F348A5              <1>          rep movsq
   163 000000CC 66BB000F            <1>          mov bx, 3840                        	;清除屏幕最底一行
   164 000000D0 B950000000          <1>          mov rcx, 80                         	;64位程序应该使用RCX
   165                              <1>   .cls:
   166 000000D5 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   166 000000DE FF                  <1>
   167 000000DF 66C704182007        <1>          mov word[rax + rbx], 0x0720
   168 000000E5 6683C302            <1>          add bx, 2
   169 000000E9 E2EA                <1>          loop .cls
   170                              <1> 
   171 000000EB 665B                <1>          pop bx
   172 000000ED 6683EB50            <1>          sub bx, 80
   173                              <1> 
   174                              <1>   .set_cursor:
   175 000000F1 66BAD403            <1>          mov dx, 0x3d4
   176 000000F5 B00E                <1>          mov al, 0x0e
   177 000000F7 EE                  <1>          out dx, al
   178 000000F8 66FFC2              <1>          inc dx                         	;0x3d5
   179 000000FB 88F8                <1>          mov al, bh
   180 000000FD EE                  <1>          out dx, al
   181 000000FE 66FFCA              <1>          dec dx       	;0x3d4
   182 00000101 B00F                <1>          mov al, 0x0f
   183 00000103 EE                  <1>          out dx, al
   184 00000104 66FFC2              <1>          inc dx       	;0x3d5
   185 00000107 88D8                <1>          mov al, bl
   186 00000109 EE                  <1>          out dx, al
   187                              <1> 
   188 0000010A 5F                  <1>          pop rdi
   189 0000010B 5E                  <1>          pop rsi
   190 0000010C 5A                  <1>          pop rdx
   191 0000010D 59                  <1>          pop rcx
   192 0000010E 5B                  <1>          pop rbx
   193 0000010F 58                  <1>          pop rax
   194                              <1> 
   195 00000110 C3                  <1>          ret
   196                              <1> 
   197                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   198                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的坐标位置
   199                              <1> ;不同，互不干扰，不需要加锁和互斥。
   200                              <1> %ifdef __MP__
   201 00000111 0000000000000000    <1> _prnxy_locker dq 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> put_cstringxy64:                         	;输入：RBX=字符串首地址
   205                              <1>                                           	;DH=行，DL=列
   206                              <1>                                           	;R9B=颜色属性
   207 00000119 50                  <1>          push rax
   208 0000011A 53                  <1>          push rbx
   209 0000011B 51                  <1>          push rcx
   210 0000011C 52                  <1>          push rdx
   211 0000011D 4150                <1>          push r8
   212                              <1> 
   213                              <1>          ;指定坐标位置在显存内的偏移量
   214 0000011F 88F0                <1>          mov al, dh
   215 00000121 B5A0                <1>          mov ch, 160                   	;每一行80个字符，占用160个字节
   216 00000123 F6E5                <1>          mul ch
   217 00000125 D0E2                <1>          shl dl, 1                     	;每个字符（列）占用2个字节，要乘以2
   218 00000127 6681E2FF00          <1>          and dx, 0x00ff
   219 0000012C 6601D0              <1>          add ax, dx                    	;得到指定坐标位置在显存内的偏移量
   220 0000012F 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   221                              <1> 
   222 00000135 9C                  <1>          pushfq                        	;-->A
   223 00000136 FA                  <1>          cli
   224                              <1> %ifdef __MP__
   225                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    64                              <2>  %%spin_lock:
    65 00000137 48833DD2FFFFFF00    <2>  cmp %2, 0
    66 0000013F 7404                <2>  je %%get_lock
    67 00000141 F390                <2>  pause
    68 00000143 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000145 41B801000000        <2>  mov %1, 1
    71 0000014B 4C8705BFFFFFFF      <2>  xchg %1, %2
    72 00000152 4983F800            <2>  cmp %1, 0
    73 00000156 75DF                <2>  jne %%spin_lock
   226                              <1> %endif
   227                              <1> 
   228 00000158 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO     	;显存的起始线性地址
   228 00000161 FF                  <1>
   229                              <1>   .nextc:
   230 00000162 8A13                <1>          mov dl, [rbx]                 	;取得将要显示的字符
   231 00000164 08D2                <1>          or dl, dl
   232 00000166 7412                <1>          jz .exit
   233 00000168 41881400            <1>          mov byte [r8 + rax], dl
   234 0000016C 45884C0001          <1>          mov byte [r8 + rax + 1], r9b     	;字符颜色
   235 00000171 48FFC3              <1>          inc rbx
   236 00000174 4883C002            <1>          add rax, 2                    	;增加一个字符的位置（2个字节）
   237 00000178 EBE8                <1>          jmp .nextc
   238                              <1>   .exit:
   239 0000017A 4D31C0              <1>          xor r8, r8
   240                              <1> %ifdef __MP__
   241 0000017D 48C70589FFFFFF0000- <1>          mov qword [rel _prnxy_locker], 0 	;释放锁
   241 00000186 0000                <1>
   242                              <1> %endif
   243 00000188 9D                  <1>          popfq                              	;A
   244                              <1> 
   245 00000189 4158                <1>          pop r8
   246 0000018B 5A                  <1>          pop rdx
   247 0000018C 59                  <1>          pop rcx
   248 0000018D 5B                  <1>          pop rbx
   249 0000018E 58                  <1>          pop rax
   250                              <1> 
   251 0000018F C3                  <1>          ret
   252                              <1> 
   253                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   254                              <1> make_call_gate:                          	;创建64位的调用门
   255                              <1>                                           	;输入：RAX=例程的线性地址
   256                              <1>                                           	;输出：RDI:RSI=调用门
   257 00000190 4889C7              <1>          mov rdi, rax
   258 00000193 48C1EF20            <1>          shr rdi, 32                     	;得到门的高64位，在RDI中
   259                              <1> 
   260 00000197 50                  <1>          push rax                        	;构造数据结构，并预置线性地址的位15~0
   261 00000198 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   262 0000019F 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   263 000001A3 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00         	;添加P=1，TYPE=64位调用门
   264 000001AA 5E                  <1>          pop rsi
   265                              <1> 
   266 000001AB C3                  <1>          ret
   267                              <1> 
   268                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   269                              <1> make_interrupt_gate:                      	;创建64位的中断门
   270                              <1>                                             	;输入：RAX=例程的线性地址
   271                              <1>                                             	;输出：RDI:RSI=中断门
   272 000001AC 4889C7              <1>          mov rdi, rax
   273 000001AF 48C1EF20            <1>          shr rdi, 32                       	;得到门的高64位，在RDI中
   274                              <1> 
   275 000001B3 50                  <1>          push rax                          	;构造数据结构，并预置线性地址的位15~0
   276 000001B4 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   277 000001BB 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   278 000001BF 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00         	;添加P=1，TYPE=64位中断门
   279 000001C6 5E                  <1>          pop rsi
   280                              <1> 
   281 000001C7 C3                  <1>          ret
   282                              <1> 
   283                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   284                              <1> make_trap_gate:                             	;创建64位的陷阱门
   285                              <1>                                              	;输入：RAX=例程的线性地址
   286                              <1>                                              	;输出：RDI:RSI=陷阱门
   287 000001C8 4889C7              <1>          mov rdi, rax
   288 000001CB 48C1EF20            <1>          shr rdi, 32                        	;得到门的高64位，在RDI中
   289                              <1> 
   290 000001CF 50                  <1>          push rax                           	;构造数据结构，并预置线性地址的位15~0
   291 000001D0 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL	;预置段选择子部分
   292 000001D7 89442404            <1>          mov [rsp + 4], eax                  	;预置线性地址的位31~16
   293 000001DB 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00         	;添加P=1，TYPE=64位陷阱门
   294 000001E2 5E                  <1>          pop rsi
   295                              <1> 
   296 000001E3 C3                  <1>          ret
   297                              <1> 
   298                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   299                              <1> make_tss_descriptor:                    	;创建64位的TSS描述符
   300                              <1>                                           	;输入：RAX=TSS的线性地址
   301                              <1>                                           	;输出：RDI:RSI=TSS描述符
   302 000001E4 50                  <1>          push rax
   303                              <1> 
   304 000001E5 4889C7              <1>          mov rdi, rax
   305 000001E8 48C1EF20            <1>          shr rdi, 32                    	;得到门的高64位，在RDI中
   306                              <1> 
   307 000001EC 50                  <1>          push rax                       	;先将部分线性地址移到适当位置
   308 000001ED 48C1242410          <1>          shl qword [rsp], 16           	;将线性地址的位23~00移到正确位置
   309 000001F2 66C704246800        <1>          mov word [rsp], 104           	;段界限的标准长度
   310 000001F8 8A442405            <1>          mov al, [rsp + 5]
   311 000001FC 88442407            <1>          mov [rsp + 7], al             	;将线性地址的位31~24移到正确位置
   312 00000200 C644240589          <1>          mov byte [rsp + 5], 0x89     	;P=1，DPL=00，TYPE=1001（64位TSS）
   313 00000205 C644240600          <1>          mov byte [rsp + 6], 0        	;G、0、0、AVL和limit
   314 0000020A 5E                  <1>          pop rsi                       	;门的低64位
   315                              <1> 
   316 0000020B 58                  <1>          pop rax
   317                              <1> 
   318 0000020C C3                  <1>          ret
   319                              <1> 
   320                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   321                              <1> mount_idt_entry:                     	;在中断描述符表IDT中安装门描述符
   322                              <1>                                        	;R8=中断向量
   323                              <1>                                        	;RDI:RSI=门描述符
   324 0000020D 4150                <1>          push r8
   325 0000020F 4151                <1>          push r9
   326                              <1> 
   327 00000211 49C1E004            <1>          shl r8, 4                         	;中断号乘以16，得到表内偏移
   328 00000215 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR        	;中断描述符表的高端线性地址
   328 0000021E FF                  <1>
   329 0000021F 4B893401            <1>          mov [r9 + r8], rsi
   330 00000223 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   331                              <1> 
   332 00000228 4159                <1>          pop r9
   333 0000022A 4158                <1>          pop r8
   334                              <1> 
   335 0000022C C3                  <1>          ret
   336                              <1> 
   337                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   338                              <1> init_8259:                              	;初始化8259中断控制器，包括重新设置向量号
   339 0000022D 50                  <1>          push rax
   340                              <1> 
   341 0000022E B011                <1>          mov al, 0x11
   342 00000230 E620                <1>          out 0x20, al                    	;ICW1：边沿触发/级联方式
   343 00000232 B020                <1>          mov al, 0x20
   344 00000234 E621                <1>          out 0x21, al  	;ICW2:起始中断向量（避开前31个异常的向量）
   345 00000236 B004                <1>          mov al, 0x04
   346 00000238 E621                <1>          out 0x21, al  	;ICW3:从片级联到IR2
   347 0000023A B001                <1>          mov al, 0x01
   348 0000023C E621                <1>          out 0x21, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   349                              <1> 
   350 0000023E B011                <1>          mov al, 0x11
   351 00000240 E6A0                <1>          out 0xa0, al                  	;ICW1：边沿触发/级联方式
   352 00000242 B028                <1>          mov al, 0x28
   353 00000244 E6A1                <1>          out 0xa1, al                  	;ICW2:起始中断向量-->0x28
   354 00000246 B002                <1>          mov al, 0x02
   355 00000248 E6A1                <1>          out 0xa1, al                  	;ICW3:从片识别标志，级联到主片IR2
   356 0000024A B001                <1>          mov al, 0x01
   357 0000024C E6A1                <1>          out 0xa1, al                  	;ICW4:非总线缓冲，全嵌套，正常EOI
   358                              <1> 
   359 0000024E 58                  <1>          pop rax
   360 0000024F C3                  <1>          ret
   361                              <1> 
   362                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   363                              <1> %ifdef __MP__
   364 00000250 0000000000000000    <1> _read_hdd_locker dq 0                 	;读硬盘锁
   365                              <1> %endif
   366                              <1> 
   367                              <1> read_hard_disk_0:                     	;从硬盘读取一个逻辑扇区
   368                              <1>                                         	;RAX=逻辑扇区号
   369                              <1>                                         	;RBX=目标缓冲区线性地址
   370                              <1>                                         	;返回：RBX=RBX+512
   371 00000258 50                  <1>          push rax
   372 00000259 51                  <1>          push rcx
   373 0000025A 52                  <1>          push rdx
   374                              <1> 
   375 0000025B 9C                  <1>          pushfq                     	;-->A
   376 0000025C FA                  <1>          cli
   377                              <1> %ifdef __MP__
   378                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    64                              <2>  %%spin_lock:
    65 0000025D 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 00000265 7404                <2>  je %%get_lock
    67 00000267 F390                <2>  pause
    68 00000269 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000026B BA01000000          <2>  mov %1, 1
    71 00000270 488715D9FFFFFF      <2>  xchg %1, %2
    72 00000277 4883FA00            <2>  cmp %1, 0
    73 0000027B 75E0                <2>  jne %%spin_lock
   379                              <1> %endif
   380                              <1> 
   381 0000027D 50                  <1>          push rax
   382                              <1> 
   383 0000027E 66BAF201            <1>          mov dx, 0x1f2
   384 00000282 B001                <1>          mov al, 1
   385 00000284 EE                  <1>          out dx, al                	;读取的扇区数
   386                              <1> 
   387 00000285 66FFC2              <1>          inc dx                    	;0x1f3
   388 00000288 58                  <1>          pop rax
   389 00000289 EE                  <1>          out dx, al               	;LBA地址7~0
   390                              <1> 
   391 0000028A 66FFC2              <1>          inc dx                   	;0x1f4
   392 0000028D B108                <1>          mov cl, 8
   393 0000028F 48D3E8              <1>          shr rax, cl
   394 00000292 EE                  <1>          out dx, al   	;LBA地址15~8
   395                              <1> 
   396 00000293 66FFC2              <1>          inc dx       	;0x1f5
   397 00000296 48D3E8              <1>          shr rax, cl
   398 00000299 EE                  <1>          out dx, al  	;LBA地址23~16
   399                              <1> 
   400 0000029A 66FFC2              <1>          inc dx       	;0x1f6
   401 0000029D 48D3E8              <1>          shr rax, cl
   402 000002A0 0CE0                <1>          or al, 0xe0  	;第一硬盘  LBA地址27~24
   403 000002A2 EE                  <1>          out dx, al
   404                              <1> 
   405 000002A3 66FFC2              <1>          inc dx       	;0x1f7
   406 000002A6 B020                <1>          mov al, 0x20 	;读命令
   407 000002A8 EE                  <1>          out dx, al
   408                              <1> 
   409                              <1>   .waits:
   410 000002A9 EC                  <1>          in al, dx
   411                              <1>          ;and al, 0x88
   412                              <1>          ;cmp al, 0x08
   413 000002AA A808                <1>          test al, 8
   414 000002AC 74FB                <1>          jz .waits              	;不忙，且硬盘已准备好数据传输
   415                              <1> 
   416 000002AE B900010000          <1>          mov rcx, 256                 			;总共要读取的字数
   417 000002B3 66BAF001            <1>          mov dx, 0x1f0
   418                              <1>   .readw:
   419 000002B7 66ED                <1>          in ax, dx
   420 000002B9 668903              <1>          mov [rbx], ax
   421 000002BC 4883C302            <1>          add rbx, 2
   422 000002C0 E2F5                <1>          loop .readw
   423                              <1> 
   424                              <1> %ifdef __MP__
   425 000002C2 48C70583FFFFFF0000- <1>          mov qword [rel _read_hdd_locker], 0			;释放锁
   425 000002CB 0000                <1>
   426                              <1> %endif
   427 000002CD 9D                  <1>          popfq                              			;A
   428                              <1> 
   429 000002CE 5A                  <1>          pop rdx
   430 000002CF 59                  <1>          pop rcx
   431 000002D0 58                  <1>          pop rax
   432                              <1> 
   433 000002D1 C3                  <1>          ret
   434                              <1> 
   435                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   436 000002D2 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          	;对应物理内存的前512个页面（2MB）
   437 00000312 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 	;对应后续的页面
   438                              <1>   _page_map_len  equ $ - _page_bit_map
   439                              <1> 
   440                              <1> allocate_a_4k_page:                       			;分配一个4KB的页
   441                              <1>                                             			;输入：无
   442                              <1>                                             			;输出：RAX=页的物理地址
   443 000006D2 4831C0              <1>          xor rax, rax
   444                              <1>   .b1:
   445 000006D5 F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax			;多处理器需要lock，单处理器不需要
   446 000006DE 730B                <1>          jnc .b2
   447 000006E0 48FFC0              <1>          inc rax
   448 000006E3 483D00200000        <1>          cmp rax, _page_map_len * 8      			;立即数符号扩展到64位进行比较
   449 000006E9 7CEA                <1>          jl .b1
   450                              <1> 
   451                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的系统来说，
   452                              <1>          ;如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注销的页面，或者执行页
   453                              <1>          ;面的换入和换出。
   454                              <1> 
   455                              <1>   .b2:
   456 000006EB 48C1E00C            <1>          shl rax, 12                         			;乘以4096（0x1000）
   457                              <1> 
   458 000006EF C3                  <1>          ret
   459                              <1> 
   460                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   461                              <1> lin_to_lin_of_pml4e:     	;返回指定的线性地址所对应的4级头表项的线性地址
   462                              <1>                                      	;输入：R13=线性地址
   463                              <1>                                      	;输出：R14=对应的4级头表项的线性地址
   464 000006F0 4155                <1>          push r13
   465                              <1> 
   466 000006F2 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000 	;保留4级头表索引部分
   466 000006FB 00                  <1>
   467 000006FC 4D21F5              <1>          and r13, r14
   468 000006FF 49C1ED24            <1>          shr r13, 36                   	;原4级头表索引变成页内偏移
   469                              <1> 
   470 00000703 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000  	;访问4级头表所用的地址前缀
   471 0000070A 4D01EE              <1>          add r14, r13
   472                              <1> 
   473 0000070D 415D                <1>          pop r13
   474                              <1> 
   475 0000070F C3                  <1>          ret
   476                              <1> 
   477                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   478                              <1> lin_to_lin_of_pdpte:    	;返回指定的线性地址所对应的页目录指针项的线性地址
   479                              <1>                                     	;输入：R13=线性地址
   480                              <1>                                     	;输出：R14=对应的页目录指针项的线性地址
   481 00000710 4155                <1>          push r13
   482                              <1> 
   483 00000712 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000	;保留4级头表索引和页目录指针表索引部分
   483 0000071B 00                  <1>
   484 0000071C 4D21F5              <1>          and r13, r14
   485 0000071F 49C1ED1B            <1>          shr r13, 27      	;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   486                              <1> 
   487 00000723 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000	;访问页目录指针表所用的地址前缀
   488 0000072A 4D01EE              <1>          add r14, r13
   489                              <1> 
   490 0000072D 415D                <1>          pop r13
   491                              <1> 
   492 0000072F C3                  <1>          ret
   493                              <1> 
   494                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   495                              <1> lin_to_lin_of_pdte:                	;返回指定的线性地址所对应的页目录项的线性地址
   496                              <1>                                      	;输入：R13=线性地址
   497                              <1>                                      	;输出：R14=对应的页目录项的线性地址
   498 00000730 4155                <1>          push r13
   499                              <1> 
   500 00000732 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000	;保留4级头表索引、页目录指针表索引和页目录表
   500 0000073B 00                  <1>
   501                              <1> 	                                ;索引部分
   502 0000073C 4D21F5              <1>          and r13, r14
   503 0000073F 49C1ED12            <1>          shr r13, 18       		;原4级头表索引变成页目录表索引，原页目录指针
   504                              <1> 		                        ;表索引变页表索引，原页目录表索引变页内偏移
   505 00000743 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000	;访问页目录表所用的地址前缀
   506 0000074A 4D01EE              <1>          add r14, r13
   507 0000074D 415D                <1>          pop r13
   508                              <1> 
   509 0000074F C3                  <1>          ret
   510                              <1> 
   511                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   512                              <1> lin_to_lin_of_pte:               	;返回指定的线性地址所对应的页表项的线性地址
   513                              <1>                                    	;输入：R13=线性地址
   514                              <1>                                    	;输出：R14=对应的页表项的线性地址
   515 00000750 4155                <1>          push r13
   516                              <1> 
   517 00000752 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000	;保留4级头表、页目录指针表、页目录表和页表的
   517 0000075B 00                  <1>
   518                              <1> 	                                ;索引部分
   519 0000075C 4D21F5              <1>          and r13, r14
   520 0000075F 49C1ED09            <1>          shr r13, 9         	        ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   521                              <1>                            	        ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   522 00000763 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000	;访问页表所用的地址前缀
   522 0000076C FF                  <1>
   523 0000076D 4D01EE              <1>          add r14, r13
   524                              <1> 
   525 00000770 415D                <1>          pop r13
   526 00000772 C3                  <1>          ret
   527                              <1> 
   528                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   529                              <1> %ifdef __MP__
   530 00000773 0000000000000000    <1> _spaging_locker dq 0
   531                              <1> %endif
   532                              <1> 
   533                              <1> setup_paging_for_laddr:          	;为指定的线性地址安装分页系统（表项）
   534                              <1>                                    	;输入：R13=线性地址
   535 0000077B 51                  <1>          push rcx
   536 0000077C 50                  <1>          push rax
   537 0000077D 4156                <1>          push r14
   538                              <1> 
   539 0000077F 9C                  <1>          pushfq                   	;-->A
   540 00000780 FA                  <1>          cli
   541                              <1> %ifdef __MP__
   542                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    64                              <2>  %%spin_lock:
    65 00000781 48833DEAFFFFFF00    <2>  cmp %2, 0
    66 00000789 7404                <2>  je %%get_lock
    67 0000078B F390                <2>  pause
    68 0000078D EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000078F 41BE01000000        <2>  mov %1, 1
    71 00000795 4C8735D7FFFFFF      <2>  xchg %1, %2
    72 0000079C 4983FE00            <2>  cmp %1, 0
    73 000007A0 75DF                <2>  jne %%spin_lock
   543                              <1> %endif
   544                              <1> 
   545                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   546                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   547 000007A2 E849FFFFFF          <1>          call lin_to_lin_of_pml4e    	;得到4级头表项的线性地址
   548 000007A7 49F70601000000      <1>          test qword [r14], 1         	;P位是否为“1”。表项是否存在？
   549 000007AE 752B                <1>          jnz .b0
   550                              <1> 
   551                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   552 000007B0 E81DFFFFFF          <1>          call allocate_a_4k_page        	;分配一个页做为页目录指针表
   553 000007B5 4883C807            <1>          or rax, 0x07                    	;添加属性位 U/S=R/W=P=1
   554 000007B9 498906              <1>          mov [r14], rax                  	;在4级头表中登记4级头表项（页目录指针表地址）
   555                              <1> 
   556                              <1>          ;清空刚分配的页目录指针表
   557 000007BC E84FFFFFFF          <1>          call lin_to_lin_of_pdpte
   558 000007C1 49C1EE0C            <1>          shr r14, 12
   559 000007C5 49C1E60C            <1>          shl r14, 12                   	;得到页目录指针表的线性地址
   560 000007C9 B900020000          <1>          mov rcx, 512
   561                              <1>   .cls0:
   562 000007CE 49C70600000000      <1>          mov qword [r14], 0
   563 000007D5 4983C608            <1>          add r14, 8
   564 000007D9 E2F3                <1>          loop .cls0
   565                              <1> ;-------------------------------------------------
   566                              <1>   .b0:
   567                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   568 000007DB E830FFFFFF          <1>          call lin_to_lin_of_pdpte      	;得到页目录指针项的线性地址
   569 000007E0 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   570 000007E7 752B                <1>          jnz .b1                        	;页目录指针项是存在的，转.b1
   571                              <1> 
   572                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   573 000007E9 E8E4FEFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页目录表
   574 000007EE 4883C807            <1>          or rax, 0x07                  	;添加属性位
   575 000007F2 498906              <1>          mov [r14], rax                	;在页目录指针表中登记页目录指针项（页目录表地址）
   576                              <1> 
   577                              <1>          ;清空刚分配的页目录表
   578 000007F5 E836FFFFFF          <1>          call lin_to_lin_of_pdte
   579 000007FA 49C1EE0C            <1>          shr r14, 12
   580 000007FE 49C1E60C            <1>          shl r14, 12                      	;得到页目录表的线性地址
   581 00000802 B900020000          <1>          mov rcx, 512
   582                              <1>   .cls1:
   583 00000807 49C70600000000      <1>          mov qword [r14], 0
   584 0000080E 4983C608            <1>          add r14, 8
   585 00000812 E2F3                <1>          loop .cls1
   586                              <1> ;-------------------------------------------------
   587                              <1>   .b1:
   588                              <1>          ;检查该线性地址所对应的页目录项是否存在
   589 00000814 E817FFFFFF          <1>          call lin_to_lin_of_pdte
   590 00000819 49F70601000000      <1>          test qword [r14], 1               	;P位是否为“1”。表项是否存在？
   591 00000820 752B                <1>          jnz .b2                            	;页目录项已存在，转.b2
   592                              <1> 
   593                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   594 00000822 E8ABFEFFFF          <1>          call allocate_a_4k_page          	;分配一个页做为页表
   595 00000827 4883C807            <1>          or rax, 0x07                      	;添加属性位
   596 0000082B 498906              <1>          mov [r14], rax                    	;在页目录表中登记页目录项（页表地址）
   597                              <1> 
   598                              <1>          ;清空刚分配的页表
   599 0000082E E81DFFFFFF          <1>          call lin_to_lin_of_pte
   600 00000833 49C1EE0C            <1>          shr r14, 12
   601 00000837 49C1E60C            <1>          shl r14, 12                       	;得到页表的线性地址
   602 0000083B B900020000          <1>          mov rcx, 512
   603                              <1>   .cls2:
   604 00000840 49C70600000000      <1>          mov qword [r14], 0
   605 00000847 4983C608            <1>          add r14, 8
   606 0000084B E2F3                <1>          loop .cls2
   607                              <1> ;-------------------------------------------------
   608                              <1>   .b2:
   609                              <1>          ;检查该线性地址所对应的页表项是否存在
   610 0000084D E8FEFEFFFF          <1>          call lin_to_lin_of_pte
   611 00000852 49F70601000000      <1>          test qword [r14], 1              	;P位是否为“1”。表项是否存在？
   612 00000859 750C                <1>          jnz .b3                           	;页表项已经存在，转.b3
   613                              <1> 
   614                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   615 0000085B E872FEFFFF          <1>          call allocate_a_4k_page         	;分配一个页
   616 00000860 4883C807            <1>          or rax, 0x07                     	;添加属性位
   617 00000864 498906              <1>          mov [r14], rax                   	;在页表中登记页表项（页的地址）
   618                              <1> 
   619                              <1>   .b3:
   620                              <1> %ifdef __MP__
   621 00000867 48C70501FFFFFF0000- <1>          mov qword [rel _spaging_locker], 0
   621 00000870 0000                <1>
   622                              <1> %endif
   623 00000872 9D                  <1>          popfq                      	;A
   624                              <1> 
   625 00000873 415E                <1>          pop r14
   626 00000875 58                  <1>          pop rax
   627 00000876 59                  <1>          pop rcx
   628                              <1> 
   629 00000877 C3                  <1>          ret
   630                              <1> 
   631                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   632                              <1> %ifdef __MP__
   633 00000878 0000000000000000    <1> _mapping_locker dq 0
   634                              <1> %endif
   635                              <1> 
   636                              <1> mapping_laddr_to_page:           	;建立线性地址到物理页的映射
   637                              <1>                                    	;即，为指定的线性地址安装指定的物理页
   638                              <1>                                    	;输入：R13=线性地址
   639                              <1>                                                    ;RAX=页的物理地址（含属性）
   640 00000880 51                  <1>          push rcx
   641 00000881 4156                <1>          push r14
   642                              <1> 
   643 00000883 9C                  <1>          pushfq
   644 00000884 FA                  <1>          cli
   645                              <1> %ifdef __MP__
   646                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    64                              <2>  %%spin_lock:
    65 00000885 48833DEBFFFFFF00    <2>  cmp %2, 0
    66 0000088D 7404                <2>  je %%get_lock
    67 0000088F F390                <2>  pause
    68 00000891 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000893 41BE01000000        <2>  mov %1, 1
    71 00000899 4C8735D8FFFFFF      <2>  xchg %1, %2
    72 000008A0 4983FE00            <2>  cmp %1, 0
    73 000008A4 75DF                <2>  jne %%spin_lock
   647                              <1> %endif
   648                              <1> 
   649 000008A6 50                  <1>          push rax
   650                              <1> 
   651                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   652                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   653 000008A7 E844FEFFFF          <1>          call lin_to_lin_of_pml4e 	;得到4级头表项的线性地址
   654 000008AC 49F70601000000      <1>          test qword [r14], 1      	;P位是否为“1”。表项是否存在？
   655 000008B3 752B                <1>          jnz .b0
   656                              <1> 
   657                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   658 000008B5 E818FEFFFF          <1>          call allocate_a_4k_page   	;分配一个页做为页目录指针表
   659 000008BA 4883C807            <1>          or rax, 0x07               	;添加属性位 U/S=R/W=P=1
   660 000008BE 498906              <1>          mov [r14], rax             	;在4级头表中登记4级头表项（页目录指针表地址）
   661                              <1> 
   662                              <1>          ;清空刚分配的页目录指针表
   663 000008C1 E84AFEFFFF          <1>          call lin_to_lin_of_pdpte
   664 000008C6 49C1EE0C            <1>          shr r14, 12
   665 000008CA 49C1E60C            <1>          shl r14, 12           	;得到页目录指针表的线性地址
   666 000008CE B900020000          <1>          mov rcx, 512
   667                              <1>   .cls0:
   668 000008D3 49C70600000000      <1>          mov qword [r14], 0
   669 000008DA 4983C608            <1>          add r14, 8
   670 000008DE E2F3                <1>          loop .cls0
   671                              <1> ;-------------------------------------------------
   672                              <1>   .b0:
   673                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   674 000008E0 E82BFEFFFF          <1>          call lin_to_lin_of_pdpte  	;得到页目录指针项的线性地址
   675 000008E5 49F70601000000      <1>          test qword [r14], 1       	;P位是否为“1”。表项是否存在？
   676 000008EC 752B                <1>          jnz .b1                    	;页目录指针项是存在的，转.b1
   677                              <1> 
   678                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   679 000008EE E8DFFDFFFF          <1>          call allocate_a_4k_page  	;分配一个页做为页目录表
   680 000008F3 4883C807            <1>          or rax, 0x07              	;添加属性位
   681 000008F7 498906              <1>          mov [r14], rax            	;在页目录指针表中登记页目录指针项（页目录表地址）
   682                              <1> 
   683                              <1>          ;清空刚分配的页目录表
   684 000008FA E831FEFFFF          <1>          call lin_to_lin_of_pdte
   685 000008FF 49C1EE0C            <1>          shr r14, 12
   686 00000903 49C1E60C            <1>          shl r14, 12                 	;得到页目录表的线性地址
   687 00000907 B900020000          <1>          mov rcx, 512
   688                              <1>   .cls1:
   689 0000090C 49C70600000000      <1>          mov qword [r14], 0
   690 00000913 4983C608            <1>          add r14, 8
   691 00000917 E2F3                <1>          loop .cls1
   692                              <1> ;-------------------------------------------------
   693                              <1>   .b1:
   694                              <1>          ;检查该线性地址所对应的页目录项是否存在
   695 00000919 E812FEFFFF          <1>          call lin_to_lin_of_pdte
   696 0000091E 49F70601000000      <1>          test qword [r14], 1           	;P位是否为“1”。表项是否存在？
   697 00000925 752B                <1>          jnz .b2                        ;页目录项已存在，转.b2
   698                              <1> 
   699                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   700 00000927 E8A6FDFFFF          <1>          call allocate_a_4k_page      	;分配一个页做为页表
   701 0000092C 4883C807            <1>          or rax, 0x07                  	;添加属性位
   702 00000930 498906              <1>          mov [r14], rax                	;在页目录表中登记页目录项（页表地址）
   703                              <1> 
   704                              <1>          ;清空刚分配的页表
   705 00000933 E818FEFFFF          <1>          call lin_to_lin_of_pte
   706 00000938 49C1EE0C            <1>          shr r14, 12
   707 0000093C 49C1E60C            <1>          shl r14, 12                   	;得到页表的线性地址
   708 00000940 B900020000          <1>          mov rcx, 512
   709                              <1>   .cls2:
   710 00000945 49C70600000000      <1>          mov qword [r14], 0
   711 0000094C 4983C608            <1>          add r14, 8
   712 00000950 E2F3                <1>          loop .cls2
   713                              <1> ;-------------------------------------------------
   714                              <1>   .b2:
   715 00000952 E8F9FDFFFF          <1>          call lin_to_lin_of_pte       	;得到页表项的线性地址
   716 00000957 58                  <1>          pop rax
   717 00000958 498906              <1>          mov [r14], rax                	;在页表中登记页表项（页的地址）
   718                              <1> 
   719                              <1> %ifdef __MP__
   720 0000095B 48C70512FFFFFF0000- <1>          mov qword [rel _mapping_locker], 0
   720 00000964 0000                <1>
   721                              <1> %endif
   722 00000966 9D                  <1>          popfq
   723                              <1> 
   724 00000967 415E                <1>          pop r14
   725 00000969 59                  <1>          pop rcx
   726                              <1> 
   727 0000096A C3                  <1>          ret
   728                              <1> 
   729                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   730 0000096B 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START 	;下一次分配时可用的起始线性地址
   731                              <1> 
   732                              <1> %ifdef __MP__
   733 00000973 0000000000000000    <1>   _core_alloc_locker dq 0
   734                              <1> %endif
   735                              <1> 
   736                              <1> core_memory_allocate:                 	        ;在虚拟地址空间的高端（内核）分配内存
   737                              <1>                                         	;输入：RCX=请求分配的字节数
   738                              <1>                                         	;输出：R13=本次分配的起始线性地址
   739                              <1>                                         	;      R14=下次分配的起始线性地址
   740 0000097B 9C                  <1>          pushfq                        	        ;A-->
   741 0000097C FA                  <1>          cli
   742                              <1> %ifdef __MP__
   743                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    64                              <2>  %%spin_lock:
    65 0000097D 48833DEEFFFFFF00    <2>  cmp %2, 0
    66 00000985 7404                <2>  je %%get_lock
    67 00000987 F390                <2>  pause
    68 00000989 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 0000098B 41BE01000000        <2>  mov %1, 1
    71 00000991 4C8735DBFFFFFF      <2>  xchg %1, %2
    72 00000998 4983FE00            <2>  cmp %1, 0
    73 0000099C 75DF                <2>  jne %%spin_lock
   744                              <1> %endif
   745                              <1> 
   746 0000099E 4C8B2DC6FFFFFF      <1>          mov r13, [rel _core_next_linear]  	;获得本次分配的起始线性地址
   747 000009A5 4D8D740D00          <1>          lea r14, [r13 + rcx]               	;下次分配时的起始线性地址
   748                              <1> 
   749 000009AA 49F7C607000000      <1>          test r14, 0x07                     	;最低3位是000吗（是否按8字节对齐）？
   750 000009B1 740C                <1>          jz .algn
   751 000009B3 4983C608            <1>          add r14, 0x08                      	;注：立即数符号扩展到64位参与操作
   752 000009B7 49C1EE03            <1>          shr r14, 3
   753 000009BB 49C1E603            <1>          shl r14, 3                       	;最低3个比特变成0，强制按8字节对齐。
   754                              <1> 
   755                              <1>   .algn:
   756 000009BF 4C8935A5FFFFFF      <1>          mov [rel _core_next_linear], r14 	;写回。
   757                              <1> 
   758                              <1> %ifdef __MP__
   759 000009C6 48C705A2FFFFFF0000- <1>          mov qword [rel _core_alloc_locker], 0	;释放锁
   759 000009CF 0000                <1>
   760                              <1> %endif
   761 000009D1 9D                  <1>          popfq                             	;A
   762                              <1> 
   763 000009D2 4155                <1>          push r13
   764 000009D4 4156                <1>          push r14
   765                              <1> 
   766                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   767 000009D6 49C1ED0C            <1>          shr r13, 12
   768 000009DA 49C1E50C            <1>          shl r13, 12                    	;清除掉页内偏移部分
   769 000009DE 49C1EE0C            <1>          shr r14, 12
   770 000009E2 49C1E60C            <1>          shl r14, 12                    	;too
   771                              <1>   .next:
   772 000009E6 E890FDFFFF          <1>          call setup_paging_for_laddr  	;安装当前线性地址所在的页
   773 000009EB 4981C500100000      <1>          add r13, 0x1000               	;+4096
   774 000009F2 4D39F5              <1>          cmp r13, r14
   775 000009F5 7EEF                <1>          jle .next
   776                              <1> 
   777 000009F7 415E                <1>          pop r14
   778 000009F9 415D                <1>          pop r13
   779                              <1> 
   780 000009FB C3                  <1>          ret
   781                              <1> 
   782                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   783                              <1> user_memory_allocate:            	;在用户任务的私有空间（低端）分配内存
   784                              <1>                                    	;输入：R11=任务控制块PCB的线性地址
   785                              <1>                                    	;      RCX=希望分配的字节数
   786                              <1>                                    	;输出：R13=本次分配的起始线性地址
   787                              <1>                                    	;      R14=下次分配的起始线性地址
   788                              <1>          ;获得本次内存分配的起始线性地址
   789 000009FC 4D8B6B18            <1>          mov r13, [r11 + 24]     	;获得本次分配的起始线性地址
   790 00000A00 4D8D740D00          <1>          lea r14, [r13 + rcx]    	;下次分配时的起始线性地址
   791                              <1> 
   792 00000A05 49F7C607000000      <1>          test r14, 0x07          	;能够被8整除吗（是否按8字节对齐）？
   793 00000A0C 740C                <1>          jz .algn
   794 00000A0E 49C1EE03            <1>          shr r14, 3
   795 00000A12 49C1E603            <1>          shl r14, 3                     ;最低3个比特变成0，强制按8字节对齐。
   796 00000A16 4983C608            <1>          add r14, 0x08   	        ;注：立即数符号扩展到64位参与操作
   797                              <1> 
   798                              <1>   .algn:
   799 00000A1A 4D897318            <1>          mov [r11 + 24], r14         	;写回PCB中。
   800                              <1> 
   801 00000A1E 4155                <1>          push r13
   802 00000A20 4156                <1>          push r14
   803                              <1> 
   804                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   805 00000A22 49C1ED0C            <1>          shr r13, 12
   806 00000A26 49C1E50C            <1>          shl r13, 12                 	;清除掉页内偏移部分
   807 00000A2A 49C1EE0C            <1>          shr r14, 12
   808 00000A2E 49C1E60C            <1>          shl r14, 12                 	;too
   809                              <1>   .next:
   810 00000A32 E844FDFFFF          <1>          call setup_paging_for_laddr   	;安装当前线性地址所在的页
   811 00000A37 4981C500100000      <1>          add r13, 0x1000                ;+4096
   812 00000A3E 4D39F5              <1>          cmp r13, r14
   813 00000A41 7EEF                <1>          jle .next
   814                              <1> 
   815 00000A43 415E                <1>          pop r14
   816 00000A45 415D                <1>          pop r13
   817                              <1> 
   818 00000A47 C3                  <1>          ret
   819                              <1> 
   820                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   821                              <1> %ifdef __MP__
   822 00000A48 0000000000000000    <1> _copy_locker dq 0
   823                              <1> %endif
   824                              <1> 
   825                              <1> copy_current_pml4:                    	;创建新的4级头表，并复制当前4级头表的内容
   826                              <1>                                         	;输入：无
   827                              <1>                                         	;输出：RAX=新4级头表的物理地址及属性
   828 00000A50 56                  <1>          push rsi
   829 00000A51 57                  <1>          push rdi
   830 00000A52 4155                <1>          push r13
   831 00000A54 51                  <1>          push rcx
   832                              <1> 
   833 00000A55 9C                  <1>          pushfq                                   	;-->A
   834 00000A56 FA                  <1>          cli
   835                              <1> %ifdef __MP__
   836                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    64                              <2>  %%spin_lock:
    65 00000A57 48833DE9FFFFFF00    <2>  cmp %2, 0
    66 00000A5F 7404                <2>  je %%get_lock
    67 00000A61 F390                <2>  pause
    68 00000A63 EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000A65 B901000000          <2>  mov %1, 1
    71 00000A6A 48870DD7FFFFFF      <2>  xchg %1, %2
    72 00000A71 4883F900            <2>  cmp %1, 0
    73 00000A75 75E0                <2>  jne %%spin_lock
   837                              <1> %endif
   838                              <1> 
   839 00000A77 E856FCFFFF          <1>          call allocate_a_4k_page          	;分配一个物理页
   840 00000A7C 4883C807            <1>          or rax, 0x07                      	;立即数符号扩展到64位参与操作
   841 00000A80 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR         	;用指定的线性地址映射和访问这个页
   841 00000A89 FF                  <1>
   842 00000A8A E8F1FDFFFF          <1>          call mapping_laddr_to_page
   843                              <1> 
   844                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   845 00000A8F 410F017D00          <1>          invlpg [r13]
   846                              <1> 
   847 00000A94 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000   	;RSI->当前活动4级头表的线性地址
   848 00000A9B 4C89EF              <1>          mov rdi, r13                       	;RDI->新4级头表的线性地址
   849 00000A9E B900020000          <1>          mov rcx, 512                       	;RCX=要复制的目录项数
   850 00000AA3 FC                  <1>          cld
   851 00000AA4 F348A5              <1>          repe movsq
   852                              <1> 
   853 00000AA7 498985F80F0000      <1>          mov [r13 + 0xff8], rax            	;新4级头表的511号表项指向它自己
   854 00000AAE 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   855                              <1> 
   856                              <1> %ifdef __MP__
   857 00000AB6 48C70587FFFFFF0000- <1>          mov qword [rel _copy_locker], 0
   857 00000ABF 0000                <1>
   858                              <1> %endif
   859 00000AC1 9D                  <1>          popfq                    	;A
   860                              <1> 
   861 00000AC2 59                  <1>          pop rcx
   862 00000AC3 415D                <1>          pop r13
   863 00000AC5 5F                  <1>          pop rdi
   864 00000AC6 5E                  <1>          pop rsi
   865                              <1> 
   866 00000AC7 C3                  <1>          ret
   867                              <1> 
   868                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   869                              <1> %ifdef __MP__
   870 00000AC8 0000000000000000    <1> _cmos_locker dq 0
   871                              <1> %endif
   872                              <1> 
   873                              <1> get_cmos_time:                        	;从CMOS中获取当前时间
   874                              <1>                                        	;输入：RBX=缓冲区线性地址
   875 00000AD0 50                  <1>          push rax
   876                              <1> 
   877 00000AD1 9C                  <1>          pushfq                       	;-->A
   878 00000AD2 FA                  <1>          cli
   879                              <1> %ifdef __MP__
   880                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
    64                              <2>  %%spin_lock:
    65 00000AD3 48833DEDFFFFFF00    <2>  cmp %2, 0
    66 00000ADB 7404                <2>  je %%get_lock
    67 00000ADD F390                <2>  pause
    68 00000ADF EBF2                <2>  jmp %%spin_lock
    69                              <2>  %%get_lock:
    70 00000AE1 B801000000          <2>  mov %1, 1
    71 00000AE6 488705DBFFFFFF      <2>  xchg %1, %2
    72 00000AED 4883F800            <2>  cmp %1, 0
    73 00000AF1 75E0                <2>  jne %%spin_lock
   881                              <1> %endif
   882                              <1> 
   883                              <1>   .w0:
   884 00000AF3 B08A                <1>          mov al, 0x8a
   885 00000AF5 E670                <1>          out 0x70, al
   886 00000AF7 E471                <1>          in al, 0x71                 	;读寄存器A
   887 00000AF9 A880                <1>          test al, 0x80               	;测试第7位UIP，等待更新周期结束。
   888 00000AFB 75F6                <1>          jnz .w0
   889                              <1> 
   890 00000AFD B084                <1>          mov al, 0x84
   891 00000AFF E670                <1>          out 0x70, al
   892 00000B01 E471                <1>          in al, 0x71                 	;读RTC当前时间(时)
   893 00000B03 88C4                <1>          mov ah, al
   894                              <1> 
   895 00000B05 C0EC04              <1>          shr ah, 4
   896 00000B08 80E40F              <1>          and ah, 0x0f
   897 00000B0B 80C430              <1>          add ah, 0x30
   898 00000B0E 8823                <1>          mov [rbx], ah
   899                              <1> 
   900 00000B10 240F                <1>          and al, 0x0f
   901 00000B12 0430                <1>          add al, 0x30
   902 00000B14 884301              <1>          mov [rbx + 1], al
   903                              <1> 
   904 00000B17 C643023A            <1>          mov byte [rbx + 2], ':'
   905                              <1> 
   906 00000B1B B082                <1>          mov al, 0x82
   907 00000B1D E670                <1>          out 0x70, al
   908 00000B1F E471                <1>          in al, 0x71             	;读RTC当前时间(分)
   909 00000B21 88C4                <1>          mov ah, al
   910                              <1> 
   911 00000B23 C0EC04              <1>          shr ah, 4
   912 00000B26 80E40F              <1>          and ah, 0x0f
   913 00000B29 80C430              <1>          add ah, 0x30
   914 00000B2C 886303              <1>          mov [rbx + 3], ah
   915                              <1> 
   916 00000B2F 240F                <1>          and al, 0x0f
   917 00000B31 0430                <1>          add al, 0x30
   918 00000B33 884304              <1>          mov [rbx + 4], al
   919                              <1> 
   920 00000B36 C643053A            <1>          mov byte [rbx + 5], ':'
   921                              <1> 
   922 00000B3A B080                <1>          mov al, 0x80
   923 00000B3C E670                <1>          out 0x70, al
   924 00000B3E E471                <1>          in al, 0x71             	;读RTC当前时间(秒)
   925 00000B40 88C4                <1>          mov ah, al              	;分拆成两个数字
   926                              <1> 
   927 00000B42 C0EC04              <1>          shr ah, 4                   	;逻辑右移4位
   928 00000B45 80E40F              <1>          and ah, 0x0f
   929 00000B48 80C430              <1>          add ah, 0x30
   930 00000B4B 886306              <1>          mov [rbx + 6], ah
   931                              <1> 
   932 00000B4E 240F                <1>          and al, 0x0f               	;仅保留低4位
   933 00000B50 0430                <1>          add al, 0x30               	;转换成ASCII
   934 00000B52 884307              <1>          mov [rbx + 7], al
   935                              <1> 
   936 00000B55 C6430800            <1>          mov byte [rbx + 8], 0     	;空字符终止
   937                              <1> 
   938                              <1> %ifdef __MP__
   939 00000B59 48C70564FFFFFF0000- <1>          mov qword [rel _cmos_locker], 0
   939 00000B62 0000                <1>
   940                              <1> %endif
   941 00000B64 9D                  <1>          popfq                	;A
   942                              <1> 
   943 00000B65 58                  <1>          pop rax
   944                              <1> 
   945 00000B66 C3                  <1>          ret
   946                              <1> 
   947                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   948 00000B67 0000000000000000    <1>   _process_id        dq 0
   949                              <1> 
   950                              <1> generate_process_id:                  	;生成唯一的进程标识
   951                              <1>                                         	;返回：RAX=进程标识
   952 00000B6F B801000000          <1>          mov rax, 1
   953 00000B74 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   954                              <1> 
   955 00000B7D C3                  <1>          ret
   956                              <1> 
   957                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   958 00000B7E 0000000000000000    <1>   _thread_id dq 0
   959                              <1> 
   960                              <1> generate_thread_id:                 	;生成唯一的线程标识
   961                              <1>                                       	;返回：RAX=线程标识
   962 00000B86 B801000000          <1>          mov rax, 1
   963 00000B8B F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   964                              <1> 
   965 00000B94 C3                  <1>          ret
   966                              <1> 
   967                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   968 00000B95 08                  <1>   _screen_row        db 8
   969                              <1> 
   970                              <1> get_screen_row:                     	;返回下一个屏幕坐标行的行号
   971                              <1>                                      	;返回：DH=行号
   972 00000B96 B601                <1>          mov dh, 1
   973 00000B98 F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   974                              <1> 
   975 00000BA0 C3                  <1>          ret
   976                              <1> 
   977                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   978                              <1> get_cpu_number:                        	;返回当前处理器的编号
   979                              <1>                                         	;返回：RAX=处理器编号
   980 00000BA1 9C                  <1>          pushfq
   981 00000BA2 FA                  <1>          cli
   982 00000BA3 0F01F8              <1>          swapgs
   983 00000BA6 65488B042510000000  <1>          mov rax, [gs:16]              	;从处理器专属数据区取回
   984 00000BAF 0F01F8              <1>          swapgs
   985 00000BB2 9D                  <1>          popfq
   986 00000BB3 C3                  <1>          ret
   987                              <1> 
   988                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   989                              <1> memory_allocate:                       	;用户空间的内存分配
   990                              <1>                                          	;进入：RDX=期望分配的字节数
   991                              <1>                                        	;输出：R13=所分配内存的起始线性地址
   992 00000BB4 51                  <1>          push rcx
   993 00000BB5 4153                <1>          push r11
   994 00000BB7 4156                <1>          push r14
   995                              <1> 
   996 00000BB9 9C                  <1>          pushfq
   997 00000BBA FA                  <1>          cli
   998 00000BBB 0F01F8              <1>          swapgs
   999 00000BBE 654C8B1C2508000000  <1>          mov r11, [gs:8]                	;取得当前任务的PCB线性地址
  1000 00000BC7 0F01F8              <1>          swapgs
  1001 00000BCA 9D                  <1>          popfq
  1002                              <1> 
  1003 00000BCB 4889D1              <1>          mov rcx, rdx
  1004 00000BCE E829FEFFFF          <1>          call user_memory_allocate
  1005                              <1> 
  1006 00000BD3 415E                <1>          pop r14
  1007 00000BD5 415B                <1>          pop r11
  1008 00000BD7 59                  <1>          pop rcx
  1009                              <1> 
  1010 00000BD8 C3                  <1>          ret
  1011                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    56                                  %include "..\common\user_static64.lib"
    57                              <1> ;user_static64.lib:用户程序使用的例程库，用来模拟高级语言的静态库。有些功能直接在本文件
    58                              <1> ;中实现，但有些功能需要通过syscall指令使用内核提供的系统调用。
    59                              <1> ;创建时间：2022-01-30 18:30，李忠
    60                              <1> ;此文件需要用预处理指令%include引入用户程序。
    61                              <1> 
    62                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    63                              <1>          bits 64
    64                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    65                              <1> bin64_to_dec:                                     ;将二进制数转换为十进制字符串。
    66                              <1>                                                   ;输入：R8=64位二进制数
    67                              <1>                                                   ;      RBX=目标缓冲区线性地址
    68 00000BD9 50                  <1>          push rax
    69 00000BDA 53                  <1>          push rbx
    70 00000BDB 51                  <1>          push rcx
    71 00000BDC 52                  <1>          push rdx
    72 00000BDD 4150                <1>          push r8
    73                              <1> 
    74 00000BDF 490FBAE03F          <1>          bt r8, 63
    75 00000BE4 7309                <1>          jnc .begin
    76 00000BE6 C6032D              <1>          mov byte [rbx], '-'
    77 00000BE9 49F7D8              <1>          neg r8
    78 00000BEC 48FFC3              <1>          inc rbx
    79                              <1>   .begin:
    80 00000BEF 4C89C0              <1>          mov rax, r8                              ;!!
    81 00000BF2 41B80A000000        <1>          mov r8, 10
    82 00000BF8 4831C9              <1>          xor rcx, rcx
    83                              <1> 
    84                              <1>   .next_div:
    85 00000BFB 4831D2              <1>          xor rdx, rdx
    86 00000BFE 49F7F0              <1>          div r8
    87 00000C01 52                  <1>          push rdx                                 ;保存分解的数位
    88 00000C02 48FFC1              <1>          inc rcx                                  ;递增压栈的次数
    89 00000C05 4809C0              <1>          or rax, rax                              ;商为0？
    90 00000C08 7402                <1>          jz .rotate
    91 00000C0A EBEF                <1>          jmp .next_div
    92                              <1> 
    93                              <1>   .rotate:
    94 00000C0C 5A                  <1>          pop rdx
    95 00000C0D 80C230              <1>          add dl, 0x30                             ;数位转换成ASCII编码
    96 00000C10 8813                <1>          mov [rbx], dl
    97 00000C12 48FFC3              <1>          inc rbx
    98 00000C15 E2F5                <1>          loop .rotate
    99                              <1> 
   100 00000C17 C60300              <1>          mov byte [rbx], 0
   101                              <1> 
   102 00000C1A 4158                <1>          pop r8
   103 00000C1C 5A                  <1>          pop rdx
   104 00000C1D 59                  <1>          pop rcx
   105 00000C1E 5B                  <1>          pop rbx
   106 00000C1F 58                  <1>          pop rax
   107                              <1> 
   108 00000C20 C3                  <1>          ret                                      ;段内返回
   109                              <1> 
   110                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   111                              <1> string_concatenates:                              ;将源字符串连接到目的字符串的尾部
   112                              <1>                                                   ;输入：RSI=源字符串的线性地址
   113                              <1>                                                   ;      RDI=目的字符串的线性地址
   114 00000C21 50                  <1>          push rax
   115 00000C22 56                  <1>          push rsi
   116 00000C23 57                  <1>          push rdi
   117                              <1> 
   118                              <1>   .r0:
   119 00000C24 803F00              <1>          cmp byte [rdi], 0
   120 00000C27 7405                <1>          jz .r1
   121 00000C29 48FFC7              <1>          inc rdi
   122 00000C2C EBF6                <1>          jmp .r0
   123                              <1> 
   124                              <1>   .r1:
   125 00000C2E 8A06                <1>          mov al, [rsi]
   126 00000C30 8807                <1>          mov [rdi], al
   127 00000C32 3C00                <1>          cmp al, 0
   128 00000C34 7408                <1>          jz .r2
   129 00000C36 48FFC6              <1>          inc rsi
   130 00000C39 48FFC7              <1>          inc rdi
   131 00000C3C EBF0                <1>          jmp .r1
   132                              <1> 
   133                              <1>   .r2:
   134 00000C3E 5F                  <1>          pop rdi
   135 00000C3F 5E                  <1>          pop rsi
   136 00000C40 58                  <1>          pop rax
   137                              <1> 
   138 00000C41 C3                  <1>          ret
   139                              <1> 
   140                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   141                              <1> 
    57                                  
    58                                           bits 64
    59                                  
    60                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    61 00000C42 F900                      _ap_string      db 249, 0
    62                                  
    63                                  ap_to_core_entry:                                 ;应用处理器（AP）进入内核的入口点
    64                                           ;启用GDT的高端线性地址并加载IDTR
    65 00000C44 48B8007E00000080FF-              mov rax, UPPER_SDA_LINEAR
    65 00000C4D FF                 
    66 00000C4E 0F015002                         lgdt [rax + 2]                           ;只有在64位模式下才能加载64位线性地址部分
    67 00000C52 0F01580C                         lidt [rax + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
    68                                  
    69                                           ;为当前处理器创建64位模式下的专属栈
    70 00000C56 B900100000                       mov rcx, 4096
    71 00000C5B E81BFDFFFF                       call core_memory_allocate
    72 00000C60 4C89F4                           mov rsp, r14
    73                                  
    74                                           ;创建当前处理器的专属存储区（含TSS），并安装TSS描述符到GDT
    75 00000C63 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
    76 00000C68 E80EFDFFFF                       call core_memory_allocate
    77 00000C6D 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
    78 00000C74 E86BF5FFFF                       call make_tss_descriptor
    79                                  
    80 00000C79 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区的高端线性地址（低端亦可）
    80 00000C82 FF                 
    81                                  
    82 00000C83 4D8B4704                         mov r8, [r15 + 4]                        ;R8=GDT的线性地址
    83 00000C87 490FB74F02                       movzx rcx, word [r15 + 2]                ;RCX=GDT的界限值
    84 00000C8C 4989740801                       mov [r8 + rcx + 1], rsi                  ;TSS描述符的低64位
    85 00000C91 49897C0809                       mov [r8 + rcx + 9], rdi                  ;TSS描述符的高64位
    86                                  
    87 00000C96 664183470210                     add word [r15 + 2], 16
    88 00000C9C 410F015702                       lgdt [r15 + 2]                           ;重新加载GDTR
    89                                  
    90 00000CA1 66C1E903                         shr cx, 3                                ;除以8（消除余数），得到索引号
    91 00000CA5 66FFC1                           inc cx                                   ;索引号递增
    92 00000CA8 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
    93                                  
    94 00000CAC 0F00D9                           ltr cx                                   ;为当前处理器加载任务寄存器TR
    95                                  
    96                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
    97 00000CAF B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
    98 00000CB4 4C89E8                           mov rax, r13                             ;只用EAX
    99 00000CB7 4C89EA                           mov rdx, r13
   100 00000CBA 48C1EA20                         shr rdx, 32                              ;只用EDX
   101 00000CBE 0F30                             wrmsr
   102                                  
   103                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   104 00000CC0 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   105 00000CC5 0F32                             rdmsr
   106 00000CC7 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   107 00000CCB 0F30                             wrmsr
   108                                  
   109 00000CCD B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   110 00000CD2 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   111 00000CD7 31C0                             xor eax, eax
   112 00000CD9 0F30                             wrmsr
   113                                  
   114 00000CDB B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   115 00000CE0 488B05(08000000)                 mov rax, [rel position]
   116 00000CE7 488D80[34190000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   117 00000CEE 4889C2                           mov rdx, rax
   118 00000CF1 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   119 00000CF5 0F30                             wrmsr
   120                                  
   121 00000CF7 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   122 00000CFC 31D2                             xor edx, edx
   123 00000CFE B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   124 00000D03 0F30                             wrmsr
   125                                  
   126 00000D05 4C8B3D(08000000)                 mov r15, [rel position]
   127 00000D0C 498D9F[420C0000]                 lea rbx, [r15 + _ap_string]
   128 00000D13 E8F0F2FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   129                                  
   130 00000D18 0F01F8                           swapgs                                   ;准备用GS操作当前处理器的专属数据
   131 00000D1B 6548C7042508000000-              mov qword [gs:8], 0                      ;没有正在执行的任务
   131 00000D24 00000000           
   132 00000D28 4831C0                           xor rax, rax
   133 00000D2B 8A05(31010000)                   mov al, byte [rel ack_cpus]
   134 00000D31 654889042510000000               mov [gs:16], rax                         ;设置当前处理器的编号
   135 00000D3A 654889242518000000               mov [gs:24], rsp                         ;保存当前处理器的固有栈指针
   136 00000D43 0F01F8                           swapgs
   137                                  
   138 00000D46 FE05(31010000)                   inc byte [rel ack_cpus]                  ;递增应答计数值
   139                                  
   140 00000D4C C60425[82F00000]00               mov byte [AP_START_UP_ADDR + lock_var], 0;释放自旋锁
   141                                  
   142 00000D54 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   142 00000D5D FF                 
   143 00000D5E 0FBAAEF000000008                 bts dword [rsi + 0xf0], 8                ;设置SVR寄存器，允许LAPIC
   144                                  
   145 00000D66 FB                               sti                                      ;开放中断
   146                                  
   147                                    .do_idle:
   148 00000D67 F4                               hlt
   149 00000D68 EBFD                             jmp .do_idle
   150                                  
   151                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   152                                  general_interrupt_handler:                        ;通用中断处理过程
   153 00000D6A 48CF                             iretq
   154                                  
   155                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   156                                  general_exception_handler:                        ;通用异常处理过程
   157                                                                                    ;在24行0列显示红底白字的错误信息
   158 00000D6C 4C8B3D(08000000)                 mov r15, [rel position]
   159 00000D73 498D9F[880D0000]                 lea rbx, [r15 + exceptm]
   160 00000D7A B618                             mov dh, 24
   161 00000D7C B200                             mov dl, 0
   162 00000D7E 41B14F                           mov r9b, 0x4f
   163 00000D81 E893F3FFFF                       call put_cstringxy64                     ;位于core_utils64_mp.wid
   164                                  
   165 00000D86 FA                               cli
   166 00000D87 F4                               hlt                                      ;停机且不接受外部硬件中断
   167                                  
   168 00000D88 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
   168 00000D91 6F6E20726169736564-
   168 00000D9A 2C68616C742E00     
   169                                  
   170                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   171                                  handle_waiting_thread:                            ;处理等待其它线程的线程
   172                                                                                    ;输入：R11=线程控制块TCB的线性地址
   173 00000DA1 53                               push rbx
   174 00000DA2 52                               push rdx
   175 00000DA3 4153                             push r11
   176                                  
   177 00000DA5 4C89DB                           mov rbx, r11
   178                                  
   179 00000DA8 498B5338                         mov rdx, [r11 + 56]                      ;被等待的线程的标识
   180 00000DAC E854040000                       call search_for_thread_id
   181 00000DB1 4D09DB                           or r11, r11                              ;线程已经被清理了吗？
   182 00000DB4 7407                             jz .set_th
   183 00000DB6 49837B1002                       cmp qword [r11 + 16], 2                  ;线程是终止状态吗？
   184 00000DBB 7528                             jne .return                              ;不是。返回（继续等待）
   185                                    .set_th:
   186 00000DBD 48C7431000000000                 mov qword [rbx + 16], 0                  ;将线程设置为就绪状态
   187                                  
   188 00000DC5 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;Local APIC的线性地址
   188 00000DCE FF                 
   189 00000DCF 41C783100300000000-              mov dword [r11 + 0x310], 0
   189 00000DD8 0000               
   190 00000DDA 41C78300030000FE40-              mov dword [r11 + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   190 00000DE3 0800               
   191                                    .return:
   192 00000DE5 415B                             pop r11
   193 00000DE7 5A                               pop rdx
   194 00000DE8 5B                               pop rbx
   195                                  
   196 00000DE9 C3                               ret
   197                                  
   198                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   199                                  handle_waiting_flag:                              ;处理等待标志的线程
   200                                                                                    ;输入：R11=线程控制块TCB的线性地址
   201 00000DEA 50                               push rax
   202 00000DEB 53                               push rbx
   203 00000DEC 51                               push rcx
   204                                  
   205 00000DED B800000000                       mov rax, 0
   206 00000DF2 498B5B38                         mov rbx, [r11 + 56]                      ;被等待的标志的线性地址
   207 00000DF6 B901000000                       mov rcx, 1
   208 00000DFB F0480FB10B                       lock cmpxchg [rbx], rcx
   209 00000E00 7526                             jnz .return
   210                                  
   211 00000E02 49C7431000000000                 mov qword [r11 + 16], 0                  ;将线程设置为就绪状态
   212                                  
   213 00000E0A 48BB00E0FFFF7FFFFF-              mov rbx, LAPIC_START_ADDR                ;Local APIC的线性地址
   213 00000E13 FF                 
   214 00000E14 C78310030000000000-              mov dword [rbx + 0x310], 0
   214 00000E1D 00                 
   215 00000E1E C78300030000FE4008-              mov dword [rbx + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   215 00000E27 00                 
   216                                  
   217                                    .return:
   218 00000E28 59                               pop rcx
   219 00000E29 5B                               pop rbx
   220 00000E2A 58                               pop rax
   221                                  
   222 00000E2B C3                               ret
   223                                  
   224                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   225                                  handle_waiting_sleep:                             ;处理睡眠中的线程
   226                                                                                    ;输入：R11=线程控制块TCB的线性地址
   227 00000E2C 50                               push rax
   228                                  
   229 00000E2D 49FF4B38                         dec qword [r11 + 56]
   230 00000E31 49837B3800                       cmp qword [r11 + 56], 0
   231 00000E36 7526                             jnz .return
   232                                  
   233 00000E38 49C7431000000000                 mov qword [r11 + 16], 0                  ;将线程设置为就绪状态
   234                                  
   235 00000E40 48B800E0FFFF7FFFFF-              mov rax, LAPIC_START_ADDR                ;Local APIC的线性地址
   235 00000E49 FF                 
   236 00000E4A C78010030000000000-              mov dword [rax + 0x310], 0
   236 00000E53 00                 
   237 00000E54 C78000030000FE4008-              mov dword [rax + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   237 00000E5D 00                 
   238                                  
   239                                    .return:
   240 00000E5E 58                               pop rax
   241                                  
   242 00000E5F C3                               ret
   243                                  
   244                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   245                                  system_management_handler:                        ;系统管理中断的处理过程
   246                                  
   247 00000E60 53                               push rbx
   248 00000E61 4153                             push r11
   249                                  
   250 00000E63 488B1D(E9020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   251 00000E6A 4809DB                           or rbx, rbx
   252 00000E6D 7453                             jz .return                               ;系统中尚不存在任务
   253                                    .nextp:
   254 00000E6F 4C8B9B10010000                   mov r11, [rbx + 272]
   255 00000E76 4D09DB                           or r11, r11
   256 00000E79 7447                             jz .return                               ;任务尚未创建线程
   257                                    .nextt:
   258 00000E7B 49837B1003                       cmp qword [r11 + 16], 3                  ;正在休眠并等待其它线程？
   259 00000E80 7507                             jne .next0                               ;不是，转去.b0继续处理此TCB
   260                                           ;处理等待其它线程终止的线程并决定其是否唤醒
   261 00000E82 E81AFFFFFF                       call handle_waiting_thread
   262 00000E87 EB1C                             jmp .gnext
   263                                    .next0:
   264                                           ;处理等待某个信号的线程并决定其是否唤醒
   265 00000E89 49837B1005                       cmp qword [r11 + 16], 5
   266 00000E8E 7507                             jne .next1
   267 00000E90 E855FFFFFF                       call handle_waiting_flag
   268 00000E95 EB0E                             jmp .gnext
   269                                    .next1:
   270                                           ;处理休眠的线程并决定其是否唤醒
   271 00000E97 49837B1004                       cmp qword [r11 + 16], 4
   272 00000E9C 7507                             jne .next2
   273 00000E9E E889FFFFFF                       call handle_waiting_sleep
   274 00000EA3 EB00                             jmp .gnext
   275                                    .next2:
   276                                    .gnext:
   277 00000EA5 4D8B9B18010000                   mov r11, [r11 + 280]                     ;否。处理下一个TCB节点
   278 00000EAC 4983FB00                         cmp r11, 0                               ;到达TCB链表尾部？
   279 00000EB0 75C9                             jne .nextt                               ;否。
   280                                  
   281 00000EB2 488B9B18010000                   mov rbx, [rbx + 280]                     ;下一个PCB节点
   282 00000EB9 483B1D(E9020000)                 cmp rbx, [rel pcb_ptr]                   ;转一圈又回到PCB首节点？
   283 00000EC0 75AD                             jne .nextp                               ;否。转.nextp处理下一个PCB
   284                                  
   285                                    .return:
   286 00000EC2 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   286 00000ECB FF                 
   287 00000ECC 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   287 00000ED5 0000               
   288                                  
   289 00000ED7 48BB00800B000080FF-     mov rbx, UPPER_TEXT_VIDEO
   289 00000EE0 FF                 
   290 00000EE1 F613                    not byte [rbx]
   291                                  
   292 00000EE3 415B                             pop r11
   293 00000EE5 5B                               pop rbx
   294                                  
   295 00000EE6 48CF                             iretq
   296                                  
   297                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   298                                  search_for_a_ready_thread:                        ;查找一个就绪的线程并将其置为忙
   299                                                                                    ;返回：R11=就绪线程所属任务的PCB线性地址
   300                                                                                    ;      R12=就绪线程的TCB线性地址
   301                                           ;此例程通常是在中断处理过程内调用，默认中断是关闭状态。
   302 00000EE8 50                               push rax
   303 00000EE9 53                               push rbx
   304 00000EEA 51                               push rcx
   305                                  
   306 00000EEB B901000000                       mov rcx, 1                               ;RCX=线程的“忙”状态
   307                                  
   308 00000EF0 0F01F8                           swapgs
   309 00000EF3 65488B1C2508000000               mov rbx, [gs:8]                          ;取得当前任务的PCB线性地址
   310 00000EFC 654C8B242520000000               mov r12, [gs:32]                         ;取得当前线程的TCB线性地址
   311 00000F05 0F01F8                           swapgs
   312 00000F08 4989DB                           mov r11, rbx
   313 00000F0B 4983FB00                         cmp r11, 0                               ;处理器当前未在执行任务？
   314 00000F0F 7511                             jne .nextt
   315 00000F11 488B1D(E9020000)                 mov rbx, [rel pcb_ptr]                   ;是的。从PCB链表首节点及其第一个TCB开始搜索。
   316 00000F18 4989DB                           mov r11, rbx
   317 00000F1B 4D8BA310010000                   mov r12, [r11 + 272]                     ;PCB链表首节点的第一个TCB节点
   318                                    .nextt:                                         ;这一部分遍历指定任务的TCB链表
   319 00000F22 4983FC00                         cmp r12, 0                               ;正位于当前PCB的TCB链表末尾?
   320 00000F26 7416                             je .nextp                                ;转去切换到PCB链表的下一个节点。
   321 00000F28 4831C0                           xor rax, rax
   322 00000F2B F0490FB14C2410                   lock cmpxchg [r12 + 16], rcx
   323 00000F32 7425                             jz .retrn
   324 00000F34 4D8BA42418010000                 mov r12, [r12 + 280]                     ;取得下一个TCB节点
   325 00000F3C EBE4                             jmp .nextt
   326                                    .nextp:                                         ;这一部分控制任务链表的遍历
   327 00000F3E 4D8B9B18010000                   mov r11, [r11 + 280]                     ;取得下一个PCB节点
   328 00000F45 4939DB                           cmp r11, rbx                             ;是否转一圈回到初始PCB节点？
   329 00000F48 7409                             je .fmiss                                ;是。即，未找到就绪线程（节点）
   330 00000F4A 4D8BA310010000                   mov r12, [r11 + 272]                     ;不是。从新的PCB中提取TCB链表首节点
   331 00000F51 EBCF                             jmp .nextt
   332                                    .fmiss:                                         ;看来系统中不存在就绪线程
   333 00000F53 4D31DB                           xor r11, r11
   334 00000F56 4D31E4                           xor r12, r12
   335                                    .retrn:
   336 00000F59 59                               pop rcx
   337 00000F5A 5B                               pop rbx
   338 00000F5B 58                               pop rax
   339                                  
   340 00000F5C C3                               ret
   341                                  
   342                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   343                                  resume_execute_a_thread:                          ;恢复执行一个线程
   344                                                                                    ;传入：R11=线程所属的任务的PCB线性地址
   345                                                                                    ;      R12=线程的TCB线性地址
   346                                           ;此例程在中断处理过程内调用，默认中断是关闭状态。
   347 00000F5D 8B05(32010000)                   mov eax, [rel clocks_1ms]                ;以下计算新线程运行时间
   348 00000F63 418B9C24F0000000                 mov ebx, [r12 + 240]                     ;为线程指定的时间片
   349 00000F6B F7E3                             mul ebx
   350                                  
   351 00000F6D 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   351 00000F76 FF                 
   352 00000F77 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频
   352 00000F80 00                 
   353 00000F81 C78620030000FD0000-              mov dword [rsi + 0x320], 0xfd            ;单次击发模式，Fixed，中断号0xfd
   353 00000F8A 00                 
   354                                  
   355 00000F8B 498B5B38                         mov rbx, [r11 + 56]
   356 00000F8F 0F22DB                           mov cr3, rbx                             ;切换地址空间
   357                                  
   358 00000F92 0F01F8                           swapgs
   359 00000F95 654C891C2508000000               mov [gs:8], r11                          ;将新线程所属的任务设置为当前任务
   360 00000F9E 654C89242520000000               mov [gs:32], r12                         ;将新线程设置为当前线程
   361 00000FA7 498B5C2420                       mov rbx, [r12 + 32]                      ;取TCB中的RSP0
   362 00000FAC 6548891C2584000000               mov [gs:128 + 4], rbx                    ;置TSS的RSP0
   363 00000FB5 0F01F8                           swapgs
   364                                  
   365 00000FB8 498B4C2450                       mov rcx, [r12 + 80]
   366 00000FBD 498B542458                       mov rdx, [r12 + 88]
   367 00000FC2 498B7C2468                       mov rdi, [r12 + 104]
   368 00000FC7 498B6C2470                       mov rbp, [r12 + 112]
   369 00000FCC 498B642478                       mov rsp, [r12 + 120]
   370 00000FD1 4D8B842480000000                 mov r8, [r12 + 128]
   371 00000FD9 4D8B8C2488000000                 mov r9, [r12 + 136]
   372 00000FE1 4D8B942490000000                 mov r10, [r12 + 144]
   373                                  
   374 00000FE9 4D8BAC24A8000000                 mov r13, [r12 + 168]
   375 00000FF1 4D8BB424B0000000                 mov r14, [r12 + 176]
   376 00000FF9 4D8BBC24B8000000                 mov r15, [r12 + 184]
   377 00001001 41FFB424D0000000                 push qword [r12 + 208]                   ;SS
   378 00001009 41FF742478                       push qword [r12 + 120]                   ;RSP
   379 0000100E 41FFB424E8000000                 push qword [r12 + 232]                   ;RFLAGS
   380 00001016 41FFB424C8000000                 push qword [r12 + 200]                   ;CS
   381 0000101E 41FFB424C0000000                 push qword [r12 + 192]                   ;RIP
   382                                  
   383 00001026 898680030000                     mov dword [rsi + 0x380], eax             ;开始计时
   384                                  
   385 0000102C 498B442440                       mov rax, [r12 + 64]
   386 00001031 498B5C2448                       mov rbx, [r12 + 72]
   387 00001036 498B742460                       mov rsi, [r12 + 96]
   388 0000103B 4D8B9C2498000000                 mov r11, [r12 + 152]
   389 00001043 4D8BA424A0000000                 mov r12, [r12 + 160]
   390                                  
   391 0000104B 48CF                             iretq                                    ;转入新线程执行
   392                                  
   393                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   394                                  time_slice_out_handler:                           ;时间片到期中断的处理过程
   395 0000104D 50                               push rax
   396 0000104E 53                               push rbx
   397 0000104F 4153                             push r11
   398 00001051 4154                             push r12
   399 00001053 4155                             push r13
   400                                  
   401 00001055 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   401 0000105E FF                 
   402 0000105F 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   402 00001068 0000               
   403                                  
   404 0000106A E879FEFFFF                       call search_for_a_ready_thread
   405 0000106F 4D09DB                           or r11, r11
   406 00001072 0F8490000000                     jz .return                               ;未找到就绪的线程
   407                                  
   408 00001078 0F01F8                           swapgs
   409 0000107B 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   410 00001084 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   411 0000108D 0F01F8                           swapgs
   412                                  
   413                                           ;保存当前任务和线程的状态以便将来恢复执行。
   414 00001090 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   415 00001094 4C896838                         mov qword [rax + 56], r13
   416                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   417 00001098 48894B50                         mov [rbx + 80], rcx
   418 0000109C 48895358                         mov [rbx + 88], rdx
   419 000010A0 48897360                         mov [rbx + 96], rsi
   420 000010A4 48897B68                         mov [rbx + 104], rdi
   421 000010A8 48896B70                         mov [rbx + 112], rbp
   422 000010AC 48896378                         mov [rbx + 120], rsp
   423 000010B0 4C898380000000                   mov [rbx + 128], r8
   424 000010B7 4C898B88000000                   mov [rbx + 136], r9
   425 000010BE 4C899390000000                   mov [rbx + 144], r10
   426                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   427 000010C5 4C89B3B0000000                   mov [rbx + 176], r14
   428 000010CC 4C89BBB8000000                   mov [rbx + 184], r15
   429 000010D3 4C8B2D(08000000)                 mov r13, [rel position]
   430 000010DA 4D8DAD[08110000]                 lea r13, [r13 + .return]                 ;将来恢复执行时，是从中断返回也～
   431 000010E1 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   432 000010E8 8C8BC8000000                     mov [rbx + 200], cs
   433 000010EE 8C93D0000000                     mov [rbx + 208], ss
   434 000010F4 9C                               pushfq
   435 000010F5 8F83E8000000                     pop qword [rbx + 232]
   436                                  
   437 000010FB 48C7431000000000                 mov qword [rbx + 16], 0                  ;置线程状态为就绪
   438                                  
   439 00001103 E955FEFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   440                                  
   441                                    .return:
   442 00001108 415D                             pop r13
   443 0000110A 415C                             pop r12
   444 0000110C 415B                             pop r11
   445 0000110E 5B                               pop rbx
   446 0000110F 58                               pop rax
   447                                  
   448 00001110 48CF                             iretq
   449                                  
   450                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   451                                  ;新任务/线程创建后，将广播新任务/线程创建消息给所有处理器，所有处理器执行此中断服务例程。
   452                                  new_task_notify_handler:                          ;任务/线程认领中断的处理过程
   453 00001112 56                               push rsi
   454 00001113 4153                             push r11
   455 00001115 4154                             push r12
   456                                  
   457 00001117 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   457 00001120 FF                 
   458 00001121 C786B0000000000000-              mov dword [rsi + 0xb0], 0                ;发送EOI
   458 0000112A 00                 
   459                                  
   460 0000112B 0F01F8                           swapgs
   461 0000112E 6548833C2508000000-              cmp qword [gs:8], 0                      ;当前处理器没有任务执行吗？
   461 00001137 00                 
   462 00001138 0F01F8                           swapgs
   463 0000113B 7522                             jne .return                              ;是的（忙）。不打扰了 :)
   464                                  
   465 0000113D E8A6FDFFFF                       call search_for_a_ready_thread
   466 00001142 4D09DB                           or r11, r11
   467 00001145 7418                             jz .return                               ;未找到就绪的任务
   468                                  
   469 00001147 0F01F8                           swapgs
   470 0000114A 4883C418                         add rsp, 24                              ;去掉进入例程时压入的三个参数
   471 0000114E 654889242518000000               mov qword [gs:24], rsp                   ;保存固有栈当前指针以便将来返回
   472 00001157 0F01F8                           swapgs
   473                                  
   474 0000115A E9FEFDFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   475                                  
   476                                    .return:
   477 0000115F 415C                             pop r12
   478 00001161 415B                             pop r11
   479 00001163 5E                               pop rsi
   480                                  
   481 00001164 48CF                             iretq
   482                                  
   483                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   484 00001166 0000000000000000          _append_lock  dq 0
   485                                  
   486                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   487                                                                                    ;输入：R11=PCB线性基地址
   488 0000116E 50                               push rax
   489 0000116F 53                               push rbx
   490                                  
   491 00001170 9C                               pushfq                                   ;-->A
   492 00001171 FA                               cli
   493                                           SET_SPIN_LOCK rax, qword [rel _append_lock]
    64                              <1>  %%spin_lock:
    65 00001172 48833DECFFFFFF00    <1>  cmp %2, 0
    66 0000117A 7404                <1>  je %%get_lock
    67 0000117C F390                <1>  pause
    68 0000117E EBF2                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00001180 B801000000          <1>  mov %1, 1
    71 00001185 488705DAFFFFFF      <1>  xchg %1, %2
    72 0000118C 4883F800            <1>  cmp %1, 0
    73 00001190 75E0                <1>  jne %%spin_lock
   494                                  
   495 00001192 488B1D(E9020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   496 00001199 4809DB                           or rbx, rbx
   497 0000119C 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   498 0000119E 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   499 000011A1 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   500 000011A8 4C891D(E9020000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   501 000011AF EB17                             jmp .return
   502                                  
   503                                    .not_empty:
   504 000011B1 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   505                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   506 000011B4 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   507 000011BB 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   508 000011C2 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   509 000011C5 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   510                                  
   511                                    .return:
   512 000011C8 48C70593FFFFFF0000-              mov qword [rel _append_lock], 0          ;释放锁
   512 000011D1 0000               
   513 000011D3 9D                               popfq                                    ;A
   514                                  
   515 000011D4 5B                               pop rbx
   516 000011D5 58                               pop rax
   517                                  
   518 000011D6 C3                               ret
   519                                  
   520                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   521                                  get_current_tid:                                  ;返回当前线程的标识
   522 000011D7 9C                               pushfq
   523 000011D8 FA                               cli
   524 000011D9 0F01F8                           swapgs
   525 000011DC 65488B042520000000               mov rax, [gs:32]
   526 000011E5 488B4008                         mov rax, [rax + 8]
   527 000011E9 0F01F8                           swapgs
   528 000011EC 9D                               popfq
   529                                  
   530 000011ED C3                               ret
   531                                  
   532                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   533                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   534 000011EE 9C                               pushfq
   535 000011EF FA                               cli
   536 000011F0 0F01F8                           swapgs
   537 000011F3 65488B042508000000               mov rax, [gs:8]
   538 000011FC 488B4008                         mov rax, [rax + 8]
   539 00001200 0F01F8                           swapgs
   540 00001203 9D                               popfq
   541                                  
   542 00001204 C3                               ret
   543                                  
   544                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   545                                  search_for_thread_id:                             ;查找指定标识的线程
   546                                                                                    ;输入：RDX=线程标识
   547                                                                                    ;输出：R11=线程的TCB线性地址
   548 00001205 53                               push rbx
   549                                  
   550 00001206 488B1D(E9020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   551                                    .nextp:
   552 0000120D 4C8B9B10010000                   mov r11, [rbx + 272]
   553                                  
   554                                    .nextt:
   555 00001214 49395308                         cmp [r11 + 8], rdx                       ;找到指定的线程了吗？
   556 00001218 7420                             je .found                                ;是的。转.found
   557 0000121A 4D8B9B18010000                   mov r11, [r11 + 280]                     ;否。处理下一个TCB节点
   558 00001221 4983FB00                         cmp r11, 0                               ;到达TCB链表尾部？
   559 00001225 75ED                             jne .nextt                               ;否。
   560                                  
   561 00001227 488B9B18010000                   mov rbx, [rbx + 280]                     ;下一个PCB节点
   562 0000122E 483B1D(E9020000)                 cmp rbx, [rel pcb_ptr]                   ;转一圈又回到PCB首节点？
   563 00001235 75D6                             jne .nextp                               ;否。转.nextp处理下一个PCB
   564                                  
   565 00001237 4D31DB                           xor r11, r11                             ;R11=0表明不存在指定的线程
   566                                    .found:
   567 0000123A 5B                               pop rbx
   568                                  
   569 0000123B C3                               ret
   570                                  
   571                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   572                                  waiting_for_a_thread:                             ;等待指定的线程结束
   573                                                                                    ;输入：RDX=线程标识
   574 0000123C 50                               push rax
   575 0000123D 53                               push rbx
   576 0000123E 4153                             push r11
   577 00001240 4154                             push r12
   578 00001242 4155                             push r13
   579                                  
   580 00001244 E8BCFFFFFF                       call search_for_thread_id
   581 00001249 4D09DB                           or r11, r11                              ;线程已经被清理了吗？
   582 0000124C 0F84F6000000                     jz .return
   583 00001252 49837B1002                       cmp qword [r11 + 16], 2                  ;线程是终止状态吗？
   584 00001257 0F84EB000000                     je .return
   585                                  
   586                                           ;被等待的线程还在运行，只能休眠并等待通知
   587 0000125D FA                               cli
   588                                  
   589 0000125E 48B800E0FFFF7FFFFF-              mov rax, LAPIC_START_ADDR                ;Local APIC的线性地址
   589 00001267 FF                 
   590 00001268 C78020030000000001-              mov dword [rax + 0x320], 0x00010000      ;屏蔽定时器中断
   590 00001271 00                 
   591                                  
   592 00001272 0F01F8                           swapgs
   593 00001275 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   594 0000127E 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   595 00001287 0F01F8                           swapgs
   596                                  
   597                                           ;保存当前任务和线程的状态以便将来恢复执行。
   598 0000128A 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   599 0000128E 4C896838                         mov qword [rax + 56], r13
   600                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   601 00001292 48894B50                         mov [rbx + 80], rcx
   602 00001296 48895358                         mov [rbx + 88], rdx
   603 0000129A 48897360                         mov [rbx + 96], rsi
   604 0000129E 48897B68                         mov [rbx + 104], rdi
   605 000012A2 48896B70                         mov [rbx + 112], rbp
   606 000012A6 48896378                         mov [rbx + 120], rsp
   607 000012AA 4C898380000000                   mov [rbx + 128], r8
   608 000012B1 4C898B88000000                   mov [rbx + 136], r9
   609 000012B8 4C899390000000                   mov [rbx + 144], r10
   610                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   611 000012BF 4C89B3B0000000                   mov [rbx + 176], r14
   612 000012C6 4C89BBB8000000                   mov [rbx + 184], r15
   613 000012CD 4C8B2D(08000000)                 mov r13, [rel position]
   614 000012D4 4D8DAD[48130000]                 lea r13, [r13 + .return]                 ;将来恢复执行时，是从例程调用返回
   615 000012DB 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   616 000012E2 8C8BC8000000                     mov [rbx + 200], cs
   617 000012E8 8C93D0000000                     mov [rbx + 208], ss
   618 000012EE 9C                               pushfq
   619 000012EF 8F83E8000000                     pop qword [rbx + 232]
   620                                  
   621 000012F5 48C7431003000000                 mov qword [rbx + 16], 3                  ;置线程状态为“休眠并等待指定线程结束”
   622 000012FD 48895338                         mov qword [rbx + 56], rdx                ;设置被等待的线程标识
   623                                  
   624 00001301 E8E2FBFFFF                       call search_for_a_ready_thread
   625 00001306 4D09DB                           or r11, r11
   626 00001309 7405                             jz .sleep                                ;未找到就绪的任务
   627                                  
   628 0000130B E94DFCFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   629                                  
   630                                    .sleep:
   631 00001310 0F01F8                           swapgs
   632 00001313 6548C7042500000000-              mov qword [gs:0], 0                      ;当前处理器无有效3特权级栈指针
   632 0000131C 00000000           
   633 00001320 6548C7042508000000-              mov qword [gs:8], 0                      ;当前处理器未在执行任务
   633 00001329 00000000           
   634 0000132D 6548C7042520000000-              mov qword [gs:32], 0                     ;当前处理器未在执行线程
   634 00001336 00000000           
   635 0000133A 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   636 00001343 0F01F8                           swapgs
   637                                  
   638 00001346 48CF                             iretq
   639                                    .return:
   640 00001348 415D                             pop r13
   641 0000134A 415C                             pop r12
   642 0000134C 415B                             pop r11
   643 0000134E 5B                               pop rbx
   644 0000134F 58                               pop rax
   645                                  
   646 00001350 C3                               ret
   647                                  
   648                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   649                                  init_mutex:                                       ;初始化互斥锁
   650                                                                                    ;输入：无
   651                                                                                    ;输出：RDX=互斥锁变量线性地址
   652 00001351 51                               push rcx
   653 00001352 4155                             push r13
   654 00001354 4156                             push r14
   655 00001356 B908000000                       mov rcx, 8
   656 0000135B E81BF6FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   657 00001360 49C7450000000000                 mov qword [r13], 0                       ;初始化互斥锁的状态（未加锁）
   658 00001368 4C89EA                           mov rdx, r13
   659 0000136B 415E                             pop r14
   660 0000136D 415D                             pop r13
   661 0000136F 59                               pop rcx
   662                                  
   663 00001370 C3                               ret
   664                                  
   665                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   666                                  acquire_mutex:                                    ;获取互斥锁
   667                                                                                    ;输入：RDX=互斥锁变量线性地址
   668 00001371 50                               push rax
   669 00001372 53                               push rbx
   670 00001373 4153                             push r11
   671 00001375 4154                             push r12
   672 00001377 4155                             push r13
   673                                  
   674 00001379 41BB01000000                     mov r11, 1
   675 0000137F B800000000                       mov rax, 0
   676 00001384 F04C0FB11A                       lock cmpxchg [rdx], r11
   677 00001389 0F84EB000000                     jz .return
   678                                  
   679                                           ;未获得互斥锁，只能阻塞当前线程。
   680 0000138F FA                               cli
   681                                  
   682 00001390 48B800E0FFFF7FFFFF-              mov rax, LAPIC_START_ADDR                ;Local APIC的线性地址
   682 00001399 FF                 
   683 0000139A C78020030000000001-              mov dword [rax + 0x320], 0x00010000      ;屏蔽定时器中断
   683 000013A3 00                 
   684                                  
   685 000013A4 0F01F8                           swapgs
   686 000013A7 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   687 000013B0 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   688 000013B9 0F01F8                           swapgs
   689                                  
   690                                           ;保存当前任务和线程的状态以便将来恢复执行。恢复时已获得互斥锁
   691 000013BC 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   692 000013C0 4C896838                         mov qword [rax + 56], r13
   693                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   694 000013C4 48894B50                         mov [rbx + 80], rcx
   695 000013C8 48895358                         mov [rbx + 88], rdx
   696 000013CC 48897360                         mov [rbx + 96], rsi
   697 000013D0 48897B68                         mov [rbx + 104], rdi
   698 000013D4 48896B70                         mov [rbx + 112], rbp
   699 000013D8 48896378                         mov [rbx + 120], rsp
   700 000013DC 4C898380000000                   mov [rbx + 128], r8
   701 000013E3 4C898B88000000                   mov [rbx + 136], r9
   702 000013EA 4C899390000000                   mov [rbx + 144], r10
   703                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   704 000013F1 4C89B3B0000000                   mov [rbx + 176], r14
   705 000013F8 4C89BBB8000000                   mov [rbx + 184], r15
   706 000013FF 4C8B2D(08000000)                 mov r13, [rel position]
   707 00001406 4D8DAD[7A140000]                 lea r13, [r13 + .return]                 ;将来恢复执行时已获得互斥锁
   708 0000140D 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   709 00001414 8C8BC8000000                     mov [rbx + 200], cs
   710 0000141A 8C93D0000000                     mov [rbx + 208], ss
   711 00001420 9C                               pushfq
   712 00001421 8F83E8000000                     pop qword [rbx + 232]
   713                                  
   714 00001427 48895338                         mov qword [rbx + 56], rdx                ;设置被等待的数据的线性地址
   715 0000142B 48C7431005000000                 mov qword [rbx + 16], 5                  ;置线程状态为“休眠并等待某个信号清零”
   716                                  
   717 00001433 E8B0FAFFFF                       call search_for_a_ready_thread
   718 00001438 4D09DB                           or r11, r11
   719 0000143B 7405                             jz .sleep                                ;未找到就绪的任务
   720                                  
   721 0000143D E91BFBFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   722                                  
   723                                    .sleep:
   724 00001442 0F01F8                           swapgs
   725 00001445 6548C7042500000000-              mov qword [gs:0], 0                      ;当前处理器无有效3特权级栈指针
   725 0000144E 00000000           
   726 00001452 6548C7042508000000-              mov qword [gs:8], 0                      ;当前处理器未在执行任务
   726 0000145B 00000000           
   727 0000145F 6548C7042520000000-              mov qword [gs:32], 0                     ;当前处理器未在执行线程
   727 00001468 00000000           
   728 0000146C 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   729 00001475 0F01F8                           swapgs
   730                                  
   731 00001478 48CF                             iretq
   732                                  
   733                                    .return:
   734 0000147A 415D                             pop r13
   735 0000147C 415C                             pop r12
   736 0000147E 415B                             pop r11
   737 00001480 5B                               pop rbx
   738 00001481 58                               pop rax
   739                                  
   740 00001482 C3                               ret
   741                                  
   742                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   743                                  release_mutex:                                    ;释放互斥锁
   744                                                                                    ;输入：RDX=互斥锁变量线性地址
   745 00001483 50                               push rax
   746 00001484 4831C0                           xor rax, rax
   747 00001487 488702                           xchg [rdx], rax
   748 0000148A 58                               pop rax
   749                                  
   750 0000148B C3                               ret
   751                                  
   752                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   753                                  thread_sleep:                                     ;线程休眠
   754                                                                                    ;输入：RDX=以55ms为单位的时间长度
   755 0000148C 50                               push rax
   756 0000148D 53                               push rbx
   757 0000148E 4153                             push r11
   758 00001490 4154                             push r12
   759 00001492 4155                             push r13
   760                                  
   761 00001494 4883FA00                         cmp rdx, 0
   762 00001498 0F84EB000000                     je .return
   763                                  
   764                                           ;休眠就意味着阻塞当前线程。
   765 0000149E FA                               cli
   766                                  
   767 0000149F 48B800E0FFFF7FFFFF-              mov rax, LAPIC_START_ADDR                ;Local APIC的线性地址
   767 000014A8 FF                 
   768 000014A9 C78020030000000001-              mov dword [rax + 0x320], 0x00010000      ;屏蔽定时器中断
   768 000014B2 00                 
   769                                  
   770 000014B3 0F01F8                           swapgs
   771 000014B6 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   772 000014BF 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   773 000014C8 0F01F8                           swapgs
   774                                  
   775                                           ;保存当前任务和线程的状态以便将来恢复执行。
   776 000014CB 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   777 000014CF 4C896838                         mov qword [rax + 56], r13
   778                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   779 000014D3 48894B50                         mov [rbx + 80], rcx
   780 000014D7 48895358                         mov [rbx + 88], rdx
   781 000014DB 48897360                         mov [rbx + 96], rsi
   782 000014DF 48897B68                         mov [rbx + 104], rdi
   783 000014E3 48896B70                         mov [rbx + 112], rbp
   784 000014E7 48896378                         mov [rbx + 120], rsp
   785 000014EB 4C898380000000                   mov [rbx + 128], r8
   786 000014F2 4C898B88000000                   mov [rbx + 136], r9
   787 000014F9 4C899390000000                   mov [rbx + 144], r10
   788                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   789 00001500 4C89B3B0000000                   mov [rbx + 176], r14
   790 00001507 4C89BBB8000000                   mov [rbx + 184], r15
   791 0000150E 4C8B2D(08000000)                 mov r13, [rel position]
   792 00001515 4D8DAD[89150000]                 lea r13, [r13 + .return]                 ;将来恢复执行时，重新尝试加锁
   793 0000151C 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   794 00001523 8C8BC8000000                     mov [rbx + 200], cs
   795 00001529 8C93D0000000                     mov [rbx + 208], ss
   796 0000152F 9C                               pushfq
   797 00001530 8F83E8000000                     pop qword [rbx + 232]
   798                                  
   799 00001536 48895338                         mov qword [rbx + 56], rdx                ;设置以55ms为单位的时间长度
   800 0000153A 48C7431004000000                 mov qword [rbx + 16], 4                  ;置线程状态为“休眠指定时间长度”
   801                                  
   802 00001542 E8A1F9FFFF                       call search_for_a_ready_thread
   803 00001547 4D09DB                           or r11, r11
   804 0000154A 7405                             jz .sleep                                ;未找到就绪的任务
   805                                  
   806 0000154C E90CFAFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   807                                  
   808                                    .sleep:
   809 00001551 0F01F8                           swapgs
   810 00001554 6548C7042500000000-              mov qword [gs:0], 0                      ;当前处理器无有效3特权级栈指针
   810 0000155D 00000000           
   811 00001561 6548C7042508000000-              mov qword [gs:8], 0                      ;当前处理器未在执行任务
   811 0000156A 00000000           
   812 0000156E 6548C7042520000000-              mov qword [gs:32], 0                     ;当前处理器未在执行线程
   812 00001577 00000000           
   813 0000157B 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   814 00001584 0F01F8                           swapgs
   815                                  
   816 00001587 48CF                             iretq
   817                                  
   818                                    .return:
   819 00001589 48BB00800B000080FF-     mov rbx, UPPER_TEXT_VIDEO
   819 00001592 FF                 
   820 00001593 F65302                  not byte [rbx + 2]
   821 00001596 415D                             pop r13
   822 00001598 415C                             pop r12
   823 0000159A 415B                             pop r11
   824 0000159C 5B                               pop rbx
   825 0000159D 58                               pop rax
   826                                  
   827 0000159E C3                               ret
   828                                  
   829                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   830                                  thread_exit:                                      ;线程终止退出
   831                                                                                    ;输入：RDX=返回码
   832 0000159F 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   832 000015A8 FF                 
   833 000015A9 C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   833 000015B2 00                 
   834                                  
   835 000015B3 FA                               cli
   836                                  
   837 000015B4 0F01F8                           swapgs
   838 000015B7 65488B1C2520000000               mov rbx, [gs:32]                         ;取出当前线程的TCB线性地址
   839 000015C0 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   840                                  
   841 000015C9 6548C7042500000000-              mov qword [gs:0], 0                      ;当前处理器无有效3特权级栈指针
   841 000015D2 00000000           
   842 000015D6 6548C7042508000000-              mov qword [gs:8], 0                      ;当前处理器未在执行任务
   842 000015DF 00000000           
   843 000015E3 6548C7042520000000-              mov qword [gs:32], 0                     ;当前处理器未在执行线程
   843 000015EC 00000000           
   844 000015F0 0F01F8                           swapgs
   845                                  
   846 000015F3 48C7431002000000                 mov qword [rbx + 16], 2                  ;线程状态：终止
   847 000015FB 48895318                         mov [rbx + 24], rdx                      ;返回代码
   848                                  
   849 000015FF E8E4F8FFFF                       call search_for_a_ready_thread
   850 00001604 4D09DB                           or r11, r11
   851 00001607 7405                             jz .sleep                                ;未找到就绪的线程
   852                                  
   853 00001609 E94FF9FFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   854                                  
   855                                    .sleep:
   856 0000160E 48CF                             iretq                                    ;回到不执行线程的日子:)
   857                                  
   858                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   859                                  terminate_process:                                ;终止当前任务
   860 00001610 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   860 00001619 FF                 
   861 0000161A C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   861 00001623 00                 
   862                                  
   863 00001624 FA                               cli
   864                                  
   865 00001625 0F01F8                           swapgs
   866 00001628 65488B042508000000               mov rax, [gs:8]                          ;定位到当前任务的PCB节点
   867 00001631 48C7401002000000                 mov qword [rax + 16], 2                  ;任务状态=终止
   868 00001639 65488B042520000000               mov rax, [gs:32]                         ;定位到当前线程的TCB节点
   869 00001642 48C7401002000000                 mov qword [rax + 16], 2                  ;线程状态=终止
   870 0000164A 6548C7042500000000-              mov qword [gs:0], 0
   870 00001653 00000000           
   871 00001657 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   872                                  
   873 00001660 6548C7042500000000-              mov qword [gs:0], 0                      ;当前处理器无有效3特权级栈指针
   873 00001669 00000000           
   874 0000166D 6548C7042508000000-              mov qword [gs:8], 0                      ;当前处理器未在执行任务
   874 00001676 00000000           
   875 0000167A 6548C7042520000000-              mov qword [gs:32], 0                     ;当前处理器未在执行线程
   875 00001683 00000000           
   876 00001687 0F01F8                           swapgs
   877                                  
   878 0000168A E859F8FFFF                       call search_for_a_ready_thread
   879 0000168F 4D09DB                           or r11, r11
   880 00001692 7405                             jz .sleep                                ;未找到就绪的任务
   881                                  
   882 00001694 E9C4F8FFFF                       jmp resume_execute_a_thread              ;恢复并执行新任务
   883                                  
   884                                    .sleep:
   885 00001699 48CF                             iretq                                    ;回到不执行任务的日子:)
   886                                  
   887                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   888                                  create_thread:                                    ;创建一个线程
   889                                                                                    ;输入：RSI=线程入口的线性地址
   890                                                                                    ;      RDI=传递给线程的参数
   891                                                                                    ;输出：RDX=线程标识
   892 0000169B 50                               push rax
   893 0000169C 53                               push rbx
   894 0000169D 51                               push rcx
   895 0000169E 4153                             push r11
   896 000016A0 4154                             push r12
   897 000016A2 4155                             push r13
   898 000016A4 4156                             push r14
   899                                  
   900                                           ;先创建线程控制块TCB
   901 000016A6 B900020000                       mov rcx, 512                             ;线程控制块TCB的尺寸
   902 000016AB E8CBF2FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   903                                  
   904 000016B0 4C89EB                           mov rbx, r13                             ;以下，RBX专用于保存TCB线性地址
   905                                  
   906 000016B3 E8CEF4FFFF                       call generate_thread_id
   907 000016B8 48894308                         mov [rbx + 8], rax                       ;记录当前线程的标识
   908 000016BC 4889C2                           mov rdx, rax                             ;用于返回线程标识
   909                                  
   910 000016BF 48C7431000000000                 mov qword [rbx + 16], 0                  ;线程状态=就绪
   911                                  
   912 000016C7 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   913 000016CC E8AAF2FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   914 000016D1 4C897320                         mov [rbx + 32], r14                      ;填写TCB中的RSP0域的值
   915                                  
   916 000016D5 9C                               pushfq
   917 000016D6 FA                               cli
   918 000016D7 0F01F8                           swapgs
   919 000016DA 654C8B1C2508000000               mov r11, [gs:8]                          ;获取当前任务的PCB线性地址
   920 000016E3 654C8B242520000000               mov r12, [gs:32]                         ;获取当前线程的TCB线性地址
   921 000016EC 0F01F8                           swapgs
   922 000016EF 9D                               popfq
   923                                  
   924 000016F0 B900000100                       mov rcx, 4096 * 16                       ;为线程开辟栈空间
   925 000016F5 E802F3FFFF                       call user_memory_allocate
   926 000016FA 4983EE20                         sub r14, 32                              ;在栈中开辟32字节的空间
   927 000016FE 4C897378                         mov [rbx + 120], r14                     ;线程执行时的RSP。
   928                                  
   929 00001702 498D4E08                         lea rcx, [r14 + 8]                       ;得到线程返回地址
   930 00001706 49890E                           mov [r14], rcx
   931                                           ;以下填写指令MOV RAX, 9的机器代码
   932 00001709 C601B8                           mov byte [rcx], 0xb8
   933 0000170C C6410109                         mov byte [rcx + 1], 0x09
   934 00001710 C6410200                         mov byte [rcx + 2], 0x00
   935 00001714 C6410300                         mov byte [rcx + 3], 0x00
   936 00001718 C6410400                         mov byte [rcx + 4], 0x00
   937                                           ;以下填写指令XOR RDX, RDX的机器代码
   938 0000171C C6410548                         mov byte [rcx + 5], 0x48
   939 00001720 C6410631                         mov byte [rcx + 6], 0x31
   940 00001724 C64107D2                         mov byte [rcx + 7], 0xd2
   941                                           ;以下填写指令SYSCALL的机器代码
   942 00001728 C641080F                         mov byte [rcx + 8], 0x0f
   943 0000172C C6410905                         mov byte [rcx + 9], 0x05
   944                                  
   945 00001730 4889B3C0000000                   mov qword [rbx + 192], rsi               ;线程入口点（RIP）
   946                                  
   947 00001737 48C783C80000003B00-              mov qword [rbx + 200], USER_CODE64_SEL   ;线程的代码段选择子
   947 00001740 0000               
   948 00001742 48C783D00000003300-              mov qword [rbx + 208], USER_STACK64_SEL  ;线程的栈段选择子
   948 0000174B 0000               
   949                                  
   950 0000174D 9C                               pushfq
   951 0000174E 8F83E8000000                     pop qword [rbx + 232]                    ;线程执行时的标志寄存器
   952                                  
   953 00001754 48C783F00000003700-              mov qword [rbx + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片
   953 0000175D 0000               
   954                                  
   955 0000175F 48C783180100000000-              mov qword [rbx + 280], 0                 ;下一个TCB的线性地址，0=无
   955 00001768 0000               
   956                                  
   957                                    .again:
   958 0000176A 4831C0                           xor rax, rax
   959 0000176D F0490FB19C24180100-              lock cmpxchg [r12 + 280], rbx            ;如果节点的后继为0，则新节点为其后继
   959 00001776 00                 
   960 00001777 740A                             jz .linkd
   961 00001779 4D8BA42418010000                 mov r12, [r12 + 280]
   962 00001781 EBE7                             jmp .again
   963                                    .linkd:
   964 00001783 48B900E0FFFF7FFFFF-              mov rcx, LAPIC_START_ADDR                ;Local APIC的线性地址
   964 0000178C FF                 
   965 0000178D C78110030000000000-              mov dword [rcx + 0x310], 0
   965 00001796 00                 
   966 00001797 C78100030000FE4008-              mov dword [rcx + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   966 000017A0 00                 
   967                                  
   968 000017A1 415E                             pop r14
   969 000017A3 415D                             pop r13
   970 000017A5 415C                             pop r12
   971 000017A7 415B                             pop r11
   972 000017A9 59                               pop rcx
   973 000017AA 5B                               pop rbx
   974 000017AB 58                               pop rax
   975                                  
   976 000017AC C3                               ret
   977                                  
   978                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   979                                  create_process:                                   ;创建新的任务及其主线程
   980                                                                                    ;输入：R8=程序的起始逻辑扇区号
   981 000017AD 50                               push rax
   982 000017AE 53                               push rbx
   983 000017AF 51                               push rcx
   984 000017B0 52                               push rdx
   985 000017B1 56                               push rsi
   986 000017B2 57                               push rdi
   987 000017B3 55                               push rbp
   988 000017B4 4150                             push r8
   989 000017B6 4151                             push r9
   990 000017B8 4152                             push r10
   991 000017BA 4153                             push r11
   992 000017BC 4154                             push r12
   993 000017BE 4155                             push r13
   994 000017C0 4156                             push r14
   995 000017C2 4157                             push r15
   996                                  
   997                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   998 000017C4 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   999 000017C9 E8ADF1FFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
  1000 000017CE 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
  1001                                  
  1002 000017D1 E8A5F1FFFF                       call core_memory_allocate                ;为线程控制块TCB分配内存
  1003 000017D6 4D89EC                           mov r12, r13                             ;以下，R12专用于保存TCB线性地址
  1004                                  
  1005 000017D9 4D89A310010000                   mov qword [r11 + 272], r12               ;在PCB中登记第一个TCB
  1006                                  
  1007 000017E0 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
  1008                                  
  1009                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
  1010 000017E8 E863F2FFFF                       call copy_current_pml4
  1011 000017ED 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
  1012                                  
  1013                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
  1014                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
  1015                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈是位于地址空间高端的栈。
  1016                                  
  1017 000017F1 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
  1018 000017F5 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
  1019                                  
  1020                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
  1021 000017F8 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
  1022 000017FF B900010000                       mov rcx, 256
  1023                                    .clsp:
  1024 00001804 48C70000000000                   mov qword [rax], 0
  1025 0000180B 4883C008                         add rax, 8
  1026 0000180F E2F3                             loop .clsp
  1027                                  
  1028 00001811 0F20D8                           mov rax, cr3                             ;刷新TLB
  1029 00001814 0F22D8                           mov cr3, rax
  1030                                  
  1031 00001817 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
  1032 0000181C E85AF1FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
  1033 00001821 4D89742420                       mov [r12 + 32], r14                      ;填写TCB中的RSP0域的值
  1034                                  
  1035 00001826 B900000100                       mov rcx, 4096 * 16                       ;为主线程开辟栈空间
  1036 0000182B E8CCF1FFFF                       call user_memory_allocate
  1037 00001830 4D89742478                       mov [r12 + 120], r14                     ;主线程执行时的RSP。
  1038                                  
  1039 00001835 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=运行
  1040 0000183D 49C744241000000000               mov qword [r12 + 16], 0                  ;线程状态=就绪
  1041                                  
  1042                                           ;以下开始加载用户程序
  1043 00001846 B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
  1044 0000184B E8ACF1FFFF                       call user_memory_allocate
  1045 00001850 4C89EB                           mov rbx, r13
  1046 00001853 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
  1047 00001856 E8FDE9FFFF                       call read_hard_disk_0
  1048                                  
  1049 0000185B 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
  1050 0000185F 4D89EE                           mov r14, r13
  1051 00001862 4D037508                         add r14, [r13 + 8]
  1052 00001866 4D89B424C0000000                 mov [r12 + 192], r14                     ;在TCB中登记程序的入口点线性地址
  1053                                  
  1054                                           ;以下判断整个程序有多大
  1055 0000186E 498B4D00                         mov rcx, [r13]                           ;程序尺寸
  1056 00001872 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
  1057 00001879 740F                             jz .y512
  1058 0000187B 48C1E909                         shr rcx, 9                               ;不能？凑整。
  1059 0000187F 48C1E109                         shl rcx, 9
  1060 00001883 4881C100020000                   add rcx, 512
  1061                                    .y512:
  1062 0000188A 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
  1063 00001891 7416                             jz .rdok
  1064 00001893 E864F1FFFF                       call user_memory_allocate
  1065                                           ;mov rbx, r13
  1066 00001898 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
  1067 0000189C 48FFC0                           inc rax                                  ;起始扇区号
  1068                                    .b1:
  1069 0000189F E8B4E9FFFF                       call read_hard_disk_0
  1070 000018A4 48FFC0                           inc rax
  1071 000018A7 E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
  1072                                  
  1073                                    .rdok:
  1074 000018A9 49C78424C80000003B-              mov qword [r12 + 200], USER_CODE64_SEL   ;主线程的代码段选择子
  1074 000018B2 000000             
  1075 000018B5 49C78424D000000033-              mov qword [r12 + 208], USER_STACK64_SEL  ;主线程的栈段选择子
  1075 000018BE 000000             
  1076                                  
  1077 000018C1 9C                               pushfq
  1078 000018C2 418F8424E8000000                 pop qword [r12 + 232]
  1079                                  
  1080 000018CA 49C78424F000000037-              mov qword [r12 + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片
  1080 000018D3 000000             
  1081                                  
  1082 000018D6 E894F2FFFF                       call generate_process_id
  1083 000018DB 49894308                         mov [r11 + 8], rax                       ;记录新任务的标识
  1084                                  
  1085 000018DF E8A2F2FFFF                       call generate_thread_id
  1086 000018E4 4989442408                       mov [r12 + 8], rax                       ;记录主线程的标识
  1087                                  
  1088 000018E9 49C784241801000000-              mov qword [r12 + 280], 0                 ;下一个TCB的线性地址（0=无）
  1088 000018F2 000000             
  1089                                  
  1090 000018F5 E874F8FFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
  1091                                  
  1092 000018FA 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
  1093                                  
  1094 000018FE 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
  1094 00001907 FF                 
  1095 00001908 C78610030000000000-              mov dword [rsi + 0x310], 0
  1095 00001911 00                 
  1096 00001912 C78600030000FE4008-              mov dword [rsi + 0x300], 0x000840fe      ;向所有处理器发送任务/线程认领中断
  1096 0000191B 00                 
  1097                                  
  1098 0000191C 415F                             pop r15
  1099 0000191E 415E                             pop r14
  1100 00001920 415D                             pop r13
  1101 00001922 415C                             pop r12
  1102 00001924 415B                             pop r11
  1103 00001926 415A                             pop r10
  1104 00001928 4159                             pop r9
  1105 0000192A 4158                             pop r8
  1106 0000192C 5D                               pop rbp
  1107 0000192D 5F                               pop rdi
  1108 0000192E 5E                               pop rsi
  1109 0000192F 5A                               pop rdx
  1110 00001930 59                               pop rcx
  1111 00001931 5B                               pop rbx
  1112 00001932 58                               pop rax
  1113                                  
  1114 00001933 C3                               ret
  1115                                  
  1116                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1117                                  syscall_procedure:                                ;系统调用的处理过程
  1118                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；进入时中断是禁止状态
  1119 00001934 0F01F8                           swapgs                                   ;切换GS到当前处理器的数据区
  1120 00001937 654889242500000000               mov [gs:0], rsp                          ;临时保存当前的3特权级栈指针
  1121 00001940 65488B242584000000               mov rsp, [gs:128+4]                      ;使用TSS的RSP0作为安全栈指针
  1122 00001949 65FF342500000000                 push qword [gs:0]
  1123 00001951 0F01F8                           swapgs
  1124 00001954 FB                               sti                                      ;准备工作全部完成，中断和任务切换无虞
  1125                                  
  1126 00001955 51                               push rcx
  1127 00001956 488B0D(08000000)                 mov rcx, [rel position]
  1128 0000195D 48038CC1[69020000]               add rcx, [rcx + rax * 8 + sys_entry]     ;得到指定的那个系统调用功能的线性地址
  1129 00001965 FFD1                             call rcx
  1130 00001967 59                               pop rcx
  1131                                  
  1132 00001968 FA                               cli
  1133 00001969 5C                               pop rsp                                  ;恢复原先的3特权级栈指针
  1134                                  
  1135 0000196A 480F07                           o64 sysret
  1136                                  
  1137                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1138                                  init:    ;初始化内核的工作环境
  1139                                  
  1140                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
  1141                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
  1142 0000196D 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
  1142 00001976 FF                 
  1143 00001977 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
  1144                                  
  1145 0000197F 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
  1146                                  
  1147                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
  1148                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
  1149 00001987 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
  1149 00001990 FF                 
  1150 00001991 4801C4                           add rsp, rax                             ;栈指针必须转换为高端地址且必须是扩高地址
  1151                                  
  1152                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
  1153 00001994 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
  1153 0000199D FF                 
  1154 0000199E 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
  1155                                  
  1156                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
  1157 000019A5 488B05(08000000)                 mov rax, [rel position]
  1158 000019AC 4805[B4190000]                   add rax, .to_upper
  1159 000019B2 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
  1160                                  
  1161                                    .to_upper:
  1162                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
  1163                                  
  1164                                           ;为32个异常创建通用处理过程的中断门
  1165 000019B4 4C8B0D(08000000)                 mov r9, [rel position]
  1166 000019BB 498D81[6C0D0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
  1167 000019C2 E8E5E7FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1168                                  
  1169 000019C7 4D31C0                           xor r8, r8
  1170                                    .idt0:
  1171 000019CA E83EE8FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1172 000019CF 49FFC0                           inc r8
  1173 000019D2 4983F81F                         cmp r8, 31
  1174 000019D6 7EF2                             jle .idt0
  1175                                  
  1176                                           ;创建并安装对应于其它中断的通用处理过程的中断门
  1177 000019D8 498D81[6A0D0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
  1178 000019DF E8C8E7FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1179                                  
  1180 000019E4 41B820000000                     mov r8, 32
  1181                                    .idt1:
  1182 000019EA E81EE8FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1183 000019EF 49FFC0                           inc r8
  1184 000019F2 4981F8FF000000                   cmp r8, 255
  1185 000019F9 7EEF                             jle .idt1
  1186                                  
  1187 000019FB 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
  1187 00001A04 FF                 
  1188 00001A05 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
  1188 00001A0E FF                 
  1189 00001A0F 4889430E                         mov qword [rbx + 0x0e], rax
  1190 00001A13 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
  1191                                  
  1192 00001A19 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
  1193                                  
  1194 00001A1D B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
  1195 00001A1F E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
  1196                                  
  1197                                           ;在64位模式下显示的第一条信息!
  1198 00001A21 4C8B3D(08000000)                 mov r15, [rel position]
  1199 00001A28 498D9F[36010000]                 lea rbx, [r15 + welcome]
  1200 00001A2F E8D4E5FFFF                       call put_string64                        ;位于core_utils64_mp.wid
  1201                                  
  1202                                           ;安装系统服务（SYSCALL/SYSRET）所需要的代码段和栈段描述符
  1203 00001A34 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区SDA的线性地址
  1203 00001A3D FF                 
  1204 00001A3E 4831DB                           xor rbx, rbx
  1205 00001A41 66418B5F02                       mov bx, [r15 + 2]                        ;BX=GDT的界限值
  1206 00001A46 66FFC3                           inc bx                                   ;BX=GDT的长度
  1207 00001A49 49035F04                         add rbx, [r15 + 4]                       ;RBX=新描述符的追加位置
  1208                                  
  1209 00001A4D C703FFFF0000                     mov dword [rbx], 0x0000ffff              ;64位模式下不支持64位立即数传送
  1210 00001A53 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
  1211 00001A5A C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
  1212 00001A61 C7430C00000000                   mov dword [rbx + 12], 0
  1213 00001A68 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
  1214 00001A6F C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
  1215 00001A76 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
  1216 00001A7D C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
  1217                                  
  1218                                           ;我们为每个逻辑处理器都准备一个专属数据区，它是由每个处理器的GS所指向的。
  1219                                           ;为当前处理器（BSP）准备专属数据区，设置GS并安装任务状态段TSS的描述符
  1220 00001A84 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
  1221 00001A89 E8EDEEFFFF                       call core_memory_allocate
  1222 00001A8E 49C7450800000000                 mov qword [r13 + 8], 0                   ;提前将“当前任务的PCB指针域”清零
  1223 00001A96 49C7451000000000                 mov qword [r13 + 16], 0                  ;将当前处理器的编号设置为#0
  1224 00001A9E 49896518                         mov [r13 + 24], rsp                      ;设置当前处理器的专属栈
  1225 00001AA2 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
  1226 00001AA9 E836E7FFFF                       call make_tss_descriptor
  1227 00001AAE 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
  1228 00001AB2 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
  1229                                  
  1230 00001AB6 664183470230                     add word [r15 + 2], 48                   ;4个段描述符和1个TSS描述符的总字节数
  1231 00001ABC 410F015702                       lgdt [r15 + 2]
  1232                                  
  1233 00001AC1 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
  1234 00001AC5 0F00D9                           ltr cx
  1235                                  
  1236                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
  1237 00001AC8 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
  1238 00001ACD 4C89E8                           mov rax, r13                             ;只用EAX
  1239 00001AD0 4C89EA                           mov rdx, r13
  1240 00001AD3 48C1EA20                         shr rdx, 32                              ;只用EDX
  1241 00001AD7 0F30                             wrmsr
  1242                                  
  1243                                           ;为快速系统调用SYSCALL和SYSRET准备参数
  1244 00001AD9 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
  1245 00001ADE 0F32                             rdmsr
  1246 00001AE0 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
  1247 00001AE4 0F30                             wrmsr
  1248                                  
  1249 00001AE6 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
  1250 00001AEB BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
  1251 00001AF0 31C0                             xor eax, eax
  1252 00001AF2 0F30                             wrmsr
  1253                                  
  1254 00001AF4 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
  1255 00001AF9 488B05(08000000)                 mov rax, [rel position]
  1256 00001B00 488D80[34190000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
  1257 00001B07 4889C2                           mov rdx, rax
  1258 00001B0A 48C1EA20                         shr rdx, 32                              ;使用EDX部分
  1259 00001B0E 0F30                             wrmsr
  1260                                  
  1261 00001B10 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
  1262 00001B15 31D2                             xor edx, edx
  1263 00001B17 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
  1264 00001B1C 0F30                             wrmsr
  1265                                  
  1266                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC
  1267                                           ;做了初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理
  1268                                           ;器和APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可
  1269                                           ;扩展固件接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表
  1270                                           ;格并从中获取多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚
  1271                                           ;拟机的配置！
  1272                                  
  1273                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
  1274                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
  1275 00001B1E 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
  1276 00001B27 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
  1277 00001B29 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
  1278                                    .looking:
  1279 00001B2E 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
  1280 00001B32 741B                             jz .looked
  1281 00001B34 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
  1282 00001B38 E2F4                             loop .looking
  1283                                  
  1284                                    .acpi_err:
  1285 00001B3A 4C8B3D(08000000)                 mov r15, [rel position]
  1286 00001B41 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
  1287 00001B48 E8BBE4FFFF                       call put_string64                        ;位于core_utils64_mp.wid
  1288 00001B4D FA                               cli
  1289 00001B4E F4                               hlt
  1290                                  
  1291                                    .looked:
  1292 00001B4F 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
  1293 00001B52 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
  1294 00001B56 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
  1295 00001B59 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
  1296                                    .maping:
  1297 00001B60 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
  1298 00001B63 4889D8                           mov rax, rbx
  1299 00001B66 4821D0                           and rax, rdx
  1300 00001B69 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
  1301 00001B6D E80EEDFFFF                       call mapping_laddr_to_page
  1302 00001B72 4881C300100000                   add rbx, 0x1000
  1303 00001B79 4839CB                           cmp rbx, rcx
  1304 00001B7C 7EE2                             jle .maping
  1305                                  
  1306                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
  1307 00001B7E BB00000600                       mov rbx, 0x60000
  1308 00001B83 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
  1308 00001B8C 20                 
  1309                                    .searc:
  1310 00001B8D 48390B                           cmp qword [rbx], rcx
  1311 00001B90 740F                             je .finda
  1312 00001B92 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
  1313 00001B96 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
  1314 00001B9D 7CEE                             jl .searc
  1315 00001B9F EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
  1316                                  
  1317                                    .finda:
  1318                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
  1319                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
  1320 00001BA1 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
  1321 00001BA5 752B                             jne .vcpi_1
  1322 00001BA7 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
  1323                                  
  1324                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
  1325 00001BAB 4831FF                           xor rdi, rdi
  1326 00001BAE 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
  1327 00001BB1 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
  1328 00001BB4 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
  1329                                    .madt0:
  1330 00001BB8 4C8B1B                           mov r11, [rbx]
  1331 00001BBB 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
  1332 00001BC2 7436                             je .findm
  1333 00001BC4 4883C308                         add rbx, 8                               ;下一个元素
  1334 00001BC8 4839FB                           cmp rbx, rdi
  1335 00001BCB 7CEB                             jl .madt0
  1336 00001BCD E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
  1337                                  
  1338                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
  1339                                    .vcpi_1:
  1340 00001BD2 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
  1341                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
  1342 00001BD5 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
  1343 00001BD9 01DF                             add edi, ebx                             ;计算RSDT上边界的物理位置
  1344 00001BDB 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
  1345 00001BDE 4D31DB                           xor r11, r11
  1346                                    .madt1:
  1347 00001BE1 67448B1B                         mov r11d, [ebx]
  1348 00001BE5 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
  1349 00001BEC 740C                             je .findm
  1350 00001BEE 83C304                           add ebx, 4                               ;下一个元素
  1351 00001BF1 39FB                             cmp ebx, edi
  1352 00001BF3 7CEC                             jl .madt1
  1353 00001BF5 E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
  1354                                  
  1355                                    .findm:
  1356                                           ;此时，R11是MADT的物理地址
  1357 00001BFA 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
  1358 00001BFE 8915(28010000)                   mov [rel lapic_addr], edx
  1359                                  
  1360                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
  1361 00001C04 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
  1362 00001C0B 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
  1363                                  
  1364 00001C12 4831FF                           xor rdi, rdi
  1365 00001C15 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
  1366 00001C19 4C01DF                           add rdi, r11                             ;RDI:MADT上部边界的物理地址
  1367 00001C1C 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
  1368                                    .enumd:
  1369 00001C20 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
  1370 00001C24 7408                             je .l_apic
  1371 00001C26 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
  1372 00001C2A 741B                             je .ioapic
  1373 00001C2C EB2D                             jmp .m_end
  1374                                    .l_apic:
  1375 00001C2E 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
  1376 00001C33 7426                             jz .m_end
  1377 00001C35 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
  1378 00001C39 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
  1379 00001C3C 49FFC7                           inc r15
  1380 00001C3F FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
  1381 00001C45 EB14                             jmp .m_end
  1382                                    .ioapic:
  1383 00001C47 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
  1384 00001C4B 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
  1385 00001C51 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
  1386 00001C55 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
  1387                                     .m_end:
  1388 00001C5B 4831C0                           xor rax, rax
  1389 00001C5E 418A4301                         mov al, [r11 + 1]
  1390 00001C62 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
  1391 00001C65 4939FB                           cmp r11, rdi
  1392 00001C68 7CB6                             jl .enumd
  1393                                  
  1394                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
  1395 00001C6A 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
  1395 00001C73 FF                 
  1396 00001C74 4831C0                           xor rax, rax
  1397 00001C77 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
  1398 00001C7D 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
  1399 00001C80 E8FBEBFFFF                       call mapping_laddr_to_page
  1400                                  
  1401                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
  1402 00001C85 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
  1402 00001C8E FF                 
  1403 00001C8F 4831C0                           xor rax, rax
  1404 00001C92 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
  1405 00001C98 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
  1406 00001C9B E8E0EBFFFF                       call mapping_laddr_to_page
  1407                                  
  1408                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
  1409 00001CA0 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
  1409 00001CA9 FF                 
  1410                                  
  1411 00001CAA C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发模式
  1411 00001CB3 00                 
  1412 00001CB4 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
  1412 00001CBD 00                 
  1413                                  
  1414 00001CBE B00B                             mov al, 0x0b                             ;RTC寄存器B
  1415 00001CC0 0C80                             or al, 0x80                              ;阻断NMI
  1416 00001CC2 E670                             out 0x70, al
  1417 00001CC4 B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
  1418 00001CC6 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
  1419                                  
  1420 00001CC8 B08A                             mov al, 0x8a                             ;CMOS寄存器A
  1421 00001CCA E670                             out 0x70, al
  1422                                           ;in al, 0x71
  1423 00001CCC B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
  1424 00001CCE E671                             out 0x71, al                             ;写回CMOS寄存器A
  1425                                  
  1426 00001CD0 B08C                             mov al, 0x8c
  1427 00001CD2 E670                             out 0x70, al
  1428 00001CD4 E471                             in al, 0x71                              ;读寄存器C
  1429                                    .w0:
  1430 00001CD6 E471                             in al, 0x71                              ;读寄存器C
  1431 00001CD8 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
  1432 00001CDD 73F7                             jnc .w0
  1433 00001CDF C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
  1433 00001CE8 FF                 
  1434                                    .w1:
  1435 00001CE9 E471                             in al, 0x71                              ;读寄存器C
  1436 00001CEB 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
  1437 00001CF0 73F7                             jnc .w1
  1438 00001CF2 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
  1439                                  
  1440 00001CF8 B8FFFFFFFF                       mov eax, 0xffff_ffff
  1441 00001CFD 29D0                             sub eax, edx
  1442 00001CFF 31D2                             xor edx, edx
  1443 00001D01 BB7D000000                       mov ebx, 125                             ;125毫秒
  1444 00001D06 F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
  1445                                  
  1446 00001D08 8905(32010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
  1447                                  
  1448 00001D0E B00B                             mov al, 0x0b                             ;RTC寄存器B
  1449 00001D10 0C80                             or al, 0x80                              ;阻断NMI
  1450 00001D12 E670                             out 0x70, al
  1451 00001D14 B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
  1452 00001D16 E671                             out 0x71, al
  1453                                  
  1454                                           ;以下安装新任务认领中断的处理过程
  1455 00001D18 4C8B0D(08000000)                 mov r9, [rel position]
  1456 00001D1F 498D81[12110000]                 lea rax, [r9 + new_task_notify_handler]  ;得到中断处理过程的线性地址
  1457 00001D26 E881E4FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1458                                  
  1459 00001D2B FA                               cli
  1460 00001D2C 41B8FE000000                     mov r8, 0xfe
  1461 00001D32 E8D6E4FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1462 00001D37 FB                               sti
  1463                                  
  1464                                           ;以下安装时间片到期中断的处理过程
  1465 00001D38 4C8B0D(08000000)                 mov r9, [rel position]
  1466 00001D3F 498D81[4D100000]                 lea rax, [r9 + time_slice_out_handler]   ;得到中断处理过程的线性地址
  1467 00001D46 E861E4FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1468                                  
  1469 00001D4B FA                               cli
  1470 00001D4C 41B8FD000000                     mov r8, 0xfd
  1471 00001D52 E8B6E4FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1472 00001D57 FB                               sti
  1473                                  
  1474                                           ;以下安装系统管理中断的处理过程
  1475 00001D58 4C8B0D(08000000)                 mov r9, [rel position]
  1476 00001D5F 498D81[600E0000]                 lea rax, [r9 + system_management_handler]
  1477 00001D66 E841E4FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1478                                  
  1479 00001D6B FA                               cli
  1480 00001D6C 41B8FC000000                     mov r8, 0xfc
  1481 00001D72 E896E4FFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1482 00001D77 FB                               sti
  1483                                  
  1484                                           ;以下开始初始化应用处理器AP。先将初始化代码复制到物理内存最低端的选定位置
  1485 00001D78 488B35(08000000)                 mov rsi, [rel position]
  1486 00001D7F 488DB6[00000000]                 lea rsi, [rsi + section.ap_init_block.start]
  1487 00001D86 BF00F00000                       mov rdi, AP_START_UP_ADDR
  1488 00001D8B B983000000                       mov rcx, ap_init_tail - ap_init
  1489 00001D90 FC                               cld
  1490 00001D91 F3A4                             repe movsb
  1491                                  
  1492                                           ;所有处理器都应当在初始化期间递增应答计数值
  1493 00001D93 FE05(31010000)                   inc byte [rel ack_cpus]                  ;BSP自己的应答计数值
  1494                                  
  1495                                           ;给其它处理器发送INIT IPI和SIPI，命令它们初始化自己
  1496 00001D99 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
  1496 00001DA2 FF                 
  1497 00001DA3 C78610030000000000-              mov dword [rsi + 0x310], 0
  1497 00001DAC 00                 
  1498 00001DAD C7860003000000450C-              mov dword [rsi + 0x300], 0x000c4500      ;先发送INIT IPI
  1498 00001DB6 00                 
  1499                                  
  1500                                           ;以下发送两次Start up IPI
  1501 00001DB7 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600
  1501 00001DC0 00                 
  1502 00001DC1 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600
  1502 00001DCA 00                 
  1503                                  
  1504 00001DCB 8A05(27000000)                   mov al, [rel num_cpus]
  1505                                    .wcpus:
  1506 00001DD1 3A05(31010000)                   cmp al, [rel ack_cpus]
  1507 00001DD7 75F8                             jne .wcpus                               ;等待所有应用处理器的应答
  1508                                  
  1509                                           ;显示已应答的处理器的数量信息
  1510 00001DD9 4C8B3D(08000000)                 mov r15, [rel position]
  1511                                  
  1512 00001DE0 4D31C0                           xor r8, r8
  1513 00001DE3 448A05(31010000)                 mov r8b, [rel ack_cpus]
  1514 00001DEA 498D9F[69010000]                 lea rbx, [r15 + buffer]
  1515 00001DF1 E8E3EDFFFF                       call bin64_to_dec
  1516 00001DF6 E80DE2FFFF                       call put_string64
  1517                                  
  1518 00001DFB 498D9F[58010000]                 lea rbx, [r15 + cpu_init_ok]
  1519 00001E02 E801E2FFFF                       call put_string64                        ;位于core_utils64_mp.wid
  1520                                  
  1521 00001E07 48BF00D0FFFF7FFFFF-              mov rdi, IOAPIC_START_ADDR               ;I/O APIC的线性地址
  1521 00001E10 FF                 
  1522                                  
  1523                                           ;8254定时器。对应I/O APIC的IOREDTBL2
  1524 00001E11 C70714000000                     mov dword [rdi], 0x14                    ;对应8254定时器。
  1525 00001E17 C74710FC000000                   mov dword [rdi + 0x10], 0x000000fc       ;不屏蔽；物理模式；固定模式；向量0xfc
  1526 00001E1E C70715000000                     mov dword [rdi], 0x15
  1527 00001E24 C7471000000000                   mov dword [rdi + 0x10], 0x00000000       ;Local APIC ID：0
  1528                                  
  1529                                           ;以下开始创建系统外壳任务（进程）
  1530 00001E2B 41B832000000                     mov r8, 50
  1531 00001E31 E877F9FFFF                       call create_process
  1532                                  
  1533 00001E36 E92CEFFFFF                       jmp ap_to_core_entry.do_idle             ;去处理器集结休息区 :)
  1534                                  
  1535                                  ;===============================================================================
  1536                                  section ap_init_block vstart=0
  1537                                  
  1538                                           bits 16                                  ;应用处理器AP从实模式开始执行
  1539                                  
  1540                                  ap_init:                                          ;应用处理器AP的初始化代码
  1541 00000000 B8000F                           mov ax, AP_START_UP_ADDR >> 4
  1542 00000003 8ED8                             mov ds, ax
  1543                                  
  1544                                           SET_SPIN_LOCK al, byte [lock_var]        ;自旋直至获得锁
    64                              <1>  %%spin_lock:
    65 00000005 803E[8200]00        <1>  cmp %2, 0
    66 0000000A 7404                <1>  je %%get_lock
    67 0000000C F390                <1>  pause
    68 0000000E EBF5                <1>  jmp %%spin_lock
    69                              <1>  %%get_lock:
    70 00000010 B001                <1>  mov %1, 1
    71 00000012 8606[8200]          <1>  xchg %1, %2
    72 00000016 3C00                <1>  cmp %1, 0
    73 00000018 75EB                <1>  jne %%spin_lock
  1545                                  
  1546 0000001A B8E007                           mov ax, SDA_PHY_ADDR >> 4                ;切换到系统数据区
  1547 0000001D 8ED8                             mov ds, ax
  1548                                  
  1549                                           ;加载描述符表寄存器GDTR
  1550 0000001F 0F01160200                       lgdt [2]                                 ;实模式下只加载6个字节的内容
  1551                                  
  1552 00000024 E492                             in al, 0x92                              ;南桥芯片内的端口
  1553 00000026 0C02                             or al, 0000_0010B
  1554 00000028 E692                             out 0x92, al                             ;打开A20
  1555                                  
  1556 0000002A FA                               cli                                      ;中断机制尚未工作
  1557                                  
  1558 0000002B 0F20C0                           mov eax, cr0
  1559 0000002E 6683C801                         or eax, 1
  1560 00000032 0F22C0                           mov cr0, eax                             ;设置PE位
  1561                                  
  1562                                           ;以下进入保护模式... ...
  1563 00000035 EA[3AF0]0800                     jmp 0x0008: AP_START_UP_ADDR + .flush    ;清流水线并串行化处理器
  1564                                  
  1565                                           [bits 32]
  1566                                    .flush:
  1567 0000003A B810000000                       mov eax, 0x0010                          ;加载数据段(4GB)选择子
  1568 0000003F 8ED0                             mov ss, eax                              ;加载堆栈段(4GB)选择子
  1569 00000041 BC007E0000                       mov esp, 0x7e00                          ;堆栈指针
  1570                                  
  1571                                           ;令CR3寄存器指向4级头表（保护模式下的32位CR3）
  1572 00000046 B800A00000                       mov eax, PML4_PHY_ADDR                   ;PCD=PWT=0
  1573 0000004B 0F22D8                           mov cr3, eax
  1574                                  
  1575                                           ;开启物理地址扩展PAE
  1576 0000004E 0F20E0                           mov eax, cr4
  1577 00000051 0FBAE805                         bts eax, 5
  1578 00000055 0F22E0                           mov cr4, eax
  1579                                  
  1580                                           ;设置型号专属寄存器IA32_EFER.LME，允许IA_32e模式
  1581 00000058 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
  1582 0000005D 0F32                             rdmsr
  1583 0000005F 0FBAE808                         bts eax, 8                               ;设置LME位
  1584 00000063 0F30                             wrmsr
  1585                                  
  1586                                           ;开启分页功能
  1587 00000065 0F20C0                           mov eax, cr0
  1588 00000068 0FBAE81F                         bts eax, 31                              ;置位CR0.PG
  1589 0000006C 0F22C0                           mov cr0, eax
  1590                                  
  1591                                           ;进入64位模式
  1592 0000006F EA[76F00000]1800                 jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
  1593                                    .to64:
  1594                                  
  1595                                           bits 64
  1596                                  
  1597                                           ;转入内核中继续初始化（使用高端线性地址）
  1598 00000076 48BB-                            mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
  1598 00000078 [440C02000080FFFF] 
  1599 00000080 FFE3                             jmp rbx
  1600                                  
  1601 00000082 00                        lock_var  db 0
  1602                                  
  1603                                  ap_init_tail:
  1604                                  
  1605                                  ;===============================================================================
  1606                                  section core_tail
  1607                                  core_end:
